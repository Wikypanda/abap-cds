<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>34 OO Design Patterns - ABAP Cheat Sheet</title>
    <style>

        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 20px;
        }
        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #95a5a6;
            padding-bottom: 8px;
            margin-top: 30px;
        }
        h3 {
            color: #34495e;
            margin-top: 25px;
        }
        h4, h5, h6 {
            color: #34495e;
            margin-top: 20px;
        }
        p {
            margin: 10px 0;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Consolas, Monaco, monospace;
            color: #c7254e;
            font-size: 0.9em;
        }
        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9em;
            line-height: 1.5;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 30px;
        }
        li {
            margin: 5px 0;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
            color: #2980b9;
        }
        hr {
            border: none;
            border-top: 2px solid #bdc3c7;
            margin: 30px 0;
        }
        .note {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 12px;
            margin: 15px 0;
            border-radius: 4px;
        }
        blockquote {
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin: 15px 0;
            color: #555;
            font-style: italic;
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            table {
                font-size: 0.9em;
            }
            th, td {
                padding: 8px;
            }
        }
    
    </style>
</head>
<body>
<p>&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;</p>
<h1>ABAP Examples Using Object-Oriented Design Patterns</h1>
<ul>
<li><a href="#abap-examples-using-object-oriented-design-patterns">ABAP Examples Using Object-Oriented Design Patterns</a></li>
<li><a href="#example-setup-and-running-example-classes">Example Setup and Running Example Classes</a></li>
<li><a href="#abap-unit-test-double-injection-techniques">ABAP Unit Test Double Injection Techniques</a></li>
<li><a href="#backdoor-injection">Backdoor Injection</a></li>
<li><a href="#constructor-injection">Constructor Injection</a></li>
<li><a href="#parameter-injection">Parameter Injection</a></li>
<li><a href="#setter-injection">Setter Injection</a></li>
<li><a href="#test-double-injection-using-inheritance-and-method-redefinition">Test Double Injection Using Inheritance and Method Redefinition</a></li>
<li><a href="#abstract-factory">Abstract Factory</a></li>
<li><a href="#adapter">Adapter</a></li>
<li><a href="#bridge">Bridge</a></li>
<li><a href="#builder">Builder</a></li>
<li><a href="#chain-of-responsibility">Chain of Responsibility</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#composite">Composite</a></li>
<li><a href="#data-access-object-dao">Data Access Object (DAO)</a></li>
<li><a href="#decorator">Decorator</a></li>
<li><a href="#facade">Facade</a></li>
<li><a href="#factory-method">Factory Method</a></li>
<li><a href="#fluent-interface">Fluent Interface</a></li>
<li><a href="#flyweight">Flyweight</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#mediator">Mediator</a></li>
<li><a href="#memento">Memento</a></li>
<li><a href="#multiton">Multiton</a></li>
<li><a href="#observer">Observer</a></li>
<li><a href="#prototype">Prototype</a></li>
<li><a href="#proxy">Proxy</a></li>
<li><a href="#singleton">Singleton</a></li>
<li><a href="#state">State</a></li>
<li><a href="#strategy">Strategy</a></li>
<li><a href="#template-method">Template Method</a></li>
<li><a href="#visitor">Visitor</a></li>
</ul>
<p>This ABAP cheat sheet includes a selection of design patterns you may have come across in object-oriented programming. It serves as an excursion. Unlike other ABAP cheat sheets, it does not cover ABAP-specific topics as such. Instead, it includes ABAP code explorations and experiments related to various design patterns.</p>
<p>Design patterns address common software design challenges, aiming to improve modularity, scalability, reusability, and more. The examples largely draw inspiration from design patterns established by the <em>Gang of Four</em> (GoF), applicable across different object-oriented programming languages. Apart from selected, renowned GoF patterns, the sheet also includes a random selection of other techniques.</p>
<div class="note">[!IMPORTANT] - The focus of the examples - which are also available via a separate repository branch ([oo_patterns](https://github.com/SAP-samples/abap-cheat-sheets/tree/oo_patterns)) - in the ABAP cheat sheet is on basic conceptual considerations regarding the design patterns, and experimenting with ABAP syntax and concepts (such as interfaces, abstract classes, encapsulation, and more). The examples aim to illustrate basic design pattern ideas using simplified ABAP demo classes. - The examples are meant for [exploration, experimentation, and demonstration](./README.md#%EF%B8%8F-disclaimer), using non-semantic and non-real-world contexts to reduce complexity and give a rough idea. Due to their experimental nature, these examples do not represent best practices or model approaches, as various approaches and class setup strategies may apply. It is up to you to evaluate whether the patterns are suitable and beneficial for your setup. Always create your own solutions. The cheat sheet does not go into the details regarding the patterns' origins, purposes, real-world examples, similarities, differences, combinations of patterns, pros, or cons.</div>
<div class="note">[!TIP] The cheat sheet includes copy and paste example classes. These are included in the [oo_patterns](https://github.com/SAP-samples/abap-cheat-sheets/tree/oo_patterns) branch of the repository. Find more information [here](https://github.com/SAP-samples/abap-cheat-sheets/blob/oo_patterns/README.md) regarding the import.</div>
<h2>Example Setup and Running Example Classes</h2>
<p>Most examples are set up for easy exploration using simple, (mostly) self-contained ABAP classes, i.e. there is only one class pool including local classes/interfaces instead of multiple global classes/interfaces:</p>
<ul>
<li>Global class (<em>Global Class</em> tab in ADT):</li>
<li>Includes the <code>if_oo_adt_classrun</code> interface to run the class with F9 in ADT.</li>
<li>Serves as the client that makes use of the local classes to demonstrate design patterns. Largely, the declarations and implementations in the CCIMP include are relevant for the conceptual considerations.</li>
<li>CCIMP include (<em>Local Types</em> tab in ADT):</li>
<li>Contains various local classes/interfaces to demonstrate design patterns, allowing quick copying and pasting without creating multiple global classes.</li>
</ul>
<p>In the following sections, click the expandable sections for further descriptions and example code. To try the examples out, create a demo class named <code>zcl_demo_abap</code> and paste the code into it (<em>Global Class</em> and <em>Local Types</em> tabs in ADT). After activation, choose <em>F9</em> in ADT to execute the class. The examples are set up to display output in the console.</p>
<div class="note">[!NOTE] - Some examples use artifacts such as database tables from the `main` branch of the ABAP cheat sheet GitHub repository. The [oo_patterns](https://github.com/SAP-samples/abap-cheat-sheets/tree/oo_patterns) branch of the repository also contains the example classes. This branch is designed to function independently from the `main` branch (for example, the said, few database tables are duplicated and renamed). Therefore, you can clone the `oo_patterns` branch without also cloning the `main` branch, or clone the `oo_patterns` branch without dependencies (such as name conflicts with already existing artifacts, in case the artifacts of the `main` branch have already been imported). - [Disclaimer](./README.md#%EF%B8%8F-disclaimer)</div>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>ABAP Unit Test Double Injection Techniques</h2>
<p>The following sections cover injection techniques that can be applied in the context of ABAP Unit. As described <a href="https://help.sap.com/docs/ABAP_PLATFORM_NEW/c238d694b825421f940829321ffa326a/04a2d0fc9cd940db8aedf3fa29e5f07e.html?locale=en-US">here</a>, multiple techniques exist for injecting test doubles into a class under test to ensure their usage during test execution. Also find more information in the <a href="14_ABAP_Unit_Tests.md">ABAP Unit Tests</a> cheat sheet.</p>
<h3>Backdoor Injection</h3>
<ul>
<li>A sample setup to inject test doubles, as illustrated in the example, may look as follows:</li>
<li>A dependent-on component (DOC) is identified (for example, reading data from a database table).</li>
<li>Ideally, an interface to the DOC is available (here, a local interface is used). A data provider class implements this interface for the data provisioning (here, a local class is used).</li>
<li>The class under test has been prepared. This example uses:</li>
<li>A private instance attribute declared with a reference to the interface.</li>
<li>The method to be tested calls a method via this interface reference variable for the data retrieval.</li>
<li>The class&#x27;s instance contructor assigns the interface reference variable by creating an object of the data provider class, which implements the interface.</li>
<li>The test class may be implemented as follows:</li>
<li>Since private attributes are not accessible in local test classes, the local test class is declared as a local friend of the global class.</li>
<li>In the test method, an object of the class under test and a test double are created. The test double is declared with a reference to the interface (here, a local class is used that creates a test double). The private attribute is then assigned the test double, realizing the backdoor injection.</li>
<li>The effect is as follows: When the method to be tested is called &quot;regularly&quot; (for example, when executing the class using <em>F9</em>, as in the example case), the object refers to the &quot;regular&quot; data provider (in this example, it is of type <code>lcl_data_provider</code>), which means it uses production data. However, when the unit test is executed (for example, by choosing <em>Ctrl/Cmd + Shift + F10</em>), the object refers to the test double (in this case, of type <code>ltd_test_data</code>), which is the local test double that gets injected.</li>
</ul>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p>Unlike other examples, this example class has a different setup:</p>
<ul>
<li>It focuses on ABAP Unit tests. You can indeed execute the simple example class by choosing <em>F9</em>. To run the unit test, use <em>Ctrl/Cmd + Shift + F10</em>.</li>
<li>The example class includes code from the global class and the CCIMP include, as well as the CCDEF (<em>Class-relevant Local Types</em> tab in ADT) and CCAU (<em>Test Classes</em> tab in ADT) includes.</li>
<li>The example uses a demo database table (and a class to populate it) from the ABAP Cheat Sheet GitHub repository.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.

    TYPES: carr_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY,
           occ_rate TYPE p LENGTH 5 DECIMALS 2.

    CLASS-METHODS class_constructor.

    METHODS: constructor,
      &quot;Method to demonstrate test double injection using back door injection
      get_occ_rate IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                   RETURNING VALUE(occupancy_rate) TYPE occ_rate.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA data_provider TYPE REF TO lif_get_data.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Filling an internal table with carrier IDs used to calculate
    &quot;the occupancy rate.
    DATA(carrier_tab) = VALUE carr_tab( ( carrid = &#x27;LH&#x27; )
                                        ( carrid = &#x27;AA&#x27; )
                                        ( carrid = &#x27;DL&#x27; ) ).

    LOOP AT carrier_tab INTO DATA(carr).
      DATA(oc_rate) = get_occ_rate( carr-carrid ).

      out-&gt;write( |The occupancy rate for airline { carr-carrid } is { oc_rate }%.|  ).
      out-&gt;write( |\n| ).
    ENDLOOP.

  ENDMETHOD.

  METHOD class_constructor.
    &quot;Filling demo database tables.
    zcl_demo_abap_aux=&gt;fill_dbtabs( ).
  ENDMETHOD.

  METHOD get_occ_rate.

    DATA total_seatsmax TYPE i.
    DATA total_seatsocc TYPE i.

    &quot;When the method to be tested is called &quot;regularly&quot; (for example, when executing the class using F9),
    &quot;the object refers to the &quot;regular&quot; data provider (type ref to lcl_data_provider), which means it uses
    &quot;production data. However, when the unit test is executed (for example, by choosing Ctrl/Cmd + Shift + F10),
    &quot;the object refers to the test double (type ref to ltd_test_data), which is the local test double that gets
    &quot;injected.
    DATA(flight_data) = data_provider-&gt;select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data INTO DATA(wa).
      total_seatsmax = total_seatsmax + wa-seatsmax.
      total_seatsocc = total_seatsocc + wa-seatsocc.
    ENDLOOP.

    occupancy_rate = total_seatsocc / total_seatsmax * 100.
  ENDMETHOD.

  METHOD constructor.
    data_provider = NEW lcl_data_provider( ).
  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCDEF include (Class-relevant Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>INTERFACE lif_get_data.
  METHODS:
    select_flight_data IMPORTING carrier            TYPE zdemo_abap_fli-carrid
                       RETURNING VALUE(flight_data) TYPE zcl_demo_abap=&gt;carr_tab.
ENDINTERFACE.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl_data_provider DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_get_data.
ENDCLASS.

CLASS lcl_data_provider IMPLEMENTATION.
  METHOD lif_get_data~select_flight_data.
    SELECT seatsmax, seatsocc
      FROM zdemo_abap_fli
      WHERE carrid = @carrier
      INTO CORRESPONDING FIELDS OF TABLE @flight_data.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCAU include (Test Classes tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Local test double class
*&amp;---------------------------------------------------------------------*

&quot;The example uses manually created test doubles. You may also want to
&quot;check out creating test doubles using ABAP frameworks. Find more
&quot;information in the ABAP Unit Tests cheat sheet.

CLASS ltd_test_data DEFINITION FOR TESTING.
  PUBLIC SECTION.
    INTERFACES lif_get_data.
ENDCLASS.

CLASS ltd_test_data IMPLEMENTATION.
  METHOD lif_get_data~select_flight_data.

    flight_data = SWITCH #( carrier
      WHEN &#x27;IJ&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 300 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 300 ) )
      WHEN &#x27;KL&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 350 seatsocc = 300 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 250 )
                              ( carrid = carrier  seatsmax = 300 seatsocc = 250 ) ) ).

  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Test class demonstrating backdoor injection
*&amp;---------------------------------------------------------------------*

&quot;Note that the example uses a local interface.

CLASS ltc_test DEFINITION
  FOR TESTING RISK LEVEL HARMLESS
  DURATION SHORT.
  PRIVATE SECTION.
    METHODS test_get_occ_rate FOR TESTING.
ENDCLASS.

&quot;In this example, a test class is created in the test include. Since private
&quot;attributes are not accessible in local test classes, the local test class
&quot;is declared as a local friend of the global class.
CLASS zcl_demo_abap DEFINITION LOCAL FRIENDS ltc_test.

CLASS ltc_test IMPLEMENTATION.
  METHOD test_get_occ_rate.
    DATA(ref_cut) = NEW zcl_demo_abap( ).
    DATA ref_data_prov TYPE REF TO lif_get_data.
    ref_data_prov = NEW ltd_test_data( ).
    ref_cut-&gt;data_provider = ref_data_prov.

    DATA(act_occ_rate) = ref_cut-&gt;get_occ_rate( &#x27;IJ&#x27; ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;70.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;IJ&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).

    act_occ_rate = ref_cut-&gt;get_occ_rate( &#x27;KL&#x27; ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;80.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;KL&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h3>Constructor Injection</h3>
<ul>
<li>Here, the test double is passed as a parameter to the instance constructor of the class under test.</li>
<li>A sample setup to inject test doubles, as illustrated in the example, may look as follows:</li>
<li>A dependent-on component (DOC) is identified (for example, reading data from a database table).</li>
<li>Ideally, an interface to the DOC is available. A data provider class implements this interface for the data provisioning.</li>
<li>The class under test has been prepared. This example uses:</li>
<li>A private instance attribute declared with a reference to the interface.</li>
<li>The method to be tested calls a method via this interface reference variable for the data retrieval.</li>
<li>The class&#x27;s instance contructor is declared with an optional parameter referencing the interface. When an object of the class is created, the interface reference variable is assigned appropriately, i.e. using the &quot;regular&quot; data provider or the test double.</li>
<li>The test class may be implemented as follows:</li>
<li>Since private attributes are not accessible in local test classes, the local test class is declared as a local friend of the global class.</li>
<li>In the test method, an object of the class under test and a test double are created. The test double is declared with a reference to the interface (here, a local class is used that creates a test double). By creating an object of the class under test, the test double is passed as parameter of the instance constructor.</li>
<li>The effect is as follows: When the method to be tested is called &quot;regularly&quot; (for example, when executing the class using <em>F9</em>, as in the example case), the object refers to the &quot;regular&quot; data provider (in this example, it is of type <code>lcl_data_provider</code>), which means it uses production data (an object is created in the instance constrctor implementation accordingly). However, when the unit test is executed (for example, by choosing <em>Ctrl/Cmd + Shift + F10</em>), the object refers to the test double (in this case, of type <code>ltd_test_data</code>), which is the local test double that gets injected via the constructor. In the instance constructor implementation, the instance attribute is assigned the reference to the test double.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p>Unlike other examples, this example class has a different setup:</p>
<ul>
<li>It focuses on ABAP Unit tests. You can indeed execute the simple example class by choosing <em>F9</em>. To run the unit test, use <em>Ctrl/Cmd + Shift + F10</em>.</li>
<li>The example class includes code from the global class, the CCIMP and CCAU (<em>Test Classes</em> tab in ADT) includes.</li>
<li>The example uses a demo database table (and a class to populate it) and a global interface from the ABAP cheat sheet GitHub repository.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.

    TYPES: carr_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY,
           occ_rate TYPE p LENGTH 5 DECIMALS 2.

    CLASS-METHODS class_constructor.
    METHODS: constructor IMPORTING iref_data_prov TYPE REF TO zdemo_abap_get_data_itf OPTIONAL,
      get_occ_rate IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                   RETURNING VALUE(occupancy_rate) TYPE occ_rate.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA data_provider TYPE REF TO zdemo_abap_get_data_itf.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Filling an internal table with carrier IDs used to calculate
    &quot;the occupancy rate.
    DATA(carrier_tab) = VALUE carr_tab( ( carrid = &#x27;LH&#x27; )
                                        ( carrid = &#x27;AA&#x27; )
                                        ( carrid = &#x27;DL&#x27; ) ).

    LOOP AT carrier_tab INTO DATA(carr).
      DATA(oc_rate) = get_occ_rate( carr-carrid ).

      out-&gt;write( |The occupancy rate for airline { carr-carrid } is { oc_rate }%.|  ).
      out-&gt;write( |\n| ).
    ENDLOOP.

  ENDMETHOD.

  METHOD class_constructor.
    &quot;Filling demo database tables.
    zcl_demo_abap_aux=&gt;fill_dbtabs( ).
  ENDMETHOD.

  METHOD get_occ_rate.
    DATA total_seatsmax TYPE i.
    DATA total_seatsocc TYPE i.

    DATA(flight_data) = data_provider-&gt;select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data INTO DATA(wa).
      total_seatsmax = total_seatsmax + wa-seatsmax.
      total_seatsocc = total_seatsocc + wa-seatsocc.
    ENDLOOP.

    occupancy_rate = total_seatsocc / total_seatsmax * 100.
  ENDMETHOD.

  METHOD constructor.
    IF iref_data_prov IS BOUND.
      data_provider = iref_data_prov.
    ELSE.
      data_provider = NEW lcl_data_provider( ).
    ENDIF.
  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl_data_provider DEFINITION.
  PUBLIC SECTION.
    INTERFACES zdemo_abap_get_data_itf.
ENDCLASS.

CLASS lcl_data_provider IMPLEMENTATION.
  METHOD zdemo_abap_get_data_itf~select_flight_data.
    SELECT seatsmax, seatsocc
      FROM zdemo_abap_fli
      WHERE carrid = @carrier
      INTO CORRESPONDING FIELDS OF TABLE @flight_data.
  ENDMETHOD.

  METHOD zdemo_abap_get_data_itf~say_hello.
   &quot;The implementation is not relevant for the example.
   &quot;See the executable example of the ABAP Unit Tests cheat sheet.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCAU include (Test Classes tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Local test double class
*&amp;---------------------------------------------------------------------*

&quot;The example uses manually created test doubles. You may also want to
&quot;check out creating test doubles using ABAP frameworks. Find more
&quot;information in the ABAP Unit Tests cheat sheet.

CLASS ltd_test_data DEFINITION FOR TESTING.
  PUBLIC SECTION.
    INTERFACES zdemo_abap_get_data_itf PARTIALLY IMPLEMENTED.
ENDCLASS.

CLASS ltd_test_data IMPLEMENTATION.
  METHOD zdemo_abap_get_data_itf~select_flight_data.

    flight_data = SWITCH #( carrier
      WHEN &#x27;IJ&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 300 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 300 ) )
      WHEN &#x27;KL&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 350 seatsocc = 300 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 250 )
                              ( carrid = carrier  seatsmax = 300 seatsocc = 250 ) ) ).

  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Test class demonstrating constructor injection
*&amp;---------------------------------------------------------------------*

&quot;Note that the example uses a local interface.

CLASS ltc_test DEFINITION
  FOR TESTING RISK LEVEL HARMLESS
  DURATION SHORT.
  PRIVATE SECTION.
    METHODS test_get_occ_rate FOR TESTING.
ENDCLASS.

&quot;In this example, a test class is created in the test include. Since private
&quot;attributes are not accessible in local test classes, the local test class
&quot;is declared as a local friend of the global class.
CLASS zcl_demo_abap DEFINITION LOCAL FRIENDS ltc_test.

CLASS ltc_test IMPLEMENTATION.
  METHOD test_get_occ_rate.
    DATA ref_data_prov TYPE REF TO zdemo_abap_get_data_itf.

    &quot;Creating an instance of the local test double
    ref_data_prov = NEW ltd_test_data( ).

    &quot;Instance is provided for the constructor injection
    DATA(ref_cut) = NEW zcl_demo_abap( ref_data_prov ).

    DATA(act_occ_rate) = ref_cut-&gt;get_occ_rate( carrier_id = &#x27;IJ&#x27; ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;70.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;IJ&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).

    act_occ_rate = ref_cut-&gt;get_occ_rate( carrier_id = &#x27;KL&#x27; ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;80.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;KL&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h3>Parameter Injection</h3>
<ul>
<li>Here, the test double is passed as a parameter to the tested method (i.e. an optional importing parameter) in the class under test.</li>
<li>A sample setup to inject test doubles, as illustrated in the example, may look as follows:</li>
<li>A dependent-on component (DOC) is identified (for example, reading data from a database table).</li>
<li>Ideally, an interface to the DOC is available (here, a local interface is used). A data provider class implements this interface for the data provisioning (here, a local class is used).</li>
<li>The class under test has been prepared. The method to be tested:</li>
<li>Calls a method via an interface reference variable for the data retrieval.</li>
<li>Is defined with an optional parameter. It is typed with reference to the interface.</li>
<li>Includes a check whether the optional parameter is bound.</li>
<li>Note: To use the local demo interface in the signature, the method is defined in the private visibility section.</li>
<li>The test class may be implemented as follows:</li>
<li>Since private attributes are not accessible in local test classes, the local test class is declared as a local friend of the global class.</li>
<li>In the test method, an object of the class under test and a test double are created. The test double is declared with a reference to the interface (here, a local class is used that creates a test double).</li>
<li>The effect is as follows: When the method to be tested is called &quot;regularly&quot; (for example, when executing the class using <em>F9</em>, as in the example case) without passing the optional parameter, an object of the &quot;regular&quot; data provider (in this example, it is of type <code>lcl_data_provider</code>) is created following the evaluation of the <code>IF</code> statement, which means it uses production data. However, when the unit test is executed (for example, by choosing <em>Ctrl/Cmd + Shift + F10</em>) and the optional parameter is supplied, the parameter is bound and, thus, uses the test double (in this case, of type <code>ltd_test_data</code>), which gets injected via the parameter.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p>Unlike other examples, this example class has a different setup:</p>
<ul>
<li>It focuses on ABAP Unit tests. You can indeed execute the simple example class by choosing <em>F9</em>. To run the unit test, use <em>Ctrl/Cmd + Shift + F10</em>.</li>
<li>The example class includes code from the global class and the CCIMP include, as well as the CCDEF (<em>Class-relevant Local Types</em> tab in ADT) and CCAU (<em>Test Classes</em> tab in ADT) includes.</li>
<li>The example uses a demo database table (and a class to populate it) from the ABAP Cheat Sheet GitHub repository.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.

    TYPES: carr_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY,
           occ_rate TYPE p LENGTH 5 DECIMALS 2.

    CLASS-METHODS class_constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.
    &quot;Method to demonstrate test double injection using parameter injection
    &quot;The example uses a private method to refer to a local interface.
    METHODS  get_occ_rate IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                                    data_prov             TYPE REF TO lif_get_data OPTIONAL
                          RETURNING VALUE(occupancy_rate) TYPE occ_rate.

    &quot; DATA data_provider TYPE REF TO lif_get_data.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Filling an internal table with carrier IDs used to calculate
    &quot;the occupancy rate.
    DATA(carrier_tab) = VALUE carr_tab( ( carrid = &#x27;LH&#x27; )
                                        ( carrid = &#x27;AA&#x27; )
                                        ( carrid = &#x27;DL&#x27; ) ).

    LOOP AT carrier_tab INTO DATA(carr).
      DATA(oc_rate) = get_occ_rate( carr-carrid ).

      out-&gt;write( |The occupancy rate for airline { carr-carrid } is { oc_rate }%.|  ).
      out-&gt;write( |\n| ).
    ENDLOOP.

  ENDMETHOD.

  METHOD class_constructor.
    &quot;Filling demo database tables.
    zcl_demo_abap_aux=&gt;fill_dbtabs( ).
  ENDMETHOD.

  METHOD get_occ_rate.

    DATA total_seatsmax TYPE i.
    DATA total_seatsocc TYPE i.
    DATA data_provider TYPE REF TO lif_get_data.

    &quot;The method has an optional importing parameter. When the unit test is executed,
    &quot;the parameter is bound. An object of the test double class is passed in that case.
    &quot;Otherwise, when the class is executed using F9, an object of the actual data provider
    &quot;is created.
    IF data_prov IS BOUND.
      data_provider = data_prov.
    ELSE.
      data_provider = NEW lcl_data_provider( ).
    ENDIF.

    DATA(flight_data) = data_provider-&gt;select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data INTO DATA(wa).
      total_seatsmax = total_seatsmax + wa-seatsmax.
      total_seatsocc = total_seatsocc + wa-seatsocc.
    ENDLOOP.

    occupancy_rate = total_seatsocc / total_seatsmax * 100.
  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCDEF include (Class-relevant Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>INTERFACE lif_get_data.
  METHODS:
    select_flight_data IMPORTING carrier            TYPE zdemo_abap_fli-carrid
                       RETURNING VALUE(flight_data) TYPE zcl_demo_abap=&gt;carr_tab.
ENDINTERFACE.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl_data_provider DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_get_data.
ENDCLASS.

CLASS lcl_data_provider IMPLEMENTATION.
  METHOD lif_get_data~select_flight_data.
    SELECT seatsmax, seatsocc
      FROM zdemo_abap_fli
      WHERE carrid = @carrier
      INTO CORRESPONDING FIELDS OF TABLE @flight_data.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCAU include (Test Classes tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Local test double class
*&amp;---------------------------------------------------------------------*

&quot;The example uses manually created test doubles. You may also want to
&quot;check out creating test doubles using ABAP frameworks. Find more
&quot;information in the ABAP Unit Tests cheat sheet.

CLASS ltd_test_data DEFINITION FOR TESTING.
  PUBLIC SECTION.
    INTERFACES lif_get_data PARTIALLY IMPLEMENTED.
ENDCLASS.

CLASS ltd_test_data IMPLEMENTATION.
  METHOD lif_get_data~select_flight_data.

    flight_data = SWITCH #( carrier
      WHEN &#x27;IJ&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 300 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 300 ) )
      WHEN &#x27;KL&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 350 seatsocc = 300 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 250 )
                              ( carrid = carrier  seatsmax = 300 seatsocc = 250 ) ) ).

  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Test class demonstrating parameter injection
*&amp;---------------------------------------------------------------------*

&quot;Note that the example uses a local interface.

CLASS ltc_test DEFINITION
  FOR TESTING RISK LEVEL HARMLESS
  DURATION SHORT.
  PRIVATE SECTION.
    METHODS test_get_occ_rate FOR TESTING.
ENDCLASS.

&quot;In this example, a test class is created in the test include. Since private
&quot;attributes are not accessible in local test classes, the local test class
&quot;is declared as a local friend of the global class.
CLASS zcl_demo_abap DEFINITION LOCAL FRIENDS ltc_test.

CLASS ltc_test IMPLEMENTATION.
  METHOD test_get_occ_rate.
    DATA(ref_cut) = NEW zcl_demo_abap( ).
    DATA ref_data_prov TYPE REF TO lif_get_data.
    ref_data_prov = NEW ltd_test_data( ).

    DATA(act_occ_rate) = ref_cut-&gt;get_occ_rate( carrier_id = &#x27;IJ&#x27;
                                                data_prov  = ref_data_prov ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;70.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;IJ&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).

    act_occ_rate = ref_cut-&gt;get_occ_rate( carrier_id = &#x27;KL&#x27;
                                          data_prov  = ref_data_prov ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;80.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;KL&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h3>Setter Injection</h3>
<ul>
<li>Here, the test double is passed as a parameter to a setter method.</li>
<li>A sample setup to inject test doubles, as illustrated in the example, may look as follows:</li>
<li>A dependent-on component (DOC) is identified (for example, reading data from a database table).</li>
<li>Ideally, an interface to the DOC is available (here, a local interface is used). A data provider class implements this interface for the data provisioning (here, a local class is used).</li>
<li>The class under test has been prepared. This example uses:</li>
<li>A private instance attribute declared with a reference to the interface.</li>
<li>The method to be tested calls a method via this interface reference variable for the data retrieval.</li>
<li>The class&#x27;s instance contructor assigns the interface reference variable by creating an object of the data provider class, which implements the interface.</li>
<li>A setter method is declared which expects a reference to the interface to be passed. To use the local demo interface in the signature, the setter method is defined in the private visibility section.</li>
<li>The test class may be implemented as follows:</li>
<li>Since private attributes are not accessible in local test classes, the local test class is declared as a local friend of the global class.</li>
<li>In the test method, an object of the class under test and a test double are created. The test double is declared with a reference to the interface (here, a local class is used that creates a test double). The setter method is called, passing the test double. Following the setter method implementation, the interface reference variable is assigned the test double.</li>
<li>The effect is as follows: When the method to be tested is called &quot;regularly&quot; (for example, when executing the class using <em>F9</em>, as in the example case), the object refers to the &quot;regular&quot; data provider (in this example, it is of type <code>lcl_data_provider</code>), which means it uses production data. However, when the unit test is executed (for example, by choosing <em>Ctrl/Cmd + Shift + F10</em>), the object refers to the test double (in this case, of type <code>ltd_test_data</code>), which is the local test double that gets injected via the setter method.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p>Unlike other examples, this example class has a different setup:</p>
<ul>
<li>It focuses on ABAP Unit tests. You can indeed execute the simple example class by choosing <em>F9</em>. To run the unit test, use <em>Ctrl/Cmd + Shift + F10</em>.</li>
<li>The example class includes code from the global class and the CCIMP include, as well as the CCDEF (<em>Class-relevant Local Types</em> tab in ADT) and CCAU (<em>Test Classes</em> tab in ADT) includes.</li>
<li>The example uses a demo database table (and a class to populate it) from the ABAP Cheat Sheet GitHub repository.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.

    TYPES: carr_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY,
           occ_rate TYPE p LENGTH 5 DECIMALS 2.

    CLASS-METHODS class_constructor.
    METHODS: constructor,
            get_occ_rate IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                         RETURNING VALUE(occupancy_rate) TYPE occ_rate.

  PROTECTED SECTION.
  PRIVATE SECTION.
    &quot;Method for setter injection
    METHODS setter_meth IMPORTING data_prov TYPE REF TO lif_get_data.

    DATA data_provider TYPE REF TO lif_get_data.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Filling an internal table with carrier IDs used to calculate
    &quot;the occupancy rate.
    DATA(carrier_tab) = VALUE carr_tab( ( carrid = &#x27;LH&#x27; )
                                        ( carrid = &#x27;AA&#x27; )
                                        ( carrid = &#x27;DL&#x27; ) ).

    LOOP AT carrier_tab INTO DATA(carr).
      DATA(oc_rate) = get_occ_rate( carr-carrid ).

      out-&gt;write( |The occupancy rate for airline { carr-carrid } is { oc_rate }%.|  ).
      out-&gt;write( |\n| ).
    ENDLOOP.

  ENDMETHOD.

  METHOD class_constructor.
    &quot;Filling demo database tables.
    zcl_demo_abap_aux=&gt;fill_dbtabs( ).
  ENDMETHOD.

  METHOD get_occ_rate.
    DATA total_seatsmax TYPE i.
    DATA total_seatsocc TYPE i.

    DATA(flight_data) = data_provider-&gt;select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data INTO DATA(wa).
      total_seatsmax = total_seatsmax + wa-seatsmax.
      total_seatsocc = total_seatsocc + wa-seatsocc.
    ENDLOOP.

    occupancy_rate = total_seatsocc / total_seatsmax * 100.
  ENDMETHOD.

  METHOD setter_meth.
    &quot;When the unit test is executed, an object of the test double class is passed as
    &quot;parameter. Then, the object used here refers the local test double.
    data_provider = data_prov.
  ENDMETHOD.

  METHOD constructor.
    data_provider = NEW lcl_data_provider( ).
  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCDEF include (Class-relevant Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>INTERFACE lif_get_data.
  METHODS:
    select_flight_data IMPORTING carrier            TYPE zdemo_abap_fli-carrid
                       RETURNING VALUE(flight_data) TYPE zcl_demo_abap=&gt;carr_tab.
ENDINTERFACE.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl_data_provider DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_get_data.
ENDCLASS.

CLASS lcl_data_provider IMPLEMENTATION.
  METHOD lif_get_data~select_flight_data.
    SELECT seatsmax, seatsocc
      FROM zdemo_abap_fli
      WHERE carrid = @carrier
      INTO CORRESPONDING FIELDS OF TABLE @flight_data.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCAU include (Test Classes tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Local test double class
*&amp;---------------------------------------------------------------------*

&quot;The example uses manually created test doubles. You may also want to
&quot;check out creating test doubles using ABAP frameworks. Find more
&quot;information in the ABAP Unit Tests cheat sheet.

CLASS ltd_test_data DEFINITION FOR TESTING.
  PUBLIC SECTION.
    INTERFACES lif_get_data PARTIALLY IMPLEMENTED.
ENDCLASS.

CLASS ltd_test_data IMPLEMENTATION.
  METHOD lif_get_data~select_flight_data.

    flight_data = SWITCH #( carrier
      WHEN &#x27;IJ&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 300 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 300 ) )
      WHEN &#x27;KL&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 350 seatsocc = 300 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 250 )
                              ( carrid = carrier  seatsmax = 300 seatsocc = 250 ) ) ).

  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Test class demonstrating setter injection
*&amp;---------------------------------------------------------------------*

&quot;Note that the example uses a local interface.

CLASS ltc_test DEFINITION
  FOR TESTING RISK LEVEL HARMLESS
  DURATION SHORT.
  PRIVATE SECTION.
    METHODS test_get_occ_rate FOR TESTING.
ENDCLASS.

&quot;In this example, a test class is created in the test include. Since private
&quot;attributes are not accessible in local test classes, the local test class
&quot;is declared as a local friend of the global class.
CLASS zcl_demo_abap DEFINITION LOCAL FRIENDS ltc_test.

CLASS ltc_test IMPLEMENTATION.
  METHOD test_get_occ_rate.
    DATA(ref_cut) = NEW zcl_demo_abap( ).
    DATA ref_data_prov TYPE REF TO lif_get_data.
    ref_data_prov = NEW ltd_test_data( ).
    &quot;Passing the test double as a parameter of a setter method
    ref_cut-&gt;setter_meth( ref_data_prov ).

    DATA(act_occ_rate) = ref_cut-&gt;get_occ_rate( carrier_id = &#x27;IJ&#x27; ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;70.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;IJ&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).

    act_occ_rate = ref_cut-&gt;get_occ_rate( carrier_id = &#x27;KL&#x27; ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;80.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;KL&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h3>Test Double Injection Using Inheritance and Method Redefinition</h3>
<ul>
<li>This ABAP Unit test double injection technique makes use of inheritance and redefining methods.</li>
<li>Here, a local test double class is created by redefining a method of the class under test.</li>
<li>A sample setup to inject test doubles, as illustrated in the example, may look as follows:</li>
<li>A dependent-on component (DOC) is identified (for example, reading data from a database table). Unlike the other ABAP Unit examples, there are no local or global interfaces involved.</li>
<li>The global class that includes a method to be tested is not declared as a final class, allowing for the creation of subclasses. For simplicity, this global class implements a method specifically for the test. You can imagine that a data retrieval method is contained in another global class, which the class under test uses.</li>
<li>The test class may be implemented as follows:</li>
<li>A test double class is created that inherits from the global class and redefines the method identified as the DOC, enabling the provisioning of test data for the test classes.</li>
<li>The test method does not instantiate the class under test. Instead, it creates an object of the test double class. The method to be tested is then called through the test double&#x27;s reference variable.</li>
<li>The effect is as follows: When the method to be tested is called &quot;regularly&quot; (for example, by executing the class using <em>F9</em>), it runs as usual with production data. However, when the unit test is executed (for example, by choosing <em>Ctrl/Cmd + Shift + F10</em>), the redefined method in the test class is called, injecting and using the test double.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p>Unlike other examples, this example class has a different setup:</p>
<ul>
<li>It focuses on ABAP Unit tests. You can indeed execute the simple example class by choosing <em>F9</em>. To run the unit test, use <em>Ctrl/Cmd + Shift + F10</em>.</li>
<li>The example class includes code from the global class and the CCAU include (<em>Test Classes</em> tab in ADT).</li>
<li>The example uses a demo database table (and a class to populate it) from the ABAP Cheat Sheet GitHub repository.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.

    TYPES: carr_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY,
           occ_rate TYPE p LENGTH 5 DECIMALS 2.

    CLASS-METHODS class_constructor.
    METHODS get_occ_rate IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                         RETURNING VALUE(occupancy_rate) TYPE occ_rate.

  PROTECTED SECTION.
    METHODS select_flight_data IMPORTING carrier            TYPE zdemo_abap_fli-carrid
                               RETURNING VALUE(flight_data) TYPE carr_tab.

  PRIVATE SECTION.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Filling an internal table with carrier IDs used to calculate
    &quot;the occupancy rate.
    DATA(carrier_tab) = VALUE carr_tab( ( carrid = &#x27;LH&#x27; )
                                        ( carrid = &#x27;AA&#x27; )
                                        ( carrid = &#x27;DL&#x27; ) ).

    LOOP AT carrier_tab INTO DATA(carr).
      DATA(oc_rate) = get_occ_rate( carr-carrid ).

      out-&gt;write( |The occupancy rate for airline { carr-carrid } is { oc_rate }%.|  ).
      out-&gt;write( |\n| ).
    ENDLOOP.

  ENDMETHOD.

  METHOD class_constructor.
    &quot;Filling demo database tables.
    zcl_demo_abap_aux=&gt;fill_dbtabs( ).
  ENDMETHOD.

  METHOD get_occ_rate.
    DATA total_seatsmax TYPE i.
    DATA total_seatsocc TYPE i.

    &quot;During the unit test, the redefined method in the test class is called.
    DATA(flight_data) = select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data INTO DATA(wa).
      total_seatsmax = total_seatsmax + wa-seatsmax.
      total_seatsocc = total_seatsocc + wa-seatsocc.
    ENDLOOP.

    occupancy_rate = total_seatsocc / total_seatsmax * 100.
  ENDMETHOD.

  METHOD select_flight_data.
    SELECT seatsmax, seatsocc
      FROM zdemo_abap_fli
      WHERE carrid = @carrier
      INTO CORRESPONDING FIELDS OF TABLE @flight_data.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCAU include (Test Classes tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Local test double class
*&amp;---------------------------------------------------------------------*

&quot;The example uses manually created test doubles. You may also want to
&quot;check out creating test doubles using ABAP frameworks. Find more
&quot;information in the ABAP Unit Tests cheat sheet.

CLASS ltd_test_data DEFINITION FOR TESTING
INHERITING FROM zcl_demo_abap.
  PROTECTED SECTION.
    METHODS select_flight_data REDEFINITION.
ENDCLASS.

CLASS ltd_test_data IMPLEMENTATION.
  METHOD select_flight_data.

    flight_data = SWITCH #( carrier
      WHEN &#x27;IJ&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 300 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 200 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 300 ) )
      WHEN &#x27;KL&#x27; THEN VALUE #( ( carrid = carrier  seatsmax = 350 seatsocc = 300 )
                              ( carrid = carrier  seatsmax = 350 seatsocc = 250 )
                              ( carrid = carrier  seatsmax = 300 seatsocc = 250 ) ) ).

  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Test class demonstrating test double injection using inheritance
*&amp; and method redefinition
*&amp;---------------------------------------------------------------------*

CLASS ltc_test DEFINITION
  FOR TESTING RISK LEVEL HARMLESS
  DURATION SHORT.
  PRIVATE SECTION.
    METHODS test_get_occ_rate FOR TESTING.
ENDCLASS.

CLASS ltc_test IMPLEMENTATION.
  METHOD test_get_occ_rate.
    &quot;Creating an object of the test double class that inherits
    &quot;from the class under test
    DATA(ref_cut) = NEW ltd_test_data(  ).

    DATA(act_occ_rate) = ref_cut-&gt;get_occ_rate( &#x27;IJ&#x27; ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;70.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;IJ&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).

    act_occ_rate = ref_cut-&gt;get_occ_rate( &#x27;KL&#x27; ).

    cl_abap_unit_assert=&gt;assert_equals(
        act = act_occ_rate
        exp = &#x27;80.00&#x27;
        msg = |The expected occupancy rate for carrier &#x27;KL&#x27; is wrong.|
        quit = if_abap_unit_constant=&gt;quit-no ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Abstract Factory</h2>
<ul>
<li>The pattern may be used when you need to create a set of related objects (a family of &quot;products&quot;) that work together or are processed together for specific purposes.</li>
<li>Such families of related objects may be required in different variants. However, the created objects must be compatible with each variant.</li>
<li>Here are some examples to illustrate this:</li>
<li>Consider a car manufacturer. Multiple components are needed to assemble a car, such as the chassis, engine, and equipment (certainly, there are more components). These components form a family of related objects to a create car. All cars from the manufacturer follow the same setup: each requires a chassis, engine, and equipment. However, the manufacturer offers various car models like convertibles, sedans, SUVs, and pickup trucks. When producing these different variants, specific components may vary. The assembly must only use compatible objects. For example, when producing a convertible, a chassis with a sedan roof should not be used.</li>
<li>Consider a restaurant offers various three-course menus (this is the example used by the demo classes). Menu items include starters, main dishes, and desserts, forming a family of related objects. Different variants exist to create specific menus. For example, the restaurant offers a vegan menu. When creating the vegan menu, it should be ensured the menu does not include a beef steak as a main dish or dairy products in desserts.</li>
<li>In terms of code, you may need a setup to create related objects in an organized and consistent way. The abstract factory design pattern enables this by using a high level of abstraction in your class setup, i.e. it enables the creation of related objects that belong to the same family through abstractions like abstract classes, without bothering about their specific implementations and allowing for the creation of objects with appropriate types determined at runtime. A factory, such as an abstract factory class, sets up the object creation process by specifying methods that provide objects. Concrete factories then inherit from the abstract factory class and implement the methods to create specific kinds of objects. More abstraction is involved, as outlined in the example description below.</li>
<li>Some of the benefits of the pattern include: centralizing multiple object creations in one location, ensuring consistency and compatibility, simplifying object creation for users by hiding complexity, adding or modifying different variants without affecting existing code, providing flexibility and adaptability (however, adding new products might be cumbersome as it requires changes in many parts of the code).</li>
<li>The abstract factory pattern differs from the factory method design pattern in several ways. Both facilitate object creation through abstraction. The factory method uses a single interface as an abstraction layer and single factory methods, while the abstract factory pattern uses a higher degree of abstraction and multiple factories. The factory method pattern primarily creates single objects, whereas the abstract factory pattern involves creating multiple related objects.</li>
</ul>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example Notes</strong></p>
<p>The example uses the following class setup in the CCIMP include (Local Types tab in ADT) to illustrate the abstract factory pattern:</p>
<ul>
<li>Setting up abstract classes for products to establish a template for concrete products</li>
<li>Abstract classes for the products (abstract products)</li>
<li>In this example, the <code>starters</code>, <code>main_dishes</code>, and <code>desserts</code> classes serve as abstract classes for products.</li>
<li>These classes provide a common interface for concrete products, ensuring all variants are created consistently.</li>
<li>Concrete classes for the products (concrete products)</li>
<li>In the example, concrete classes for the products, inheriting from the <code>starters</code>, <code>main_dishes</code>, and <code>desserts</code> abstract classes, are named using the format <code>starters_<em></code>, <code>main_dishes_</em></code>, and <code>desserts_*</code>.</li>
<li>For each variant, such as the seafood menu, specific concrete products are provided. Here, the method implementations of the concrete classes involve adding various dishes to a string table, representing available menu options for customers. Numbers in parentheses (1-3) denote the menu course. Generally, the implementations must ensure that the products fit their specific variant.</li>
</ul>
<ul>
<li>Setting up an abstract factory and concrete factories</li>
<li>Abstract factory class</li>
<li>The abstract factory, represented by the <code>menu_factory</code> class, defines a common interface for product families to create related objects.</li>
<li>It includes factory methods to provide these related objects.</li>
<li>The returned related objects are typed with references to the abstract products (<code>starters</code>, <code>main_dishes</code>, and <code>desserts</code>).</li>
<li>Concrete factory classes</li>
<li>The variants enter the picture with concrete factories. Here, the concrete factories are represented by the <code>italian_menu_creator</code>, <code>seafood_menu_creator</code>, and <code>vegan_menu_creator</code> classes.</li>
<li>Each variant has a concrete factory, and these factories inherit from the abstract factory class <code>menu_factory</code>.</li>
<li>The concrete factories include factory methods to create and return concrete products at runtime. Note that the returning parameter is typed with reference to the abstract product.</li>
<li>This implementation ensures compatibility, meaning the seafood factory should only create and provide objects for starters, main dishes, and desserts related to seafood.</li>
</ul>
<ul>
<li>Setting up a client</li>
<li>The <code>menu_provider</code> class represents the client.</li>
<li>The client uses the abstract factories for object creation, allowing it to work with any variant without dealing with concrete factories.</li>
<li>In this example, the implementation returns the entire menu (<code>create_menu</code> method) based on the selected menu variant. The &quot;selection&quot; of the menu variant is realized by the instance constructor of the class. The desired menu variant is passed to the instance constructor as an object reference, typed with reference to the abstract factory.</li>
<li>At runtime, the abstract factories connect with concrete factories so that the <code>create_menu</code> method implementation can work with them. Regardless of which variant is chosen (i.e., which object reference is passed), the client can handle it, use compatible objects, and return the desired menu.</li>
<li>The example includes the helper class <code>customer_order</code>, which has a factory method to create the appropriate object reference required by the client, based on the desired menu.</li>
</ul>
<p>Global class:</p>
<ul>
<li>The global class implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>It serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the <code>CCIMP</code> include are relevant for the conceptual considerations.</li>
<li>Using the <code>menu_provider</code> client class and specifying the variant using the <code>customer_order</code> class, a menu is created. During the method calls, all related objects (products) are created, and string tables are filled with various dishes to illustrate the pattern. As a result, a single string table is returned, containing meals for all three courses per variant offered by the restaurant. The example includes method calls for all three example variants and outputs the resulting string tables to the ADT console.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.



CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.
  DATA(italian_menu) = NEW menu_provider( customer_order=&gt;place_order( menu_factory=&gt;italian ) )-&gt;create_menu(  ).
  out-&gt;write( data = italian_menu name = `italian_menu` ).
  out-&gt;write( |\n| ).

  DATA(seafood_menu) = NEW menu_provider( customer_order=&gt;place_order( menu_factory=&gt;seafood ) )-&gt;create_menu(  ).
  out-&gt;write( data = seafood_menu name = `seafood_menu` ).
  out-&gt;write( |\n| ).

  DATA(vegan_menu) = NEW menu_provider( customer_order=&gt;place_order( menu_factory=&gt;vegan ) )-&gt;create_menu(  ).
  out-&gt;write( data = vegan_menu name = `vegan_menu` ).
  out-&gt;write( |\n| ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Abstract products
*&amp;---------------------------------------------------------------------*

CLASS starters DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS get_starters ABSTRACT RETURNING VALUE(starters) TYPE string_table.
ENDCLASS.

CLASS main_dishes DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS get_main_dishes ABSTRACT RETURNING VALUE(main_dishes) TYPE string_table.
ENDCLASS.

CLASS desserts DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS get_desserts ABSTRACT RETURNING VALUE(desserts) TYPE string_table.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete products
*&amp;---------------------------------------------------------------------*

CLASS starters_italian DEFINITION INHERITING FROM starters.
  PUBLIC SECTION.
    METHODS get_starters REDEFINITION.
ENDCLASS.

CLASS starters_italian IMPLEMENTATION.
  METHOD get_starters.
    starters = VALUE #( ( `Bruschetta (1)` ) ( `Caprese salad (1)` ) ( `Antipasto platter (1)` ) ).
  ENDMETHOD.
ENDCLASS.

CLASS starters_vegan DEFINITION INHERITING FROM starters.
  PUBLIC SECTION.
    METHODS get_starters REDEFINITION.
ENDCLASS.

CLASS starters_vegan IMPLEMENTATION.
  METHOD get_starters.
    starters = VALUE #( ( `Stuffed mushrooms (1)` ) ( `Zucchini fritters (1)` ) ( `Tomato soup (1)` ) ).
  ENDMETHOD.
ENDCLASS.

CLASS starters_seafood DEFINITION INHERITING FROM starters.
  PUBLIC SECTION.
    METHODS get_starters REDEFINITION.
ENDCLASS.

CLASS starters_seafood IMPLEMENTATION.
  METHOD get_starters.
    starters = VALUE #( ( `Shrimp cocktail (1)` ) ( `Crab cakes (1)` ) ( `Calamari (1)` ) ).
  ENDMETHOD.
ENDCLASS.

CLASS main_dishes_italian DEFINITION INHERITING FROM main_dishes.
  PUBLIC SECTION.
    METHODS get_main_dishes REDEFINITION.
ENDCLASS.

CLASS main_dishes_italian IMPLEMENTATION.
  METHOD get_main_dishes.
    main_dishes = VALUE #( ( `Spaghetti Carbonara (2)` ) ( `Lasagna alla Bolognese (2)` ) ( `Saltimbocca alla Romana (2)` ) ).
  ENDMETHOD.
ENDCLASS.

CLASS main_dishes_vegan DEFINITION INHERITING FROM main_dishes.
  PUBLIC SECTION.
    METHODS get_main_dishes REDEFINITION.
ENDCLASS.

CLASS main_dishes_vegan IMPLEMENTATION.
  METHOD get_main_dishes.
    main_dishes = VALUE #( ( `Chickpea curry (2)` ) ( `Cauliflower steak (2)` ) ( `Vegan burger (2)` ) ).
  ENDMETHOD.
ENDCLASS.

CLASS main_dishes_seafood DEFINITION INHERITING FROM main_dishes.
  PUBLIC SECTION.
    METHODS get_main_dishes REDEFINITION.
ENDCLASS.

CLASS main_dishes_seafood IMPLEMENTATION.
  METHOD get_main_dishes.
    main_dishes = VALUE #( ( `Baked salmon (2)` ) ( `Grilled lobster (2)` ) ( `Fish and chips (2)` ) ).
  ENDMETHOD.
ENDCLASS.

CLASS desserts_italian DEFINITION INHERITING FROM desserts.
  PUBLIC SECTION.
    METHODS get_desserts REDEFINITION.
ENDCLASS.

CLASS desserts_italian IMPLEMENTATION.
  METHOD get_desserts.
    desserts = VALUE #( ( `Tiramisu (3)` ) ( `Panna cotta (3)` ) ( `Tartufo (3)` ) ).
  ENDMETHOD.
ENDCLASS.

CLASS desserts_vegan DEFINITION INHERITING FROM desserts.
  PUBLIC SECTION.
    METHODS get_desserts REDEFINITION.
ENDCLASS.

CLASS desserts_vegan IMPLEMENTATION.
  METHOD get_desserts.
    desserts = VALUE #( ( `Fruit sorbet (3)` ) ( `Almond milk vanilla pudding (3)` ) ( `Apple crumble (3)` ) ).
  ENDMETHOD.
ENDCLASS.

CLASS desserts_seafood DEFINITION INHERITING FROM desserts.
  PUBLIC SECTION.
    METHODS get_desserts REDEFINITION.
ENDCLASS.

CLASS desserts_seafood IMPLEMENTATION.
  METHOD get_desserts.
    desserts = VALUE #( ( `Lemon sorbet (3)` ) ( `Cheesecake (3)` ) ( `Chocolate mousse (3)` ) ).
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Abstract factory
*&amp;---------------------------------------------------------------------*

CLASS menu_factory DEFINITION ABSTRACT.
  PUBLIC SECTION.
    TYPES: BEGIN OF ENUM menu_variant,
             italian,
             seafood,
             vegan,
           END OF ENUM menu_variant.

    METHODS: create_starters ABSTRACT RETURNING VALUE(starters_ref) TYPE REF TO starters,
      create_main_dishes ABSTRACT RETURNING VALUE(main_dishes_ref) TYPE REF TO main_dishes,
      create_desserts ABSTRACT RETURNING VALUE(desserts_ref) TYPE REF TO desserts.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete factories
*&amp;---------------------------------------------------------------------*

CLASS italian_menu_creator DEFINITION INHERITING FROM menu_factory.
  PUBLIC SECTION.
    METHODS: create_starters REDEFINITION,
      create_main_dishes REDEFINITION,
      create_desserts REDEFINITION.

ENDCLASS.

CLASS italian_menu_creator IMPLEMENTATION.

  METHOD create_starters.
    starters_ref = NEW starters_italian( ).
  ENDMETHOD.

  METHOD create_main_dishes.
    main_dishes_ref = NEW main_dishes_italian( ).
  ENDMETHOD.

  METHOD create_desserts.
    desserts_ref = NEW desserts_italian( ).
  ENDMETHOD.
ENDCLASS.

CLASS seafood_menu_creator DEFINITION INHERITING FROM menu_factory.
  PUBLIC SECTION.
    METHODS: create_starters REDEFINITION,
      create_main_dishes REDEFINITION,
      create_desserts REDEFINITION.

ENDCLASS.

CLASS seafood_menu_creator IMPLEMENTATION.

  METHOD create_starters.
    starters_ref = NEW starters_seafood( ).
  ENDMETHOD.

  METHOD create_main_dishes.
    main_dishes_ref = NEW main_dishes_seafood( ).
  ENDMETHOD.

  METHOD create_desserts.
    desserts_ref = NEW desserts_seafood( ).
  ENDMETHOD.

ENDCLASS.

CLASS vegan_menu_creator DEFINITION INHERITING FROM menu_factory.
  PUBLIC SECTION.
    METHODS: create_starters REDEFINITION,
      create_main_dishes REDEFINITION,
      create_desserts REDEFINITION.

ENDCLASS.

CLASS vegan_menu_creator IMPLEMENTATION.

  METHOD create_starters.
    starters_ref = NEW starters_vegan( ).
  ENDMETHOD.

  METHOD create_main_dishes.
    main_dishes_ref = NEW main_dishes_vegan( ).
  ENDMETHOD.

  METHOD create_desserts.
    desserts_ref = NEW desserts_vegan( ).
  ENDMETHOD.

ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Client
*&amp;---------------------------------------------------------------------*

CLASS menu_provider DEFINITION.
  PUBLIC SECTION.
    METHODS: constructor IMPORTING factory TYPE REF TO menu_factory,
             create_menu RETURNING VALUE(menu) TYPE string_table.
  PRIVATE SECTION.
    DATA factory TYPE REF TO menu_factory.
    DATA starters_factory TYPE REF TO starters.
    DATA main_dishes_factory TYPE REF TO main_dishes.
    DATA desserts_factory TYPE REF TO desserts.
ENDCLASS.

CLASS menu_provider IMPLEMENTATION.
  METHOD create_menu.
    &quot;The more detailed out code lines are to emphasize that this class deals
    &quot;with references to abstract types. Appending the lines may also
    &quot;be achieved with fewer lines of code, as commented out below.
    starters_factory = factory-&gt;create_starters( ).
    main_dishes_factory = factory-&gt;create_main_dishes( ).
    desserts_factory = factory-&gt;create_desserts( ).

    DATA(starters_for_menu) = starters_factory-&gt;get_starters( ).
    DATA(main_dishes_for_menu) = main_dishes_factory-&gt;get_main_dishes( ).
    DATA(desserts_for_menu) = desserts_factory-&gt;get_desserts( ).

    APPEND LINES OF starters_for_menu TO menu.
    APPEND LINES OF main_dishes_for_menu TO menu.
    APPEND LINES OF desserts_for_menu TO menu.

    &quot;APPEND LINES OF factory-&gt;create_starters( )-&gt;get_starters( ) TO menu.
    &quot;APPEND LINES OF factory-&gt;create_main_dishes( )-&gt;get_main_dishes( ) TO menu.
    &quot;APPEND LINES OF factory-&gt;create_desserts( )-&gt;get_desserts( ) TO menu.
  ENDMETHOD.

  METHOD constructor.
    me-&gt;factory = factory.
  ENDMETHOD.
ENDCLASS.

&quot;Helper class
CLASS customer_order DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    CLASS-METHODS place_order IMPORTING menu_variant   TYPE menu_factory=&gt;menu_variant
                              RETURNING VALUE(factory) TYPE REF TO menu_factory.
ENDCLASS.

CLASS customer_order IMPLEMENTATION.
  METHOD place_order.
    CASE menu_variant.
      WHEN menu_factory=&gt;italian.
        factory = NEW italian_menu_creator( ).
      WHEN menu_factory=&gt;seafood.
        factory = NEW seafood_menu_creator( ).
      WHEN menu_factory=&gt;vegan.
        factory = NEW vegan_menu_creator( ).
    ENDCASE.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Adapter</h2>
<ul>
<li>Used when APIs are incompatible, and you want to integrate those APIs into an existing one to consolidate all functionality.</li>
<li>This can be achieved by using an adapter class to convert and transform functionality from a non-compatible API into the existing API.</li>
</ul>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>This example demonstrates the adapter design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements <code>if_oo_adt_classrun</code> and calls methods from local classes.</li>
<li>Acts as a consumer of APIs (local classes) defined in the CCIMP include.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>The example is similar to the factory method example.</li>
<li>Local interface <code>lif_hello</code>: Defines an enumeration type and a method that returns a string.</li>
<li>Local classes <code>lcl_**</code> implement <code>lif_hello</code>.</li>
<li>Local class <code>lcl_hello_factory</code>: Contains the factory method <code>create_hello</code>. The class specifies <code>CREATE PRIVATE</code> to prevent external instantiation. The <code>create_hello</code> returns a reference of type <code>REF TO lif_hello</code>.</li>
<li>Assuming functionality is extended. An existing API is integrated and reused.</li>
<li>This is represented by the <code>lcl_de_xstring</code> class. It implements a different interface. The method returns a data object of type <code>xstring</code>, which is not compatible with the <code>say_hello</code> method of the <code>lif_hello</code> interface that returns a <code>string</code>.</li>
<li>An adapter class is introduced that implements the <code>lif_hello</code> interface and handles conversion (in the example case, <code>xstring</code> is transformed to <code>string</code>) to allow the use of the non-compatible API.</li>
<li>Users can then call methods of the adapter class.</li>
<li>The class execution includes the following:</li>
<li>Multiple objects are created using the factory method with different input parameters.</li>
<li>Based on the parameter, a specific object is created. The <code>say_hello</code> method returns a string as implemented in the resepctive class.</li>
<li>When <code>lif_hello=&gt;de</code> is supplied, an object is created using the adapter class.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Saying hello in English
    DATA(oref_en) = lcl_hello_factory=&gt;create_hello( lif_hello=&gt;en ).
    DATA(hello_en) = oref_en-&gt;say_hello( ).
    out-&gt;write( hello_en ).

    &quot;Saying hello in French
    DATA(oref_fr) = lcl_hello_factory=&gt;create_hello( lif_hello=&gt;fr ).
    DATA(hello_fr) = oref_fr-&gt;say_hello( ).
    out-&gt;write( hello_fr ).

    &quot;Saying hello in Italian
    DATA(oref_it) = lcl_hello_factory=&gt;create_hello( lif_hello=&gt;it ).
    DATA(hello_it) = oref_it-&gt;say_hello( ).
    out-&gt;write( hello_it ).

    &quot;Saying hello in Spanish
    DATA(oref_es) = lcl_hello_factory=&gt;create_hello( lif_hello=&gt;es ).
    DATA(hello_es) = oref_es-&gt;say_hello( ).
    out-&gt;write( hello_es ).

    &quot;Saying hello in German
    &quot;See the local class implementation. This method call demonstrates the adapter since
    &quot;the required data is originally available in a non-conform way (&#x27;Hallo&#x27; is
    &quot;available as xstring, coming from a different API that does not implement the same
    &quot;interface as the other classes). The adapter class (called when creating the instance
    &quot;in the factory method) integrates the non-conform API and transforms the content.
    DATA(oref_de) = lcl_hello_factory=&gt;create_hello( lif_hello=&gt;de ).
    DATA(hello_de) = oref_de-&gt;say_hello( ).
    out-&gt;write( hello_de ).

    &quot;Default hello
    DATA(oref_default) = lcl_hello_factory=&gt;create_hello( lif_hello=&gt;init ).
    DATA(hello_default) = oref_default-&gt;say_hello( ).
    out-&gt;write( hello_default ).

  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>INTERFACE lif_hello.
  TYPES: basetype TYPE i,
         BEGIN OF ENUM enum_langu BASE TYPE basetype,
           init VALUE IS INITIAL,
           en   VALUE 1,
           fr   VALUE 2,
           it   VALUE 3,
           es   VALUE 4,
           de   VALUE 5,
         END OF ENUM enum_langu.

  METHODS say_hello RETURNING VALUE(hi) TYPE string.
ENDINTERFACE.

CLASS lcl_en DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_hello.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_en IMPLEMENTATION.
  METHOD lif_hello~say_hello.
    hi = `Hi`.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_fr DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_hello.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_fr IMPLEMENTATION.
  METHOD lif_hello~say_hello.
    hi = `Salut`.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_it DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_hello.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_it IMPLEMENTATION.
  METHOD lif_hello~say_hello.
    hi = `Ciao`.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_es DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_hello.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_es IMPLEMENTATION.
  METHOD lif_hello~say_hello.
    hi = `Hola`.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
&quot;Class that does not implement the lif_hello interface
&quot;The assumption is that functionality of the API is reused and integrated
&quot;into the exsisting API. The non-compatible type is converted using an
&quot;adapter class.

INTERFACE lif_hello_as_xstring.
  METHODS xstring_hello RETURNING VALUE(hi) TYPE xstring.
ENDINTERFACE.

CLASS lcl_de_xstring DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_hello_as_xstring.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_de_xstring IMPLEMENTATION.
  METHOD lif_hello_as_xstring~xstring_hello.
    hi = CONV xstring( `48616C6C6F` ).
  ENDMETHOD.
ENDCLASS.

**********************************************************************
&quot;Adapter class

CLASS lcl_de_adapter DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_hello.
ENDCLASS.

CLASS lcl_de_adapter IMPLEMENTATION.
  METHOD lif_hello~say_hello.
    DATA(oref) = NEW lcl_de_xstring( ).
    DATA(hello_as_xstring) = oref-&gt;lif_hello_as_xstring~xstring_hello( ).
    hi = cl_abap_conv_codepage=&gt;create_in( )-&gt;convert( hello_as_xstring ).
  ENDMETHOD.
ENDCLASS.

**********************************************************************
&quot;Class containing a factory method

CLASS lcl_hello_factory DEFINITION FINAL CREATE PRIVATE.

  PUBLIC SECTION.
    CLASS-METHODS create_hello IMPORTING language     TYPE lif_hello=&gt;enum_langu
                               RETURNING VALUE(hello) TYPE REF TO lif_hello.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_hello_factory IMPLEMENTATION.
  METHOD create_hello.
    hello = SWITCH #( language
                      WHEN lif_hello=&gt;en THEN NEW lcl_en( )
                      WHEN lif_hello=&gt;fr THEN NEW lcl_fr( )
                      WHEN lif_hello=&gt;it THEN NEW lcl_it( )
                      WHEN lif_hello=&gt;es THEN NEW lcl_es( )
                      &quot;Calling the method in the adapter class
                      WHEN lif_hello=&gt;de THEN NEW lcl_de_adapter( )
                      &quot;E.g. raising an exception or returning a default object
                      ELSE NEW lcl_en( ) ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Bridge</h2>
<ul>
<li>The idea behind the bridge design pattern is to categorize the class setup into an abstraction layer and an implementation layer, keeping them separate.</li>
<li>The abstraction defines high-level functionality, while it delegates actual operations to the implementation layer. The <em>bridging</em> element enters the picture like this: The abstraction may hold a reference to an instance of the implementation side, enabling interaction through that instance.</li>
<li>The following example uses a car production scenario for demonstration. The abstraction layer is represented by a car (a base class, and potentially refinements - classes inheriting from the base class - for specific types, such as an SUV or a sports car) that outlines high-level production steps. The implementation layer is represented by car factories that execute these steps (a base class for factories, and classes inheriting from the base class for various factories). Find more information about the example in the expandable section.</li>
<li>The bridge design pattern may be beneficial when you can apply a decoupling of classes and determine different class hierarchies for the abstraction and implementation layers, still requiring them to work together flexibly, unlike relying on, for example, inheritance within a single, large class hierarchy:</li>
<li>You might avoid an overcrowding of classes. For example, without the bridge pattern, you would need a separate class for each combination, such as a class for car type A with factory Z, car type A with factory Y, car type B with factory Z, car type B with factory Y, and so on. The bridge design pattern, however, may allow flexible combinations of the two layers at runtime.</li>
<li>Without decoupling, maintenance and extensions may become inflexible. By using the bridge design pattern, you can easily add a new car type (that is, a new refined abstraction) without needing to modify the car factory classes on the implementation side, as the setup is made to have the layers independent from each other. Vice versa, adaptations on the implementation side may occur independently, without disrupting the code on the abstraction side.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example uses a car production context for demo purposes.</li>
<li>The abstraction layer is represented by a car (class <code>lcl_car</code> and its refinements). The implementation layer is represented by car factories that perform various production steps (class <code>lcl_car_factory</code> and its concrete classes for different factories).</li>
<li>The bridging element enters the picture with <code>lcl_car</code> holding an instance referencing a concrete factory, and delegating implementation-specific steps to the car factory.</li>
<li>The example code demonstrates the bridge design pattern by including the following declarations and implementations:</li>
<li>CCIMP include (<em>Local Types</em> tab in ADT):</li>
<li><code>lcl_car</code></li>
<li>This class represents the base class of the abstraction layer.</li>
<li>It is an abstract class that defines high-level functionality by specifying methods for various car production steps.</li>
<li>It specifies the instance constructor that subclasses must call, expecting an object of <code>lcl_car_factory</code> from the implementation layer to be passed.</li>
<li>In this example, the non-abstract method <code>produce</code> orchestrates the production steps. For display purposes, a string table with comments on the production steps is filled throughout the method calls, which is returned by the returning parameter.</li>
<li>The protected visibility section specifies additional components, such as the <code>factory</code> instance attribute, which serves as the bridging element in the setup by holding an instance of a concrete car factory.</li>
<li>The non-abstract methods <code>paint</code>, <code>control_quality</code>, and <code>test_drive</code> provide default implementations. These methods correspond to those declared by the <code>lcl_car_factory</code>, with method calls delegated to concrete implementations via the <code>factory</code> reference variable.</li>
<li>The example is designed to include refined abstractions, allowing subclasses of <code>lcl_car</code> to either use the default implementations without modifications or refine the production steps with specific implementations. In some cases, the simplified example just involves adding strings to a string table to represent different, refined implementations. However, the default implementation is always used by calling the method with <code>super-&gt;</code>.</li>
<li>The <code>car_type</code> method is abstract, requiring subclasses to implement it. In this example, its purpose is to determine the car type, which is also an attribute of <code>lcl_car</code> (<code>cartype</code>), not of the car factory classes.</li>
<li><code>lcl_compact_car</code>, <code>lcl_suv</code>, <code>lcl_sports_car</code></li>
<li>These classes inherit from <code>lcl_car</code> and represent refined abstractions, that is, different car types that can be produced in every factory available.</li>
<li>Each class can, but does not have to, override the default implementation or add specific implementations.</li>
<li>The example demonstrates specific implementations in some cases by adding strings to a string table, which represents different implementations. However, the default implementation is always used by calling the method with <code>super-&gt;</code>. For example, the assumption is that there are additional prerequisites for test-driving a sports car, such as needing access to a special test track.</li>
<li>By allowing these classes to extend the default implementation, these refined abstractions illustrate how adaptations can be made flexibly without dependencies on other abstractions or the implementation layer.</li>
<li><code>lcl_car_factory</code></li>
<li>Represents the base class of the implementation layer.</li>
<li>It is an abstract class that defines methods that inheriting classes must implement.</li>
<li>In the example setup, the method names correspond to those defined by <code>lcl_car</code>. The methods in <code>lcl_car</code> &quot;know&quot; about these methods but call them through the stored instance in <code>factory</code>. They do not know the concrete implementation details; they simply delegate to those methods.</li>
<li><code>lcl_factory_a</code>, <code>lcl_factory_b</code>, <code>lcl_factory_c</code></li>
<li>These classes inherit from <code>lcl_car_factory</code> and represent the concrete implementations that perform operations in the implementation layer.</li>
<li>Each class must redefine the abstract methods defined in the superclass <code>lcl_car_factory</code>.</li>
<li>The simplified example adds a string to a string table, representing the unique operations performed by each car factory class. While the steps and functionalities, such as painting, quality checks, and test driving, remain consistent, the implementation may vary. An assumption might be that, for example, the painting is done using different machines in the car factories, or specific test tracks are used for the test drive.</li>
<li>Because all factory classes use the same abstract interface, individual cars (<code>lcl_car</code> objects) can be used interchangeably with any factory.</li>
<li><code>lcl_log</code></li>
<li>Not related to conceptual considerations.</li>
<li>It just serves display purposes by providing a string table to hold the production comments added throughout the method calls.</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as the client in the example. It is responsible for associating objects of the abstraction layer with objects of the implemenation layer.</li>
<li>By calling the non-abstract method <code>produce</code>, the production process is orchestrated accordingly.</li>
<li>The string table that is output visualizes the production steps.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    DATA compact_car1 TYPE REF TO lcl_compact_car.
    DATA factory_a TYPE REF TO lcl_factory_a.
    factory_a = NEW #( ).
    compact_car1 = NEW lcl_compact_car( factory_a ).
    DATA(log1) = compact_car1-&gt;produce( ).

    out-&gt;write( log1 ).
    out-&gt;write( |\n\n| ).

    DATA(compact_car2) = NEW lcl_compact_car( NEW lcl_factory_b( ) ).
    DATA(log2) = compact_car2-&gt;produce( ).
    out-&gt;write( log2 ).
    out-&gt;write( |\n\n| ).

    DATA(suv1)    = NEW lcl_suv( NEW lcl_factory_c( ) ).
    DATA(log3) = suv1-&gt;produce( ).
    out-&gt;write( log3 ).
    out-&gt;write( |\n\n| ).

    DATA(suv2)    = NEW lcl_suv( NEW lcl_factory_a( ) ).
    DATA(log4) = suv2-&gt;produce( ).
    out-&gt;write( log4 ).
    out-&gt;write( |\n\n| ).

    DATA(sports_car1) = NEW lcl_sports_car( NEW lcl_factory_a( ) ).
    DATA(log5) = sports_car1-&gt;produce( ).
    out-&gt;write( log5 ).
    out-&gt;write( |\n\n| ).

    DATA(sports_car2) = NEW lcl_sports_car( NEW lcl_factory_b( ) ).
    DATA(log6) = sports_car2-&gt;produce( ).
    out-&gt;write( log6 ).
    out-&gt;write( |\n\n| ).

    DATA(sports_car3) = NEW lcl_sports_car( NEW lcl_factory_c( ) ).
    DATA(log7) = sports_car3-&gt;produce( ).
    out-&gt;write( log7 ).

  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>&quot;Class providing a string table representing a log table for
&quot;display purposes in the example
CLASS lcl_log DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA log TYPE string_table.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Base class of the implementation layer
*&amp;---------------------------------------------------------------------*

CLASS lcl_car_factory DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS build ABSTRACT IMPORTING cartype TYPE string.
    METHODS paint ABSTRACT IMPORTING cartype TYPE string.
    METHODS control_quality ABSTRACT IMPORTING cartype TYPE string.
    METHODS test_drive ABSTRACT IMPORTING cartype TYPE string.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_car_factory IMPLEMENTATION.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete implementations
*&amp;---------------------------------------------------------------------*

CLASS lcl_factory_a DEFINITION INHERITING FROM lcl_car_factory.
  PUBLIC SECTION.
    METHODS build REDEFINITION.
    METHODS paint REDEFINITION.
    METHODS control_quality REDEFINITION.
    METHODS test_drive REDEFINITION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_factory_a IMPLEMENTATION.
  METHOD build.
    APPEND |Factory A: { cartype } built| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD paint.
    APPEND |Factory A: { cartype } painted| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD control_quality.
    APPEND |Factory A: { cartype } checked| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD test_drive.
    APPEND |Factory A: { cartype } test driven| TO lcl_log=&gt;log.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_factory_b DEFINITION INHERITING FROM lcl_car_factory.
  PUBLIC SECTION.
    METHODS build REDEFINITION.
    METHODS paint REDEFINITION.
    METHODS control_quality REDEFINITION.
    METHODS test_drive REDEFINITION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_factory_b IMPLEMENTATION.
  METHOD build.
    APPEND |Factory B: { cartype } built| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD paint.
    APPEND |Factory B: { cartype } painted| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD control_quality.
    APPEND |Factory B: { cartype } checked| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD test_drive.
    APPEND |Factory B: { cartype } test driven| TO lcl_log=&gt;log.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_factory_c DEFINITION INHERITING FROM lcl_car_factory.
  PUBLIC SECTION.
    METHODS build REDEFINITION.
    METHODS paint REDEFINITION.
    METHODS control_quality REDEFINITION.
    METHODS test_drive REDEFINITION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_factory_c IMPLEMENTATION.
  METHOD build.
    APPEND |Factory C: { cartype } built| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD paint.
    APPEND |Factory C: { cartype } painted| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD control_quality.
    APPEND |Factory C: { cartype } checked| TO lcl_log=&gt;log.
  ENDMETHOD.

  METHOD test_drive.
    APPEND |Factory C: { cartype } test driven| TO lcl_log=&gt;log.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Base class of the abstraction layer
*&amp;---------------------------------------------------------------------*

CLASS lcl_car DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS constructor IMPORTING oref_factory TYPE REF TO lcl_car_factory.
    METHODS produce RETURNING VALUE(log) TYPE string_table.
  PROTECTED SECTION.
    DATA factory TYPE REF TO lcl_car_factory.
    DATA cartype TYPE string.
    METHODS car_type ABSTRACT RETURNING VALUE(cartype) TYPE string.
    METHODS paint.
    METHODS control_quality.
    METHODS test_drive.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_car IMPLEMENTATION.
  METHOD constructor.
    factory = oref_factory.
  ENDMETHOD.

  METHOD produce.
    cartype = car_type( ).

    APPEND |{ repeat( val = `-` occ = 80 ) }| TO lcl_log=&gt;log.
    DATA(relative_name) = CAST cl_abap_classdescr( cl_abap_typedescr=&gt;describe_by_object_ref( factory ) )-&gt;get_relative_name( ).
    DATA(factory_name) = to_upper( match( val = relative_name pcre = `.\Z` ) ).
    APPEND |Starting production of { cartype } using factory { factory_name } (class { relative_name })| TO lcl_log=&gt;log.

    factory-&gt;build( cartype ).
    paint( ).
    control_quality( ).
    test_drive( ).

    APPEND |Factory { factory_name }: { cartype } produced| TO lcl_log=&gt;log.

    &quot;Handling the log table for display purposes
    log = lcl_log=&gt;log.
    CLEAR lcl_log=&gt;log.
  ENDMETHOD.

  METHOD paint.
    factory-&gt;paint( cartype ).
  ENDMETHOD.

  METHOD control_quality.
    factory-&gt;control_quality( cartype ).
  ENDMETHOD.

  METHOD test_drive.
    factory-&gt;test_drive( cartype ).
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Refined abstractions
*&amp;---------------------------------------------------------------------*

&quot;test_drive, control_quality not refined
CLASS lcl_compact_car DEFINITION INHERITING FROM lcl_car.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS car_type REDEFINITION.
    METHODS paint REDEFINITION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_compact_car IMPLEMENTATION.
  METHOD car_type.
    cartype = `compact car`.
  ENDMETHOD.

  METHOD paint.
    APPEND |Compact-car-specific preparation step for painting| TO lcl_log=&gt;log.
    super-&gt;paint( ).
  ENDMETHOD.
ENDCLASS.

&quot;test_drive not refined
CLASS lcl_suv DEFINITION INHERITING FROM lcl_car.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS car_type REDEFINITION.
    METHODS paint REDEFINITION.
    METHODS control_quality REDEFINITION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_suv IMPLEMENTATION.
  METHOD car_type.
    cartype = `SUV`.
  ENDMETHOD.

  METHOD paint.
    APPEND |SUV-specific preparation step for painting| TO lcl_log=&gt;log.
    super-&gt;paint( ).
  ENDMETHOD.

  METHOD control_quality.
    APPEND |SUV-specific preparation step for quality control| TO lcl_log=&gt;log.
    super-&gt;control_quality( ).
  ENDMETHOD.
ENDCLASS.

&quot;paint not refined
CLASS lcl_sports_car DEFINITION INHERITING FROM lcl_car.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS car_type REDEFINITION.
    METHODS test_drive REDEFINITION.
    METHODS control_quality REDEFINITION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_sports_car IMPLEMENTATION.
  METHOD car_type.
    cartype = `sports car`.
  ENDMETHOD.

  METHOD test_drive.
    APPEND |Sports-car-specific preparation step for test drive| TO lcl_log=&gt;log.
    super-&gt;test_drive( ).
  ENDMETHOD.

  METHOD control_quality.
    APPEND |Sports-car-specific preparation step for quality control| TO lcl_log=&gt;log.
    super-&gt;control_quality( ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Builder</h2>
<ul>
<li>The idea is to simplify the creation of complex objects, which may involve multiple steps, by hiding this complexity from users.</li>
<li>Depending on requirements or user input, the class setup should allow for the creation of different objects that share similar or the same creation steps and attributes.</li>
<li>The builder design pattern may be useful here. Builder classes consolidate the necessary steps to create objects and return specific ones, allowing users to get the objects without taking care of the exact process.</li>
<li>By using the builder pattern, you can flexibly create different objects that follow the same or similar building processes. Builder classes also centralize code changes, and you can add more builder classes for additional use cases or objects.</li>
<li>The example tries to demonstrate the builder design pattern with the following class setup:</li>
<li>An abstract builder class defines the steps for object creation and includes methods and attributes shared by concrete builder classes responsible for creating specific objects. The example does not use an interface because the abstract class includes non-abstract methods performing general tasks not requiring object-specific implementations.</li>
<li>Multiple concrete builder classes inherit from the abstract superclass. They (can) follow the same object creation flow when redefining the superclass methods, but the implementation may vary among builder classes to serve different purposes for specific objects.</li>
<li>Another class orchestrates object creation. This class contains factory methods and acts as an object provider for external users (the global class in the example), simplifying object creation and hiding complexity. Users call a factory method, providing certain input parameters. Based on these values, specific objects are created by dedicated concrete builder classes. The orchestration class ensures methods are called in the correct sequence and returns the final created object.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>Purpose: The example represents an automatic internal table creator and table content creator using random values.</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Acts as a consumer of APIs, i.e. local classes defined in the CCIMP include.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li><code>lcl_itab_builder</code>:</li>
<li>An abstract builder class defining instance attributes and abstract methods. Concreate builder classes inherit from this superclass.</li>
<li>It is not an interface because it includes attributes and non-abstract methods for general tasks used by subclasses. These methods are in the public visibility section because the global example class also demonstrates their functionality.</li>
<li>The common building steps (i.e. the abstract methods) are:</li>
<li><code>build_type_info</code>: Checks if the provided type is available.</li>
<li><code>build_components</code>: Retrieves component names and their types (e.g., <code>string</code>, <code>i</code>, <code>decfloat34</code>).</li>
<li><code>build_table_keys</code>: Builds or verifies a list of primary table keys used for internal table creation, depending on whether a custom key list is supplied or default keys are used. The latter retrieves key components specified centrally in the DDIC, such as when DDIC database tables are used as type names.</li>
<li><code>build_table_type</code>: Builds a type description object based on the line type, table kind, and keys.</li>
<li><code>build_data_object</code>: Creates the internal table. For flexibility, it is created as an anonymous data object (<code>TYPE REF TO data</code>) using a dynamic <code>CREATE DATA</code> statement and the created type description object.</li>
<li><code>build_random_data</code>: Adds table entries to the created internal table, using nonsense random content for components with elementary types. Methods for retrieving random values are implemented in the abstract superclass.</li>
<li><code>lcl_builder_*</code> classes:</li>
<li>Concrete builder classes, such as <code>lcl_builder_std_itab_w_prkey</code>, that inherit from the abstract superclass.</li>
<li>These classes implement the abstract methods of the superclass, representing the step-by-step building process to create specific objects.</li>
<li>The example includes concrete builder classes that create standard tables with non-unique primary keys and empty keys, as well as sorted and hashed tables.</li>
<li><code>lcl_itab_data_provider</code>: A concrete builder class inheriting from the abstract builder class, used to populate existing internal tables with demo data. An internal table is passed as an actual parameter in a method described next.</li>
<li><code>lcl_itab_provider</code>:</li>
<li>Orchestrates the step-by-step object building process and provides the objects to users to hide complexity and guide creation.</li>
<li>Called by users, which is the global class in the example.</li>
<li>Contains two factory methods:</li>
<li><code>create_itab</code>: Used for internal table creation based on input parameters. It expects a line type name: globally available line types, such as DDIC database table or CDS entity names, or globally available elementary types for simple internal tables. Optionally, you can specify key component names for the target table; if component names not in the structure are used, they are ignored. If not specified, default key components are used to create tables with primary keys. Optionally, you can specify the number of table entries to create. The method returns an object with the table available via an instance attribute.</li>
<li><code>populate_itab</code>: Supplies existing local internal tables with nonsense random demo data. The method returns an object with the populated table available via an instance attribute.</li>
<li>Note:</li>
<li>This example is for experimentation and exploration. It does not claim to cover all aspects of the design pattern or internal table creation/population.</li>
<li>Excluded aspects include: Limited exception handling (a failing <code>ASSERT</code> statement is available in some cases), secondary table key handling, proper handling of key uniqueness, fixed or enumerated values, deep or nested components (such as references, nested structures, and tables), uppercase letters for character-like types, unnecessary population of the client field, returning the internal table in an output parameter (the table is available in an instance attribute of type <code>REF to data</code>).</li>
<li>The example uses repository objects from the ABAP cheat sheet repository. If you have not imported it, you can replace the <code>Z*</code> artifacts with others for exploration.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>&quot;! ABAP example demonstrating the builder design pattern
&quot;! See the disclaimer in the ABAP cheat sheet repository&#x27;s readme file.
CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
    CLASS-METHODS get_table_info IMPORTING itab TYPE ANY TABLE RETURNING VALUE(info) TYPE string_table.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Creating a string table that includes type names
    &quot;The entries include database table, CDS entity names of the ABAP cheat sheet repository.
    &quot;Plus, elementary types (built-in ABAP types) and a non-existent type are included.
    DATA(type_names) = VALUE string_table(
      ( `ZDEMO_ABAP_CARR` )
      ( `ZDEMO_ABAP_FLI` )
      ( `ZDEMO_ABAP_CARR_VE` )
      ( `ZDEMO_ABAP_ABSTRACT_ENT` )
      &quot;Elementary types
      ( `STRING` )
      ( `UTCLONG` )
      &quot;Non-existent type
      ( `TYPE_THAT_DOES_NOT_EXIST` ) ).

    out-&gt;write( `1) Creating standard tables with non-unique primary table keys` ).
    out-&gt;write( |\n| ).

    &quot;Specifying no key components, using default ones
    LOOP AT type_names INTO DATA(name).
      DATA(oref) = lcl_itab_provider=&gt;create_itab(
                     type_name         = name
                     table_kind        = lcl_itab_provider=&gt;standard_w_nonunique_pr_key
                     table_entry_count = 10 ).

      out-&gt;write( |------------- Table with line type { oref-&gt;type_name } -------------| ).
      out-&gt;write( |\n| ).

      IF oref-&gt;type_exists = abap_true.
        &quot;The example is designed to retrieve Table type informationrmation so as to display
        &quot;information such type and table keys of the internal table.
        DATA(info) = get_table_info( oref-&gt;itab-&gt;* ).
        out-&gt;write( `Table type information:` ).
        out-&gt;write( info ).
        out-&gt;write( |\n| ).
        out-&gt;write( oref-&gt;itab-&gt;*  ).
        out-&gt;write( |\n| ).
      ELSE.
        out-&gt;write( `Type does not exist. Internal table not created.` ).
        out-&gt;write( |\n| ).
      ENDIF.
    ENDLOOP.

    out-&gt;write( `------------- Key components explicitly specified -------------` ).
    out-&gt;write( |\n| ).

    &quot;Key components explicitly specified (including a non-existent component name that is ignored)
    DATA(oref_key_specified) = lcl_itab_provider=&gt;create_itab(
                   type_name         = `ZDEMO_ABAP_CARR`
                   table_kind        = lcl_itab_provider=&gt;standard_w_nonunique_pr_key
                   key_components    = VALUE #( ( `CARRID` ) ( `CARRNAME` ) ( `FALSE_COMPONENT` ) )
                   table_entry_count = 3 ).

    out-&gt;write( `------------- Table with line type ZDEMO_ABAP_CARR -------------` ).
    IF oref_key_specified-&gt;type_exists = abap_true.
      info = get_table_info( oref_key_specified-&gt;itab-&gt;* ).
      out-&gt;write( `Table type information:` ).
      out-&gt;write( info ).
      out-&gt;write( |\n| ).
      out-&gt;write( oref_key_specified-&gt;itab-&gt;*  ).
      out-&gt;write( |\n| ).
    ELSE.
      out-&gt;write( `Type does not exist. Internal table not created.` ).
      out-&gt;write( |\n| ).
    ENDIF.

    out-&gt;write( repeat( val = `*` occ = 100 ) ).
    out-&gt;write( |\n| ).

**********************************************************************

    out-&gt;write( `2) Creating standard tables with empty key` ).
    out-&gt;write( |\n| ).

    type_names = VALUE string_table(
       ( `ZDEMO_ABAP_FLSCH` )
       ( `D` ) ).

    LOOP AT type_names INTO name.
      DATA(oref_empty_key) = lcl_itab_provider=&gt;create_itab(
                     type_name         = name
                     table_kind        = lcl_itab_provider=&gt;standard_w_empty_key
                     &quot;Specified key components are ignored in the example
                     &quot;key_components    = VALUE #( ( `CARRID` ) ( `CARRNAME` ) )
                     table_entry_count = 3 ).

      out-&gt;write( |------------- Table with line type { oref_empty_key-&gt;type_name } -------------| ).
      out-&gt;write( |\n| ).

      IF oref_empty_key-&gt;type_exists = abap_true.
        info = get_table_info( oref_empty_key-&gt;itab-&gt;* ).
        out-&gt;write( `Table type information:` ).
        out-&gt;write( info ).
        out-&gt;write( |\n| ).
        out-&gt;write( oref_empty_key-&gt;itab-&gt;*  ).
        out-&gt;write( |\n| ).
      ELSE.
        out-&gt;write( `Type does not exist. Internal table not created.` ).
        out-&gt;write( |\n| ).
      ENDIF.
    ENDLOOP.

    out-&gt;write( repeat( val = `*` occ = 100 ) ).
    out-&gt;write( |\n| ).

**********************************************************************

    out-&gt;write( `3) Creating sorted tables with unique primary keys` ).
    out-&gt;write( |\n| ).

    type_names = VALUE string_table(
       ( `ZDEMO_ABAP_FLI` )
       ( `ZDEMO_ABAP_TAB1` )
       ( `T` ) ).

    LOOP AT type_names INTO name.
      DATA(oref_sorted) = lcl_itab_provider=&gt;create_itab(
                     type_name         = name
                     table_kind        = lcl_itab_provider=&gt;sorted_w_unique_pr_key
                     table_entry_count = 3 ).

      out-&gt;write( |------------- Table with line type { oref_sorted-&gt;type_name } -------------| ).
      out-&gt;write( |\n| ).

      IF oref_sorted-&gt;type_exists = abap_true.
        info = get_table_info( oref_sorted-&gt;itab-&gt;* ).
        out-&gt;write( `Table type information:` ).
        out-&gt;write( info ).
        out-&gt;write( |\n| ).
        out-&gt;write( oref_sorted-&gt;itab-&gt;*  ).
        out-&gt;write( |\n| ).
      ELSE.
        out-&gt;write( `Type does not exist. Internal table not created.` ).
        out-&gt;write( |\n| ).
      ENDIF.
    ENDLOOP.

    out-&gt;write( repeat( val = `*` occ = 100 ) ).
    out-&gt;write( |\n| ).

**********************************************************************

    out-&gt;write( `4) Creating hashed tables with unique primary keys` ).
    out-&gt;write( |\n| ).

    type_names = VALUE string_table(
       ( `ZDEMO_ABAP_CARR` )
       ( `ZDEMO_ABAP_TAB2` )
       ( `I` ) ).

    LOOP AT type_names INTO name.
      DATA(oref_hashed) = lcl_itab_provider=&gt;create_itab(
                     type_name         = name
                     table_kind        = lcl_itab_provider=&gt;hashed_w_unique_pr_key
                     table_entry_count = 3 ).

      out-&gt;write( |------------- Table with line type { oref_hashed-&gt;type_name } -------------| ).
      out-&gt;write( |\n| ).

      IF oref_hashed-&gt;type_exists = abap_true.
        info = get_table_info( oref_hashed-&gt;itab-&gt;* ).
        out-&gt;write( `Table type information:` ).
        out-&gt;write( info ).
        out-&gt;write( |\n| ).
        out-&gt;write( oref_hashed-&gt;itab-&gt;*  ).
        out-&gt;write( |\n| ).
      ELSE.
        out-&gt;write( `Type does not exist. Internal table not created.` ).
        out-&gt;write( |\n| ).
      ENDIF.
    ENDLOOP.

    out-&gt;write( repeat( val = `*` occ = 100 ) ).
    out-&gt;write( |\n| ).

**********************************************************************

    out-&gt;write( `5) Populating internal tables with random data` ).
    out-&gt;write( |\n| ).

    &quot;Demo internal tables to be filled
    DATA it_std1 TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY.
    DATA it_std2 TYPE string_table.
    DATA it_std3 TYPE TABLE OF i.

    TYPES: BEGIN OF various_types,
             c1        TYPE c LENGTH 1,
             c5        TYPE c LENGTH 5,
             c10       TYPE c LENGTH 10,
             str       TYPE string,
             int       TYPE i,
             f         TYPE f,
             dec16     TYPE decfloat16,
             dec34     TYPE decfloat34,
             i8        TYPE int8,
             n5        TYPE n LENGTH 5,
             time      TYPE t,
             date      TYPE d,
             timestamp TYPE utclong,
             x1        TYPE x LENGTH 1,
             x5        TYPE x LENGTH 5,
             xstr      TYPE xstring,
             pl2d1     TYPE p LENGTH 2 DECIMALS 1,
             pl3d2     TYPE p LENGTH 3 DECIMALS 2,
             pl4d3     TYPE p LENGTH 4 DECIMALS 3,
             pl5d4     TYPE p LENGTH 5 DECIMALS 4,
             pl6d5     TYPE p LENGTH 6 DECIMALS 5,
             pl7d6     TYPE p LENGTH 7 DECIMALS 6,
             pl8d7     TYPE p LENGTH 8 DECIMALS 7,
             pl9d8     TYPE p LENGTH 9 DECIMALS 8,
             pl10d9    TYPE p LENGTH 10 DECIMALS 9,
             pl11d10   TYPE p LENGTH 11 DECIMALS 10,
             pl12d11   TYPE p LENGTH 12 DECIMALS 11,
             pl13d12   TYPE p LENGTH 13 DECIMALS 12,
             pl14d13   TYPE p LENGTH 14 DECIMALS 13,
             pl15d14   TYPE p LENGTH 15 DECIMALS 14,
           END OF various_types.

    DATA it_std4 TYPE TABLE OF various_types WITH EMPTY KEY.

    &quot;Sorted tables
    DATA it_sorted1 TYPE SORTED TABLE OF zdemo_abap_flsch WITH NON-UNIQUE KEY primary_key COMPONENTS carrid connid cityfrom.
    DATA it_sorted2 TYPE SORTED TABLE OF zdemo_abap_fli WITH UNIQUE KEY carrid connid.
    DATA it_sorted3 TYPE SORTED TABLE OF utclong WITH NON-UNIQUE KEY table_line.

    &quot;Hashed tables
    DATA it_hashed1 TYPE HASHED TABLE OF zdemo_abap_flsch WITH UNIQUE KEY primary_key COMPONENTS carrid connid.
    TYPES n5 TYPE n LENGTH 5.
    DATA it_hashed2 TYPE HASHED TABLE OF n5 WITH UNIQUE KEY primary_key COMPONENTS table_line.

    TYPES table_refs TYPE TABLE OF REF TO data WITH EMPTY KEY.
    DATA(itab_refs) = VALUE table_refs(
      ( REF #( it_std1 ) )
      ( REF #( it_std2 ) )
      ( REF #( it_std3 ) )
      ( REF #( it_std4 ) )
      ( REF #( it_sorted1 ) )
      ( REF #( it_sorted2 ) )
      ( REF #( it_sorted3 ) )
      ( REF #( it_hashed1 ) )
      ( REF #( it_hashed2 ) ) ).

    LOOP AT itab_refs INTO DATA(ref).
      DATA(tabix) = sy-tabix.
      DATA(oref_populate_itab) = lcl_itab_provider=&gt;populate_itab(
                                   itab              = ref-&gt;*
                                   table_entry_count = 3
                                 ).

      out-&gt;write( |------------- Internal table { tabix } -------------| ).
      out-&gt;write( |\n| ).

      info = get_table_info( oref_populate_itab-&gt;itab-&gt;* ).
      out-&gt;write( `Table type information:` ).
      out-&gt;write( info ).

      out-&gt;write( |\n| ).
      out-&gt;write( oref_populate_itab-&gt;itab-&gt;*  ).
      out-&gt;write( |\n| ).
    ENDLOOP.

        out-&gt;write( repeat( val = `*` occ = 100 ) ).
    out-&gt;write( |\n| ).

**********************************************************************

    out-&gt;write( `6) Other line types` ).
    out-&gt;write( |\n| ).

    &quot;Other line types not supported in the example
*DATA(oref_not_working) = lcl_itab_provider=&gt;populate_itab(
*                             itab              = itab_refs
*                             table_entry_count = 3  ).

    &quot;Deep/nested line types are not supported
    &quot;These components remain initial.
    TYPES: BEGIN OF deep_type,
             flag   TYPE abap_boolean,
             c5     TYPE c LENGTH 5,
             strtab TYPE string_table,
             struc  TYPE zdemo_abap_carr,
           END OF deep_type.

    DATA deep_itab TYPE TABLE OF deep_type WITH EMPTY KEY.

    DATA(oref_deep) = lcl_itab_provider=&gt;populate_itab(
                                 itab              = deep_itab
                                 table_entry_count = 3  ).

    out-&gt;write( oref_deep-&gt;itab-&gt;*  ).
    out-&gt;write( |\n| ).
        out-&gt;write( repeat( val = `*` occ = 100 ) ).
    out-&gt;write( |\n| ).

**********************************************************************

    out-&gt;write( `7) Exploring the random value creation methods` ).
    out-&gt;write( |\n| ).

    out-&gt;write( `---------------- Getting random strings ----------------` ).
    DO 5 TIMES.
      DATA(str) = lcl_itab_builder=&gt;get_random_string( sy-index ).
      out-&gt;write( str ).
    ENDDO.

    out-&gt;write( `---------------- Getting random number sequences ----------------` ).
    DO 5 TIMES.
      DATA(number_set) = lcl_itab_builder=&gt;get_random_number_sequence( sy-index ).
      out-&gt;write( number_set ).
    ENDDO.

    out-&gt;write( `---------------- Getting random packed numbers ----------------` ).
    DO 15 TIMES.
      DATA(random_p) = lcl_itab_builder=&gt;get_random_p(
                         length = 8
                         decimals  = sy-index - 1 ).
      out-&gt;write( random_p-&gt;* ).
    ENDDO.

    out-&gt;write( `---------------- Getting random dates ----------------` ).
    DO 5 TIMES.
      DATA(random_d) = lcl_itab_builder=&gt;get_random_d( ).
      out-&gt;write( random_d ).
    ENDDO.

    out-&gt;write( `---------------- Getting random times ----------------` ).
    DO 5 TIMES.
      DATA(random_t) = lcl_itab_builder=&gt;get_random_t( ).
      out-&gt;write( random_t ).
    ENDDO.

    out-&gt;write( `---------------- Getting random UTC timestamps ----------------` ).
    DO 5 TIMES.
      DATA(random_utc) = lcl_itab_builder=&gt;get_random_utclong( ).
      out-&gt;write( random_utc ).
    ENDDO.

    out-&gt;write( `---------------- Getting random data objects of type decfloat16 ----------------` ).
    DO 5 TIMES.
      DATA(random_dec16) = lcl_itab_builder=&gt;get_random_dec16( ).
      out-&gt;write( random_dec16 ).
    ENDDO.

    out-&gt;write( `---------------- Getting random data objects of type decfloat34 ----------------` ).
    DO 5 TIMES.
      DATA(random_dec34) = lcl_itab_builder=&gt;get_random_dec34( ).
      out-&gt;write( random_dec34 ).
    ENDDO.

    out-&gt;write( `---------------- Getting random data objects of type f ----------------` ).
    DO 5 TIMES.
      DATA(random_f) = lcl_itab_builder=&gt;get_random_f( ).
      out-&gt;write( random_f ).
    ENDDO.

    out-&gt;write( `---------------- Getting random data objects of type x ----------------` ).

    DATA(xstr_1) = lcl_itab_builder=&gt;get_random_x( 1 ).
    DATA x1 TYPE x LENGTH 1.
    x1 = xstr_1.
    out-&gt;write( x1 ).

    DATA(xstr_2) = lcl_itab_builder=&gt;get_random_x( 2 ).
    DATA x2 TYPE x LENGTH 2.
    x2 = xstr_2.
    out-&gt;write( x2 ).

    DATA(xstr_8) = lcl_itab_builder=&gt;get_random_x( 8 ).
    DATA x8 TYPE x LENGTH 8.
    x8 = xstr_8.
    out-&gt;write( x8 ).

    out-&gt;write( `---------------- Getting random data objects of type xstring ----------------` ).

    DATA(xstr_a) = lcl_itab_builder=&gt;get_random_xstring( ).
    out-&gt;write( xstr_a ).
    DATA(xstr_b) = lcl_itab_builder=&gt;get_random_xstring( ).
    out-&gt;write( xstr_b ).
    DATA(xstr_c) = lcl_itab_builder=&gt;get_random_xstring( ).
    out-&gt;write( xstr_c ).

  ENDMETHOD.

  METHOD get_table_info.
    DATA(tab_type_info) = CAST cl_abap_tabledescr( cl_abap_typedescr=&gt;describe_by_data( itab ) ).

    &quot;Getting the table kind
    &quot;For the constant values of type abap_tablekind, see cl_abap_tabledescr. For example, &#x27;S&#x27;
    &quot;stands for a standard table.
    DATA(tab_table_kind) = tab_type_info-&gt;table_kind.
    INSERT |Table kind: { tab_table_kind }| INTO TABLE info.

    &quot;Checking if the table has a unique key
    DATA(tab_has_unique_key) = tab_type_info-&gt;has_unique_key.
    INSERT |Has a unique key: &quot;{ tab_has_unique_key }&quot; | &amp;&amp;
    |{ COND #( WHEN tab_has_unique_key IS INITIAL THEN `(no unique key)` ) }| INTO TABLE info.

    &quot;Returning a table with a description of all table keys, e.g. all components of a key,
    &quot;key kind (U, unique, in the example case), information whether the key is the primary
    &quot;key etc. For the constant values, see the cl_abap_tabledescr class.
    DATA(tab_keys) = tab_type_info-&gt;get_keys( ).

    INSERT |Table keys: { REDUCE string( INIT str = `` FOR &lt;key2&gt; IN tab_keys NEXT str = |{ str }| &amp;&amp;
    |{ COND #( WHEN str IS NOT INITIAL THEN `, ` ) }{ REDUCE string( INIT str2 = `` FOR &lt;key3&gt; IN &lt;key2&gt;-components NEXT str2 = |{ str2 }| &amp;&amp;
    |{ COND #( WHEN str2 IS NOT INITIAL THEN `/` ) }{ &lt;key3&gt;-name }| ) } (is primary: &quot;{ &lt;key2&gt;-is_primary }&quot;, |  &amp;&amp;
    |is unique: &quot;{ &lt;key2&gt;-is_unique }&quot;, key kind: &quot;{ &lt;key2&gt;-key_kind }&quot;, access kind: &quot;{ &lt;key2&gt;-access_kind }&quot;)| ) }| INTO TABLE info.
  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>&quot;Class for the builder
&quot;An abstract class is used as there are more general tasks performed by the subclasses.
&quot;These tasks are implemented in non-abstract methods in the class.
CLASS lcl_itab_builder DEFINITION ABSTRACT CREATE PUBLIC.
  PUBLIC SECTION.
    DATA type_name TYPE string.
    DATA primary_key_components TYPE string_table.
    DATA itab TYPE REF TO data.
    DATA table_entries_to_create TYPE i.
    DATA type_exists TYPE abap_boolean.
    DATA components TYPE cl_abap_structdescr=&gt;component_table.
    DATA is_elementary_line_type TYPE abap_boolean.
    DATA table_type_descr_obj TYPE REF TO cl_abap_tabledescr.
    DATA line_type TYPE REF TO cl_abap_datadescr.

    &quot;----------------------- Abstract methods -----------------------
    METHODS build_type_info ABSTRACT RETURNING VALUE(type_exists) TYPE abap_boolean.
    METHODS build_components ABSTRACT.
    METHODS build_table_keys ABSTRACT.
    METHODS build_table_type ABSTRACT.
    METHODS build_data_object ABSTRACT.
    METHODS build_random_data ABSTRACT.

    &quot;----------------------- Constants used in non-abstract methods -----------------------
    CONSTANTS character_set TYPE string VALUE `abcdefghijklmnopqrstuvwxyz0123456789`.
    CONSTANTS number_set TYPE string VALUE `0123456789`.
    CONSTANTS max_length TYPE i VALUE 10.
    CONSTANTS start_date TYPE d VALUE &#x27;20250101&#x27;.
    CONSTANTS start_time TYPE t VALUE &#x27;000000&#x27;.
    CONSTANTS max_table_entry_count TYPE i VALUE 50.
    CONSTANTS min_int_value TYPE i VALUE 1.
    CONSTANTS max_int_value TYPE i VALUE 100.
    CONSTANTS min_int8_value TYPE int8 VALUE 1.
    CONSTANTS max_int8_value TYPE int8 VALUE 100.
    CONSTANTS min_p_value TYPE p VALUE 0.
    CONSTANTS max_p_value TYPE p VALUE 9.

    &quot;----------------------- Non-abstract methods used by subclasses -----------------------
    &quot;They are intentionally included in the public visibility section for the demo in the
    &quot;global class.
    METHODS check_type.
    METHODS handle_keys.
    METHODS handle_components.

    METHODS add_table_entries
      IMPORTING
        VALUE(table_entry_count) TYPE i.

    CLASS-METHODS get_random_string
      IMPORTING
        length           TYPE i OPTIONAL
        randomize_length TYPE abap_boolean DEFAULT abap_true
          PREFERRED PARAMETER length
      RETURNING
        VALUE(str)       TYPE string.

    CLASS-METHODS get_random_number_sequence
      IMPORTING
        length           TYPE i OPTIONAL
        randomize_length TYPE abap_boolean DEFAULT abap_true
          PREFERRED PARAMETER length
      RETURNING
        VALUE(numbers)   TYPE string.

    CLASS-METHODS get_random_i
      IMPORTING min_value     TYPE i DEFAULT min_int_value
                max_value     TYPE i DEFAULT max_int_value
      RETURNING VALUE(number) TYPE i.

    CLASS-METHODS get_random_int8
      IMPORTING min_value     TYPE int8 DEFAULT min_int8_value
                max_value     TYPE int8 DEFAULT max_int8_value
      RETURNING VALUE(number) TYPE i.

    CLASS-METHODS get_random_p
      IMPORTING length               TYPE i
                decimals             TYPE i
                min_value            TYPE p DEFAULT min_p_value
                max_value            TYPE p DEFAULT max_p_value
      RETURNING VALUE(packed_number) TYPE REF TO data.

    CLASS-METHODS get_random_n
      IMPORTING length          TYPE i
      RETURNING VALUE(random_n) TYPE string.

    CLASS-METHODS get_random_d
      RETURNING VALUE(random_d) TYPE d.

    CLASS-METHODS get_random_t
      RETURNING VALUE(random_t) TYPE t.

    CLASS-METHODS get_random_utclong
      RETURNING VALUE(random_utc) TYPE utclong.

    CLASS-METHODS get_random_dec16
      RETURNING VALUE(random_dec16) TYPE decfloat16.

    CLASS-METHODS get_random_dec34
      RETURNING VALUE(random_dec34) TYPE decfloat34.

    CLASS-METHODS get_random_f
      RETURNING VALUE(random_f) TYPE f.

    CLASS-METHODS get_random_x
      IMPORTING length          TYPE i
      RETURNING VALUE(random_x) TYPE xstring.

    CLASS-METHODS get_random_xstring
      RETURNING VALUE(random_xstring) TYPE xstring.
  PROTECTED SECTION.
  PRIVATE SECTION.

ENDCLASS.

CLASS lcl_itab_builder IMPLEMENTATION.

  METHOD get_random_string.
    IF length IS NOT SUPPLIED.
      DATA(len) = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                              min  = 1
                                              max  = max_length )-&gt;get_next( ).
    ELSE.
      IF length NOT BETWEEN 1 AND max_length.
        len = max_length.
      ELSE.
        len = length.
      ENDIF.

      IF randomize_length = abap_true.
        len = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                          min  = 1
                                          max  = len )-&gt;get_next( ).
      ENDIF.
    ENDIF.

    DO len TIMES.
      DATA(num) = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                              min  = 0
                                              max  = strlen( character_set ) - 1 )-&gt;get_next( ).
      str &amp;&amp;= character_set+num(1).
    ENDDO.
  ENDMETHOD.

  METHOD get_random_number_sequence.
    IF length IS NOT SUPPLIED.
      DATA(len) = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                              min  = 1
                                              max  = max_length )-&gt;get_next( ).
    ELSE.
      IF length NOT BETWEEN 1 AND max_length.
        len = max_length.
      ELSE.
        len = length.
      ENDIF.
      IF randomize_length = abap_true.
        len = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                          min  = 1
                                          max  = len )-&gt;get_next( ).
      ENDIF.
    ENDIF.

    DO len TIMES.
      DATA(num) = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                              min  = 0
                                              max  = strlen( number_set ) - 1 )-&gt;get_next( ).
      numbers &amp;&amp;= number_set+num(1).
    ENDDO.
  ENDMETHOD.

  METHOD get_random_i.
    RETURN cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                       min  = min_value
                                       max  = max_value )-&gt;get_next( ).
  ENDMETHOD.

  METHOD get_random_int8.
    RETURN cl_abap_random_int8=&gt;create( seed = cl_abap_random=&gt;seed( )
                                        min  = min_value
                                        max  = max_value )-&gt;get_next( ).
  ENDMETHOD.

  METHOD get_random_p.
    IF length NOT BETWEEN 1 AND 16.
      RETURN.
    ENDIF.

    IF decimals NOT BETWEEN 0 AND 14.
      RETURN.
    ENDIF.

    TRY.
        CASE decimals.
          WHEN 0.
            DATA(a) = cl_abap_random_packed=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed=&gt;p31_0( min_value ) max = CONV cl_abap_random_packed=&gt;p31_0( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE a.
            packed_number-&gt;* = a.
          WHEN 1.
             DATA(b) = cl_abap_random_packed_dec1=&gt;create( seed = cl_abap_random=&gt;seed( )
                min = COND #( WHEN length = 1 THEN CONV cl_abap_random_packed_dec1=&gt;p31_1( &#x27;0.1&#x27; ) ELSE CONV cl_abap_random_packed_dec1=&gt;p31_1( min_value ) )
                max = COND #( WHEN length = 1 THEN CONV cl_abap_random_packed_dec1=&gt;p31_1( &#x27;0.9&#x27; ) ELSE CONV cl_abap_random_packed_dec1=&gt;p31_1( max_value ) )
              )-&gt;get_next( ).
            CREATE DATA packed_number LIKE b.
            packed_number-&gt;* = b.
          WHEN 2.
            DATA(c) = cl_abap_random_packed_dec2=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec2=&gt;p31_2( min_value ) max = CONV cl_abap_random_packed_dec2=&gt;p31_2( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE c.
            packed_number-&gt;* = c.
          WHEN 3.
            DATA(d) = cl_abap_random_packed_dec3=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec3=&gt;p31_3( min_value ) max = CONV cl_abap_random_packed_dec3=&gt;p31_3( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE d.
            packed_number-&gt;* = d.
          WHEN 4.
            DATA(e) = cl_abap_random_packed_dec4=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec4=&gt;p31_4( min_value ) max = CONV cl_abap_random_packed_dec4=&gt;p31_4( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE e.
            packed_number-&gt;* = e.
          WHEN 5.
            DATA(f) = cl_abap_random_packed_dec5=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec5=&gt;p31_5( min_value ) max = CONV cl_abap_random_packed_dec5=&gt;p31_5( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE f.
            packed_number-&gt;* = f.
          WHEN 6.
            DATA(g) = cl_abap_random_packed_dec6=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec6=&gt;p31_6( min_value ) max = CONV cl_abap_random_packed_dec6=&gt;p31_6( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE g.
            packed_number-&gt;* = g.
          WHEN 7.
            DATA(h) = cl_abap_random_packed_dec7=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec7=&gt;p31_7( min_value ) max = CONV cl_abap_random_packed_dec7=&gt;p31_7( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE h.
            packed_number-&gt;* = h.
          WHEN 8.
            DATA(i) = cl_abap_random_packed_dec8=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec8=&gt;p31_8( min_value ) max = CONV cl_abap_random_packed_dec8=&gt;p31_8( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE i.
            packed_number-&gt;* = i.
          WHEN 9.
            DATA(j) = cl_abap_random_packed_dec9=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec9=&gt;p31_9( min_value ) max = CONV cl_abap_random_packed_dec9=&gt;p31_9( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE j.
            packed_number-&gt;* = j.
          WHEN 10.
            DATA(k) = cl_abap_random_packed_dec10=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec10=&gt;p31_10( min_value ) max = CONV cl_abap_random_packed_dec10=&gt;p31_10( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE k.
            packed_number-&gt;* = k.
          WHEN 11.
            DATA(l) = cl_abap_random_packed_dec11=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec11=&gt;p31_11( min_value ) max = CONV cl_abap_random_packed_dec11=&gt;p31_11( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE l.
            packed_number-&gt;* = l.
          WHEN 12.
            DATA(m) = cl_abap_random_packed_dec12=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec12=&gt;p31_12( min_value ) max = CONV cl_abap_random_packed_dec12=&gt;p31_12( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE m.
            packed_number-&gt;* = m.
          WHEN 13.
            DATA(n) = cl_abap_random_packed_dec13=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec13=&gt;p31_13( min_value ) max = CONV cl_abap_random_packed_dec13=&gt;p31_13( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE n.
            packed_number-&gt;* = n.
          WHEN 14.
            DATA(o) = cl_abap_random_packed_dec14=&gt;create( seed = cl_abap_random=&gt;seed( ) min = CONV cl_abap_random_packed_dec14=&gt;p31_14( min_value ) max = CONV cl_abap_random_packed_dec14=&gt;p31_14( max_value ) )-&gt;get_next( ).
            CREATE DATA packed_number LIKE o.
            packed_number-&gt;* = o.
        ENDCASE.
      CATCH cx_root.
    ENDTRY.

  ENDMETHOD.

  METHOD get_random_n.
    IF length &gt; max_length OR length &lt; 1.
      DATA(len) = max_length.
    ELSE.
      len = length.
    ENDIF.
    random_n = get_random_number_sequence( len ).
  ENDMETHOD.

  METHOD get_random_d.
    DATA(int) = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                            min  = -100
                                            max  = 100 )-&gt;get_next( ).
    random_d =  start_date + int.
  ENDMETHOD.

  METHOD get_random_t.
    DATA(int) = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                            min  = -36000
                                            max  = 36000 )-&gt;get_next( ).
    random_t = start_time + int.
  ENDMETHOD.

  METHOD get_random_utclong.
    DATA(int) = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                            min  = -100
                                            max  = 100 )-&gt;get_next( ).

    random_utc = utclong_add( val = utclong_current( )
                              days = int
                              hours = int
                              minutes = int
                              seconds = int ).
  ENDMETHOD.

  METHOD get_random_dec16.
    random_dec16 = cl_abap_random_decfloat16=&gt;create( seed = cl_abap_random=&gt;seed( ) )-&gt;get_next( ).
  ENDMETHOD.

  METHOD get_random_dec34.
    random_dec34 = cl_abap_random_decfloat34=&gt;create( seed = cl_abap_random=&gt;seed( ) )-&gt;get_next( ).
  ENDMETHOD.

  METHOD get_random_f.
    random_f = cl_abap_random_float=&gt;create( seed = cl_abap_random=&gt;seed( ) )-&gt;get_next( ).
  ENDMETHOD.

  METHOD get_random_x.
    DATA(random_string) = get_random_string( length ).
    random_x = cl_abap_conv_codepage=&gt;create_out( codepage = `UTF-8` )-&gt;convert( random_string ).
  ENDMETHOD.

  METHOD get_random_xstring.
    DATA(random_string) = get_random_string( ).
    random_xstring = cl_abap_conv_codepage=&gt;create_out( codepage = `UTF-8` )-&gt;convert( random_string ).
  ENDMETHOD.

  METHOD add_table_entries.

    IF table_entry_count &lt; 0.
      table_entry_count = 1.
    ENDIF.

    IF table_entry_count &gt; max_table_entry_count.
      table_entry_count = max_table_entry_count.
    ENDIF.

    DO table_entry_count TIMES.
      INSERT INITIAL LINE INTO TABLE itab-&gt;* ASSIGNING FIELD-SYMBOL(&lt;line&gt;).

      LOOP AT components ASSIGNING FIELD-SYMBOL(&lt;comp&gt;).
        DATA(tabix) = sy-tabix.

        IF &lt;comp&gt;-type IS INSTANCE OF cl_abap_elemdescr.
          DATA(tdo_elem) = CAST cl_abap_elemdescr( &lt;comp&gt;-type ).
          DATA(type_kind) = tdo_elem-&gt;type_kind.
          DATA(output_length) = tdo_elem-&gt;output_length.
          DATA(length) = tdo_elem-&gt;length.
          DATA(decimals) = tdo_elem-&gt;decimals.

          CASE type_kind.
            WHEN cl_abap_typedescr=&gt;typekind_char.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_string( output_length ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_string( output_length ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_string.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_string( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_string( ).
              ENDIF.
            WHEN  cl_abap_typedescr=&gt;typekind_hex.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_x( output_length ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_x( output_length ).
              ENDIF.
            WHEN  cl_abap_typedescr=&gt;typekind_xstring.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_xstring( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_xstring( ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_num.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_n( output_length ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_n( output_length ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_time.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_t( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_t( ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_date.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_d( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_d( ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_utclong.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_utclong( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_utclong( ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_int
            OR cl_abap_typedescr=&gt;typekind_int1 OR
            cl_abap_typedescr=&gt;typekind_int2.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_i(  ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_i(  ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_int8.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_int8( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_int8( ).
              ENDIF.
            WHEN  cl_abap_typedescr=&gt;typekind_packed.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_p(
                                  length    = length
                                  decimals  = decimals
                                )-&gt;*.
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_p(
                                     length    = length
                                     decimals  = decimals
                                   )-&gt;*.
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_decfloat16.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; =  lcl_itab_builder=&gt;get_random_dec16( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_dec16( ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_decfloat34.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; = lcl_itab_builder=&gt;get_random_dec34( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_dec34( ).
              ENDIF.
            WHEN cl_abap_typedescr=&gt;typekind_float.
              IF is_elementary_line_type = abap_true.
                &lt;line&gt; =  lcl_itab_builder=&gt;get_random_f( ).
              ELSE.
                &lt;line&gt;-(tabix) = lcl_itab_builder=&gt;get_random_f( ).
              ENDIF.
          ENDCASE.
        ENDIF.
      ENDLOOP.
    ENDDO.
  ENDMETHOD.

  METHOD check_type.
    cl_abap_typedescr=&gt;describe_by_name( EXPORTING p_name = type_name
                                         RECEIVING p_descr_ref = DATA(tdo)
                                         EXCEPTIONS type_not_found = 4 ).

    IF sy-subrc &lt;&gt; 0.
      type_exists = abap_false.
      RETURN.
    ELSE.
      type_exists = abap_true.
      line_type = CAST #( tdo ).
    ENDIF.
  ENDMETHOD.

  METHOD handle_components.
    CASE TYPE OF line_type.
      WHEN TYPE cl_abap_structdescr.
        components = CAST cl_abap_structdescr( line_type )-&gt;get_components( ).
      WHEN TYPE cl_abap_elemdescr.
        is_elementary_line_type = abap_true.
        &quot;Build the components table manually with TABLE_LINE to enable a loop..
        DATA(tdo_elem) = CAST cl_abap_elemdescr( line_type ).
        components = VALUE #( ( name = `TABLE_LINE` type = tdo_elem ) ).
      WHEN OTHERS.
        ASSERT 1 = 0.
    ENDCASE.
  ENDMETHOD.

  METHOD handle_keys.
    &quot;Checking if the provided key names are components of the structured type
    &quot;In case of elementary line types, TABLE_LINE is used.
    IF primary_key_components IS NOT INITIAL.
      IF is_elementary_line_type = abap_true.
        CLEAR primary_key_components.
        APPEND `TABLE_LINE` TO primary_key_components.
      ELSE.
        DATA(comp_names) = CAST cl_abap_structdescr( line_type )-&gt;components.
        LOOP AT primary_key_components INTO DATA(prkey).
          IF NOT line_exists( components[ name = prkey ] ).
            DELETE primary_key_components WHERE table_line = prkey.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.

    &quot;If no key names are provided, and the type refers to a global structured type such as
    &quot;DDIC database tables or CDS entites, the following implementation collects those components
    &quot;that are specified as keys for the repository object.
    IF primary_key_components IS INITIAL AND is_elementary_line_type = abap_false.
      &quot;Checking whether the type is a global type, available as repository object.
      DATA(filter) = xco_cp_abap_repository=&gt;object_name-&gt;get_filter( xco_cp_abap_sql=&gt;constraint-&gt;equal( type_name ) ).
      DATA(repo_objects) = xco_cp_abap_repository=&gt;objects-&gt;where( VALUE #( ( filter ) ) )-&gt;in( xco_cp_abap=&gt;repository )-&gt;get( ).

      LOOP AT repo_objects INTO DATA(obj).
        DATA(val) = obj-&gt;type-&gt;value.
        IF val = `DDLS`.
          EXIT.
        ELSEIF val = `TABL`.
          EXIT.
        ENDIF.
      ENDLOOP.

      CASE val.
        WHEN `TABL`.
          &quot;Retrieving the key component names of DDIC database tables
          primary_key_components = xco_cp_abap_repository=&gt;object-&gt;tabl-&gt;database_table-&gt;for( CONV #( type_name ) )-&gt;fields-&gt;key-&gt;get_names( ).
          &quot;Assuming the first key field in the list is the client field, removing this field from the key components.
          DELETE primary_key_components INDEX 1.
        WHEN `DDLS`.
          &quot;Retrieving the key component names of CDS entities
          DATA(ddls_key_spec) = xco_cp_abap_repository=&gt;object-&gt;ddls-&gt;for( CONV #( type_name ) )-&gt;entity( )-&gt;fields-&gt;all-&gt;get_names( ).
          LOOP AT ddls_key_spec INTO DATA(k).
            DATA(is_key) = xco_cp_abap_repository=&gt;object-&gt;ddls-&gt;for( CONV #( type_name ) )-&gt;view_entity( )-&gt;field( k )-&gt;content( )-&gt;get_key_indicator( ).
            IF is_key IS NOT INITIAL.
              APPEND k TO primary_key_components.
            ENDIF.
          ENDLOOP.
      ENDCASE.
    ENDIF.

    &quot;If the primary key table is still empty, e.g. when referring to an CDS abstract entity, the following implementation
    &quot;adds the first component as key component.
    IF primary_key_components IS INITIAL AND is_elementary_line_type = abap_false.
      comp_names = CAST cl_abap_structdescr( line_type )-&gt;components.
      IF lines( comp_names ) &gt; 0.
        APPEND comp_names[ 1 ]-name TO primary_key_components.
      ENDIF.
    ENDIF.

    &quot;If an elementary line type is used, and the primary key table is still empty, adding TABLE_LINE.
    IF primary_key_components IS INITIAL AND is_elementary_line_type = abap_true.
      APPEND `TABLE_LINE` TO primary_key_components.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
&quot;Concrete example classes inheriting from the abstract class
&quot;The example concrete builder classes construct internal table of different
&quot;kinds. Among them, standard tables with non-unique primary table key,
&quot;standard tables with empty key, sorted and hashed tables.
&quot;Additionally, a concrete builder class creates random data for an internal
&quot;table that is supplied when calling the object creation method.

CLASS lcl_builder_std_itab_w_prkey DEFINITION INHERITING FROM lcl_itab_builder CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS: build_type_info REDEFINITION,
      build_table_type REDEFINITION,
      build_data_object REDEFINITION,
      build_random_data REDEFINITION,
      build_table_keys REDEFINITION,
      build_components REDEFINITION.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_builder_std_itab_w_prkey IMPLEMENTATION.

  METHOD build_type_info.
    check_type( ).
  ENDMETHOD.

  METHOD build_components.
    CHECK type_exists = abap_true.
    handle_components( ).
  ENDMETHOD.

  METHOD build_table_keys.
    CHECK type_exists = abap_true.
    handle_keys( ).
  ENDMETHOD.

  METHOD build_table_type.
    CHECK type_exists = abap_true.

    table_type_descr_obj = cl_abap_tabledescr=&gt;get(
          p_line_type  = line_type
          p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
          p_key        = VALUE #( FOR wa IN primary_key_components ( name = wa ) )
          p_unique     = cl_abap_typedescr=&gt;false ).
  ENDMETHOD.

  METHOD build_data_object.
    CHECK type_exists = abap_true.
    CREATE DATA itab TYPE HANDLE table_type_descr_obj.
    &quot;Note: As the keys are non-unique, no temporary table is created as in other concrete
    &quot;builder classes.
  ENDMETHOD.

  METHOD build_random_data.
    CHECK type_exists = abap_true.
    add_table_entries( table_entries_to_create ).
  ENDMETHOD.
ENDCLASS.

**********************************************************************

CLASS lcl_builder_std_itab_empty_key DEFINITION INHERITING FROM lcl_itab_builder CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS: build_type_info REDEFINITION,
      build_table_keys REDEFINITION,
      build_table_type REDEFINITION,
      build_data_object REDEFINITION,
      build_random_data REDEFINITION,
      build_components REDEFINITION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_builder_std_itab_empty_key IMPLEMENTATION.
  METHOD build_type_info.
    check_type( ).
  ENDMETHOD.

  METHOD build_components.
    CHECK type_exists = abap_true.
    handle_components( ).
  ENDMETHOD.

  METHOD build_table_keys.
    CHECK type_exists = abap_true.
    CLEAR primary_key_components.
  ENDMETHOD.

  METHOD build_table_type.
    CHECK type_exists = abap_true.

    table_type_descr_obj = cl_abap_tabledescr=&gt;get(
           p_line_type  = line_type
           p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
           p_key_kind = cl_abap_tabledescr=&gt;keydefkind_empty ).
  ENDMETHOD.

  METHOD build_data_object.
    CHECK type_exists = abap_true.
    CREATE DATA itab TYPE HANDLE table_type_descr_obj.
  ENDMETHOD.

  METHOD build_random_data.
    CHECK type_exists = abap_true.
    add_table_entries( table_entries_to_create ).
  ENDMETHOD.
ENDCLASS.

**********************************************************************

CLASS lcl_builder_sorted_itab DEFINITION INHERITING FROM lcl_itab_builder CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS: build_type_info REDEFINITION,
      build_table_keys REDEFINITION,
      build_table_type REDEFINITION,
      build_data_object REDEFINITION,
      build_random_data REDEFINITION,
      build_components REDEFINITION.

  PROTECTED SECTION.
  PRIVATE SECTION.
    &quot;Attributes for tables that stores content and the table type
    DATA temporary_itab TYPE REF TO data.
    DATA temporary_table_type TYPE REF TO cl_abap_tabledescr.
ENDCLASS.

CLASS lcl_builder_sorted_itab IMPLEMENTATION.
  METHOD build_type_info.
    check_type( ).
  ENDMETHOD.

  METHOD build_components.
    CHECK type_exists = abap_true.
    handle_components( ).
  ENDMETHOD.

  METHOD build_table_keys.
    CHECK type_exists = abap_true.
    handle_keys( ).
  ENDMETHOD.

  METHOD build_table_type.
    CHECK type_exists = abap_true.

    table_type_descr_obj = cl_abap_tabledescr=&gt;get(
           p_line_type  = line_type
           p_table_kind = cl_abap_tabledescr=&gt;tablekind_sorted
           p_key        = VALUE #( FOR wa IN primary_key_components ( name = wa ) )
           p_unique     = cl_abap_typedescr=&gt;true ).

    &quot;In the previous statement, the type description object for the created table type
    &quot;is assigned. The following assignment is performed for a temporary table.
    &quot;This is done to not interfere with unique primary table keys and non-modifiable components
    &quot;when adding table entries (because the creation procedure shared by all objects is performed
    &quot;using the &#x27;itab&#x27; attribute. Therefore, a standard table with empty key is created using the
    &quot;same line type. The table entries are added to this table. In a later step, the table entries
    &quot;are copied back to the original internal table.
    temporary_table_type = cl_abap_tabledescr=&gt;get(
            p_line_type  = line_type
            p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
            p_key_kind = cl_abap_tabledescr=&gt;keydefkind_empty ).

  ENDMETHOD.

  METHOD build_data_object.
    CHECK type_exists = abap_true.

    &quot;Creating two internal tables
    &quot;See the comment in the build_table_type method.
    CREATE DATA itab TYPE HANDLE temporary_table_type.
    CREATE DATA temporary_itab TYPE HANDLE table_type_descr_obj.
  ENDMETHOD.

  METHOD build_random_data.
    CHECK type_exists = abap_true.
    add_table_entries( table_entries_to_create ).

    &quot;See the comment in the build_table_type method.
    LOOP AT itab-&gt;* ASSIGNING FIELD-SYMBOL(&lt;a&gt;).
      INSERT &lt;a&gt; INTO TABLE temporary_itab-&gt;*.
    ENDLOOP.

    CLEAR itab.
    CREATE DATA itab LIKE temporary_itab-&gt;*.

    LOOP AT temporary_itab-&gt;* ASSIGNING FIELD-SYMBOL(&lt;b&gt;).
      INSERT &lt;b&gt; INTO TABLE itab-&gt;*.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

CLASS lcl_builder_hashed_itab DEFINITION INHERITING FROM lcl_itab_builder CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS: build_type_info REDEFINITION,
      build_table_keys REDEFINITION,
      build_table_type REDEFINITION,
      build_data_object REDEFINITION,
      build_random_data REDEFINITION,
      build_components REDEFINITION.

  PROTECTED SECTION.
  PRIVATE SECTION.
    &quot;See the comment in the build_table_type method of class lcl_builder_sorted_itab.
    DATA temporary_itab TYPE REF TO data.
    DATA temporary_table_type TYPE REF TO cl_abap_tabledescr.
ENDCLASS.

CLASS lcl_builder_hashed_itab IMPLEMENTATION.

  METHOD build_type_info.
    check_type( ).
  ENDMETHOD.

  METHOD build_components.
    CHECK type_exists = abap_true.
    handle_components( ).
  ENDMETHOD.

  METHOD build_table_keys.
    CHECK type_exists = abap_true.
    handle_keys( ).
  ENDMETHOD.

  METHOD build_table_type.
    CHECK type_exists = abap_true.

    &quot;See the comment in the build_table_type method of class lcl_builder_sorted_itab.
    table_type_descr_obj = cl_abap_tabledescr=&gt;get(
           p_line_type  = line_type
           p_table_kind = cl_abap_tabledescr=&gt;tablekind_hashed
           p_key        = VALUE #( FOR wa IN primary_key_components ( name = wa ) )
           p_unique     = cl_abap_typedescr=&gt;true ).

    temporary_table_type = cl_abap_tabledescr=&gt;get(
            p_line_type  = line_type
            p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
            p_key_kind = cl_abap_tabledescr=&gt;keydefkind_empty ).
  ENDMETHOD.

  METHOD build_data_object.
    CHECK type_exists = abap_true.

    &quot;See the comment in the build_table_type method of class lcl_builder_sorted_itab.
    CREATE DATA itab TYPE HANDLE temporary_table_type.
    CREATE DATA temporary_itab TYPE HANDLE table_type_descr_obj.
  ENDMETHOD.

  METHOD build_random_data.
    CHECK type_exists = abap_true.
    add_table_entries( table_entries_to_create ).

    &quot;See the comment in the build_table_type method of class lcl_builder_sorted_itab.
    LOOP AT itab-&gt;* ASSIGNING FIELD-SYMBOL(&lt;a&gt;).
      INSERT &lt;a&gt; INTO TABLE temporary_itab-&gt;*.
    ENDLOOP.

    CLEAR itab.
    CREATE DATA itab LIKE temporary_itab-&gt;*.

    LOOP AT temporary_itab-&gt;* ASSIGNING FIELD-SYMBOL(&lt;b&gt;).
      INSERT &lt;b&gt; INTO TABLE itab-&gt;*.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

CLASS lcl_itab_data_provider DEFINITION INHERITING FROM lcl_itab_builder CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS: build_type_info REDEFINITION,
      build_table_keys REDEFINITION,
      build_table_type REDEFINITION,
      build_data_object REDEFINITION,
      build_random_data REDEFINITION,
      build_components REDEFINITION.

    METHODS constructor IMPORTING itab TYPE ANY TABLE.
  PROTECTED SECTION.
  PRIVATE SECTION.
    &quot;See the comment in the build_table_type method of class lcl_builder_sorted_itab.
    DATA temporary_itab TYPE REF TO data.
    DATA temporary_table_type TYPE REF TO cl_abap_tabledescr.
ENDCLASS.

CLASS lcl_itab_data_provider IMPLEMENTATION.

  METHOD build_type_info.
    line_type = table_type_descr_obj-&gt;get_table_line_type( ).
  ENDMETHOD.

  METHOD build_components.
    handle_components( ).
  ENDMETHOD.

  METHOD build_table_keys.
    &quot;The table type including the key components is provided by the table supplied.
    CLEAR primary_key_components.
  ENDMETHOD.

  METHOD build_table_type.
    &quot;See the comment in the build_table_type method of class lcl_builder_sorted_itab.
    temporary_table_type = cl_abap_tabledescr=&gt;get(
            p_line_type  = line_type
            p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
            p_key_kind = cl_abap_tabledescr=&gt;keydefkind_empty ).
  ENDMETHOD.

  METHOD build_data_object.
    &quot;See the comment in the build_table_type method of class lcl_builder_sorted_itab.
    CREATE DATA itab TYPE HANDLE temporary_table_type.
    CREATE DATA temporary_itab TYPE HANDLE table_type_descr_obj.
  ENDMETHOD.

  METHOD build_random_data.
    add_table_entries( table_entries_to_create ).

    &quot;See the comment in the build_table_type method of class lcl_builder_sorted_itab.
    LOOP AT itab-&gt;* ASSIGNING FIELD-SYMBOL(&lt;a&gt;).
      INSERT &lt;a&gt; INTO TABLE temporary_itab-&gt;*.
    ENDLOOP.

    CLEAR itab.
    CREATE DATA itab LIKE temporary_itab-&gt;*.

    LOOP AT temporary_itab-&gt;* ASSIGNING FIELD-SYMBOL(&lt;b&gt;).
      INSERT &lt;b&gt; INTO TABLE itab-&gt;*.
    ENDLOOP.
  ENDMETHOD.

  METHOD constructor.
    super-&gt;constructor( ).
    table_type_descr_obj = CAST cl_abap_tabledescr( cl_abap_typedescr=&gt;describe_by_data( itab ) ).
  ENDMETHOD.
ENDCLASS.

**********************************************************************
&quot;Class that includes factory methods that provide objects of the
&quot;concrete builder classes
&quot;The class is used by the consumers such as the global class in this
&quot;example. It is responsible for a correct order of method calls so that
&quot;an appropriate and correct object is returned.

CLASS lcl_itab_provider DEFINITION FINAL CREATE PRIVATE.
  PUBLIC SECTION.
    TYPES: BEGIN OF ENUM table_kind,
             standard_w_nonunique_pr_key,
             sorted_w_unique_pr_key,
             hashed_w_unique_pr_key,
             standard_w_empty_key,
           END OF ENUM table_kind.

    CLASS-METHODS create_itab IMPORTING VALUE(type_name)  TYPE string
                                        table_kind        TYPE lcl_itab_provider=&gt;table_kind DEFAULT standard_w_empty_key
                                        key_components    TYPE string_table OPTIONAL
                                        table_entry_count TYPE i DEFAULT 3
                              RETURNING VALUE(build)      TYPE REF TO lcl_itab_builder.

    CLASS-METHODS populate_itab IMPORTING itab              TYPE ANY TABLE
                                          table_entry_count TYPE i DEFAULT 3
                                RETURNING VALUE(build)      TYPE REF TO lcl_itab_builder.
ENDCLASS.

CLASS lcl_itab_provider IMPLEMENTATION.
  METHOD create_itab.
    type_name = to_upper( condense( val = type_name to = `` ) ).

    CASE table_kind.
      WHEN standard_w_nonunique_pr_key.
        build = NEW lcl_builder_std_itab_w_prkey( ).
      WHEN standard_w_empty_key.
        build = NEW lcl_builder_std_itab_empty_key( ).
      WHEN sorted_w_unique_pr_key.
        build = NEW lcl_builder_sorted_itab( ).
      WHEN hashed_w_unique_pr_key.
        build = NEW lcl_builder_hashed_itab( ).
      WHEN OTHERS.
        ASSERT 1 = 0.
    ENDCASE.

    build-&gt;type_name = type_name.
    build-&gt;table_entries_to_create = table_entry_count.
    build-&gt;primary_key_components = key_components.
    build-&gt;build_type_info( ).
    build-&gt;build_components( ).
    build-&gt;build_table_keys( ).
    build-&gt;build_table_type( ).
    build-&gt;build_data_object( ).
    build-&gt;build_random_data( ).
  ENDMETHOD.

  METHOD populate_itab.
    build = NEW lcl_itab_data_provider( itab ).
    build-&gt;table_entries_to_create = table_entry_count.
    build-&gt;build_type_info( ).
    build-&gt;build_components( ).
    build-&gt;build_table_type( ).
    build-&gt;build_data_object( ).
    build-&gt;build_random_data( ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Chain of Responsibility</h2>
<ul>
<li>The idea behind the chain of responsibility design pattern is organizing handlers in a sequence (a chain), allowing for flexible request processing, potentially without knowing which handler will handle the request at compile time.</li>
<li>Requests move through this chain of handlers until one is found that can process it.</li>
<li>A potential setup, illustrated in the following example, may look like this:</li>
<li>An interface defines methods for processing requests.</li>
<li>An abstract handler class that implements the interface, includes default behavior, and maintains a reference to the next handler in the chain.</li>
<li>Concrete handler classes that inherit from the abstract handler, deciding whether to process the request or pass it to the next handler.</li>
<li>A client that establishes the chain of responsibility and sends requests.</li>
<li>This pattern may be useful for creating flexible and maintainable setups, especially when processing various types of requests differently, managing multiple handlers without knowing in advance which one will actually handle the requests, following indeed a specific processing sequence, enabling easy extension by adding new concrete handlers, and more.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example demonstrates the chain of responsibility design pattern through the following declarations and implementations. Note that the example is simplified, and various class setup strategies may apply.</li>
<li>As example context, it uses the retrieval of type information (RTTI) based on type description objects. For more details on RTTI and type description objects, refer to the Dynamic Programming cheat sheet. Different handler classes handle specific type description objects, including handlers for elementary, structured, and table types. Classes that can handle other types are not implemented. They should be handled by a default handler class.</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Acts as the client to demonstrate the design pattern. The declarations and implementations in the <em>CCIMP include</em> are relevant for conceptual considerations.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Interface <code>lif_chain_of_resp</code>:</li>
<li>Defines the shared interface for concrete handler classes in the chain of responsibility.</li>
<li>Includes the <code>process</code> method for processing type description objects and returning type information (mutliple pieces of information are stored in a string table for display purposes), and the <code>set_handler</code> method for assigning the next handler in the chain.</li>
<li>Class <code>lcl_base_handler</code></li>
<li>Represents an abstract handler class that provides default implementations for concrete handler classes inheriting from it.</li>
<li>Since it is defined as an abstract class, it cannot be instantiated directly. Only its subclasses can be instantiated.</li>
<li>The class maintains a reference to the next handler in the protected <code>iref_handler</code> attribute.</li>
<li>By implementing the <code>lif_chain_of_resp</code> interface, it provides the methods <code>lif_chain_of_resp~set_handler</code> for setting the next handler and <code>lif_chain_of_resp~process</code> for processing requests.</li>
<li><code>lcl_concrete_handler*</code> classes</li>
<li>Represents concrete handler classes that inherit from the <code>lcl_base_handler</code> class.</li>
<li>These classes provide specific implementations for handling different types of type description objects.</li>
<li>The example includes handler classes for processing elementary, structured, and table types. Other types are not addressed in detail.</li>
<li>If a class cannot handle the request (because the type description object has another type), it calls the next handler in the chain. For types not covered by the example, the default handler class <code>lcl_concrete_handler4</code> can manage requests and provide general information (no casting is implemented to obtain more specific type information as in other concrete handler classes).</li>
<li>The purpose of the example is to illustrate the following:</li>
<li>The client, represented by the implementations in the global class, determines the chain of responsibility by setting the concrete sequence of handler calls and starting requests.</li>
<li>These requests (represented by passing a type description object) are processed by handler class objects.</li>
<li>Each handler in the chain attempts to process the request. If a handler can handle the respective type description, it processes it. Otherwise, it delegates the request to the next handler in the chain.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS process_chain IMPORTING type_description_object TYPE REF TO cl_abap_typedescr
                                    example                 TYPE string
                                    out                     TYPE REF TO if_oo_adt_classrun_out.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;---------------------------------------------------------------------*
*&amp; Example 1: Elementary type (local type)
*&amp;---------------------------------------------------------------------*

    TYPES packed TYPE p LENGTH 16 DECIMALS 14.
    DATA(type_descr_obj) = cl_abap_typedescr=&gt;describe_by_name( &#x27;PACKED&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example = `1) Elementary type (local type)`
      out                     = out
    ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 2: Elementary type (global DDIC type)
*&amp;---------------------------------------------------------------------*

    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;LAND1&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example = `2) Elementary type (global DDIC type)`
      out                     = out
    ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 3: Structured type (local type)
*&amp;---------------------------------------------------------------------*

    TYPES: BEGIN OF demo_struc,
             comp1 TYPE c LENGTH 3,
             comp2 TYPE i,
             comp3 TYPE string,
             comp4 TYPE n LENGTH 5,
           END OF demo_struc.

    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;DEMO_STRUC&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example                 = `3) Structured type (local type)`
      out                     = out
    ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 4: Structured type (global type)
*&amp;---------------------------------------------------------------------*

    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;I_TIMEZONE&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example                 = `4) Structured type (global type)`
      out                     = out
    ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 5: Table type (local type)
*&amp;---------------------------------------------------------------------*

    TYPES tab_type TYPE HASHED TABLE OF demo_struc
      WITH UNIQUE KEY comp1 comp2
      WITH NON-UNIQUE SORTED KEY sk COMPONENTS comp4.

    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;TAB_TYPE&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example                 = `5) Table type (local type)`
      out                     = out
    ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 6: Table type (global type)
*&amp;---------------------------------------------------------------------*

    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;STRING_TABLE&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example                 = `6) Table type (global type)`
      out                     = out
    ).

*&amp;---------------------------------------------------------------------*
*&amp; Examples for types that are not covered by concrete handler classes
*&amp;---------------------------------------------------------------------*

    &quot;Enumerated type
    TYPES: BEGIN OF ENUM t_enum,
             a,
             b,
             c,
             d,
           END OF ENUM t_enum.

    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;T_ENUM&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example                 = `7) Enumerated type`
      out                     = out
    ).

    &quot;Reference type
    TYPES ref TYPE REF TO string.

    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;REF&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example                 = `8) Reference type`
      out                     = out
    ).

    &quot;Class
    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;CL_SYSTEM_UUID&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example                 = `9) Class`
      out                     = out
    ).

    &quot;Interface
    type_descr_obj = cl_abap_typedescr=&gt;describe_by_name( &#x27;IF_OO_ADT_CLASSRUN&#x27; ).

    process_chain(
      type_description_object = type_descr_obj
      example                 = `10) Interface`
      out                     = out
    ).
  ENDMETHOD.

  METHOD process_chain.
    DATA: handler1 TYPE REF TO lif_chain_of_resp,
          handler2 TYPE REF TO lif_chain_of_resp,
          handler3 TYPE REF TO lif_chain_of_resp,
          handler4 TYPE REF TO lif_chain_of_resp,
          info_tab TYPE string_table.

    handler1 = NEW lcl_concrete_handler1( ).
    handler2 = NEW lcl_concrete_handler2( ).
    handler3 = NEW lcl_concrete_handler3( ).
    handler4 = NEW lcl_concrete_handler4( ).

    handler1-&gt;set_handler( handler2 ).
    handler2-&gt;set_handler( handler3 ).
    handler3-&gt;set_handler( handler4 ).

    DATA(info) = handler1-&gt;process( type_description_object ).

    IF info IS INITIAL.
      APPEND |-------------------- { example } --------------------| TO info.
    ELSE.
      INSERT LINES OF VALUE string_table( ( |-------------------- { example } --------------------| ) ( ) ) INTO info INDEX 1.
    ENDIF.

    out-&gt;write( info ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 100 ) }\n\n| ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_chain_of_resp.
  METHODS: process IMPORTING type_descr  TYPE REF TO cl_abap_typedescr
                   RETURNING VALUE(info) TYPE string_table,
    set_handler IMPORTING iref TYPE REF TO lif_chain_of_resp.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Abstract handler class
*&amp;---------------------------------------------------------------------*

CLASS lcl_base_handler DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES lif_chain_of_resp.
  PROTECTED SECTION.
    DATA iref_handler TYPE REF TO lif_chain_of_resp.
ENDCLASS.

CLASS lcl_base_handler IMPLEMENTATION.
  METHOD lif_chain_of_resp~set_handler.
    me-&gt;iref_handler = iref.
  ENDMETHOD.

  METHOD lif_chain_of_resp~process.
    IF iref_handler IS INITIAL.
      APPEND `Cannot handle request` TO info.
    ELSE.
      info = iref_handler-&gt;process( type_descr ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete handler classes
*&amp;---------------------------------------------------------------------*

CLASS lcl_concrete_handler1 DEFINITION INHERITING FROM lcl_base_handler.
  PUBLIC SECTION.
    METHODS lif_chain_of_resp~process REDEFINITION.
ENDCLASS.

CLASS lcl_concrete_handler1 IMPLEMENTATION.
  METHOD lif_chain_of_resp~process.
    DATA(cl_name) = CAST cl_abap_classdescr( cl_abap_typedescr=&gt;describe_by_object_ref( me ) )-&gt;get_relative_name( ).

    IF type_descr IS INSTANCE OF cl_abap_elemdescr
    AND type_descr IS NOT INSTANCE OF cl_abap_enumdescr.
      APPEND |Class { cl_name } handled request.| TO info.
      APPEND `--- Type information ---` TO info.

      DATA(tdo_elem) = CAST cl_abap_elemdescr( type_descr ).
      DATA(type_category_elem) = tdo_elem-&gt;kind.
      DATA(type_kind_elem) = tdo_elem-&gt;type_kind.
      DATA(decimals_elem) = tdo_elem-&gt;decimals.
      DATA(output_length_elem) = tdo_elem-&gt;output_length.
      DATA(absolute_name_elem) = tdo_elem-&gt;absolute_name.
      DATA(relative_name_elem) = tdo_elem-&gt;get_relative_name( ).
      DATA(is_ddic_type_elem) = tdo_elem-&gt;is_ddic_type( ).

      APPEND |Type category: { type_category_elem }| TO info.
      APPEND |Type kind: { type_kind_elem }| TO info.
      APPEND |Decimals: { decimals_elem }| TO info.
      APPEND |Output length: { output_length_elem }| TO info.
      APPEND |Absolute name: { absolute_name_elem }| TO info.
      APPEND |Relative name: { relative_name_elem }| TO info.
      APPEND |Is DDIC type: { COND #( WHEN is_ddic_type_elem = abap_true THEN abap_true ELSE `-` ) }| TO info.
    ELSE.
      info = super-&gt;lif_chain_of_resp~process( type_descr ).
      IF info IS INITIAL.
        APPEND |Class { cl_name } could not handle request.| TO info.
      ELSE.
        INSERT |Class { cl_name } could not handle request.| INTO info INDEX 1.
      ENDIF.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_concrete_handler2 DEFINITION INHERITING FROM lcl_base_handler.
  PUBLIC SECTION.
    METHODS lif_chain_of_resp~process REDEFINITION.
ENDCLASS.

CLASS lcl_concrete_handler2 IMPLEMENTATION.
  METHOD lif_chain_of_resp~process.
    DATA(cl_name) = CAST cl_abap_classdescr( cl_abap_typedescr=&gt;describe_by_object_ref( me ) )-&gt;get_relative_name( ).

    IF type_descr IS INSTANCE OF cl_abap_structdescr.
      APPEND |Class { cl_name } handled request.| TO info.
      APPEND `--- Type information ---` TO info.

      DATA(tdo_struc) = CAST cl_abap_structdescr( type_descr ).
      DATA(type_category_struc) = tdo_struc-&gt;kind.
      DATA(type_kind_struc) = tdo_struc-&gt;type_kind.
      DATA(absolute_name_struc) = tdo_struc-&gt;absolute_name.
      DATA(relative_name_struc) = tdo_struc-&gt;get_relative_name( ).
      DATA(is_ddic_type_struc) = tdo_struc-&gt;is_ddic_type( ).
      DATA(comps_struc) = tdo_struc-&gt;components.

      APPEND |Type category: { type_category_struc }| TO info.
      APPEND |Type kind: { type_kind_struc }| TO info.
      APPEND |Absolute name: { absolute_name_struc }| TO info.
      APPEND |Relative name: { relative_name_struc }| TO info.
      APPEND |Is DDIC type: { COND #( WHEN is_ddic_type_struc = abap_true THEN abap_true ELSE `-` ) }| TO info.
      APPEND |Components: { REDUCE string( INIT s = VALUE #( ) FOR wa IN comps_struc NEXT s &amp;&amp;= |{ COND #( WHEN s IS NOT INITIAL THEN ` ` ) }{ wa-name }| ) }| TO info.
    ELSE.
      info = super-&gt;lif_chain_of_resp~process( type_descr ).
      IF info IS INITIAL.
        APPEND |Class { cl_name } could not handle request.| TO info.
      ELSE.
        INSERT |Class { cl_name } could not handle request.| INTO info INDEX 1.
      ENDIF.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_concrete_handler3 DEFINITION INHERITING FROM lcl_base_handler.
  PUBLIC SECTION.
    METHODS lif_chain_of_resp~process REDEFINITION.
ENDCLASS.

CLASS lcl_concrete_handler3 IMPLEMENTATION.
  METHOD lif_chain_of_resp~process.
    DATA(cl_name) = CAST cl_abap_classdescr( cl_abap_typedescr=&gt;describe_by_object_ref( me ) )-&gt;get_relative_name( ).

    IF type_descr IS INSTANCE OF cl_abap_tabledescr.
      APPEND |Class { cl_name } handled request.| TO info.
      APPEND `--- Type information ---` TO info.

      DATA(tdo_tab) = CAST cl_abap_tabledescr( type_descr ).
      DATA(type_category_tab) = tdo_tab-&gt;kind.
      DATA(type_kind_tab) = tdo_tab-&gt;type_kind.
      DATA(absolute_name_tab) = tdo_tab-&gt;absolute_name.
      DATA(relative_name_tab) = tdo_tab-&gt;get_relative_name( ).
      DATA(table_kind_itab) = tdo_tab-&gt;table_kind.
      DATA(table_has_unique_key_itab) = tdo_tab-&gt;has_unique_key.
      DATA(table_keys_itab) = tdo_tab-&gt;get_keys( ).
      DATA(table_is_ddic_typw) = tdo_tab-&gt;is_ddic_type( ).

      APPEND |Type category: { type_category_tab }| TO info.
      APPEND |Type kind: { type_kind_tab }| TO info.
      APPEND |Absolute name: { absolute_name_tab }| TO info.
      APPEND |Relative name: { relative_name_tab }| TO info.
      APPEND |Table kind: { table_kind_itab }| TO info.
      APPEND |Does table have a unique key: { COND #( WHEN table_has_unique_key_itab = abap_true THEN abap_true ELSE `-` ) }| TO info.
      APPEND |Table keys: { REDUCE string( INIT str = `` FOR &lt;key2&gt; IN table_keys_itab NEXT str = |{ str }| &amp;&amp;
             |{ COND #( WHEN str IS NOT INITIAL THEN `, ` ) }{ REDUCE string( INIT str2 = `` FOR &lt;key3&gt; IN &lt;key2&gt;-components NEXT str2 = |{ str2 }| &amp;&amp;
             |{ COND #( WHEN str2 IS NOT INITIAL THEN `/` ) }{ &lt;key3&gt;-name }| ) } (is primary: &quot;{ &lt;key2&gt;-is_primary }&quot;, |  &amp;&amp;
             |is unique: &quot;{ &lt;key2&gt;-is_unique }&quot;, key kind: &quot;{ &lt;key2&gt;-key_kind }&quot;, access kind: &quot;{ &lt;key2&gt;-access_kind }&quot;)| ) }| TO info.
      APPEND |Is DDIC type: { COND #( WHEN table_is_ddic_typw = abap_true THEN abap_true ELSE `-` ) }| TO info.
      TRY.
          DATA(table_component_info_itab) = CAST cl_abap_structdescr( tdo_tab-&gt;get_table_line_type( ) )-&gt;components.
          APPEND |Table components: { REDUCE string( INIT s = VALUE #( ) FOR w IN table_component_info_itab NEXT s &amp;&amp;= |{ COND #( WHEN s IS NOT INITIAL THEN ` ` ) }{ w-name }| ) }| TO info.
        CATCH cx_sy_move_cast_error.
          APPEND |Table components: The table has not a structured line type.| TO info.
      ENDTRY.
    ELSE.
      info = super-&gt;lif_chain_of_resp~process( type_descr ).
      IF info IS INITIAL.
        APPEND |Class { cl_name } could not handle request.| TO info.
      ELSE.
        INSERT |Class { cl_name } could not handle request.| INTO info INDEX 1.
      ENDIF.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_concrete_handler4 DEFINITION INHERITING FROM lcl_base_handler.
  PUBLIC SECTION.
    METHODS: lif_chain_of_resp~process REDEFINITION.
ENDCLASS.

CLASS lcl_concrete_handler4 IMPLEMENTATION.
  METHOD lif_chain_of_resp~process.
    DATA(cl_name) = CAST cl_abap_classdescr( cl_abap_typedescr=&gt;describe_by_object_ref( me ) )-&gt;get_relative_name( ).
    APPEND |Class { cl_name } handled request.| TO info.
    APPEND `--- Type information ---` TO info.

    IF type_descr IS INITIAL.
      APPEND `Cannot extract type information` TO info.
    ELSE.
      DATA(type_category) = type_descr-&gt;kind.
      DATA(type_kind) = type_descr-&gt;type_kind.
      DATA(absolute_name) = type_descr-&gt;absolute_name.
      DATA(relative_name) = type_descr-&gt;get_relative_name( ).

      APPEND |Type category: { type_category }| TO info.
      APPEND |Type kind: { type_kind }| TO info.
      APPEND |Absolute name: { absolute_name }| TO info.
      APPEND |Relative name: { relative_name }| TO info.
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Command</h2>
<ul>
<li>The idea behind the command design pattern is to wrap operations to be executed and the details required for the operations inside individual objects.</li>
<li>By placing all details in these command objects, you can, for example, store these objects, pass them as arguments of method calls, execute them in a specific order, or delay their execution to a later time.</li>
<li>Typically, objects invoking commands (invokers) are separated from the objects that receive the commands and finally execute the operations (receivers). Basically, invokers can execute any command without knowing the execution details defined by the receivers.</li>
<li>The pattern may be useful for creating a flexible setup that can be easily extended by adding new commands, without requiring a modification of existing classes. By storing commands, the setup can also support undo and redo functionalities.</li>
<li>A potential setup, illustrated in the following example, may look like this:</li>
<li>Command interface (or an abstract class)</li>
<li>Defines a method for executing commands.</li>
<li>The method can be defined without any input parameters to have a generic approach for various kinds of operations. The actual data to work with can be assigned to instance attributes of command objects.</li>
<li>Concrete command classes</li>
<li>These classes implement the command interface.</li>
<li>They execute the command by calling appropriate methods implemented by receiver objects, i.e. the actual operation is performed by the receivers.</li>
<li>Receiver class</li>
<li>This class contains the implementation for executing the operations defined by the commands.</li>
<li>Methods in the receiver class are called by the concrete command classes.</li>
<li>Invoker class</li>
<li>Responsible for triggering command execution.</li>
<li>Invokers are unaware of the implementation details.</li>
<li>Client</li>
<li>Creates command objects and connects them with suitable receiver objects.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example demonstrates the command design pattern at a high level using the following context:</li>
<li>Assume there is a simplified image editor app.</li>
<li>The app may offer various functionalities, such as resizing and rotating images.</li>
<li>In the app, a user edits an image by triggering resizing and rotation - each operation represents an individual command object - by providing specific values, such as width and height to resize the image.</li>
<li>Additionally, the app supports undo and redo functionality.</li>
<li>The code demonstrates the design pattern with the following declarations and implementations:</li>
<li>CCIMP Include (<em>Local Types</em> Tab in ADT):</li>
<li>Command interface <code>lif_command</code></li>
<li>Defines a method for executing commands (<code>execute</code>) and a method for reverting executed commands (<code>undo</code>).</li>
<li>Receiver class <code>lcl_receiver</code></li>
<li>Executes commands by implementing specific methods. In the image editor example, it includes methods like <code>resize</code> and <code>rotate</code> to edit images and change object states based on commands.</li>
<li>The instance constructor initializes the image&#x27;s values, which are provided during object creation for simplicity.</li>
<li>The <code>get_current_state</code> method is implemented for logging and display purposes.</li>
<li>Concrete command classes <code>lcl_cmd_resize</code> and <code>lcl_cmd_rotate</code></li>
<li>Implement the command interface.</li>
<li>Objects of these classes represent specific commands.</li>
<li>Each object of the classes holds a reference to the receiver (stored in the <code>rec</code> attribute), passed via the constructor. Details of the command are stored in instance attributes (<code>wd</code>, <code>ht</code>, <code>ang</code>), which the operation uses for execution.</li>
<li>The <code>execute</code> method calls appropriate methods through the receiver objects.</li>
<li>The <code>undo</code> method reverts changes by storing previous values in instance attributes during the <code>execute</code> method.</li>
<li>Invoker class <code>lcl_invoker</code></li>
<li>Executes commands through the <code>exec_cmd</code> method.</li>
<li>In this example, the command object is passed as an argument to the instance constructor.</li>
<li>It includes internal tables that hold references for undo and redo operations (<code>undo_tab</code> and <code>redo_tab</code>). When executing a command via <code>exec_cmd</code>, a reference is added to <code>undo_tab</code>, and <code>redo_tab</code> is cleared. The <code>redo</code> method executes the last command from <code>redo_tab</code> and adds it to <code>undo_tab</code>.</li>
<li>Global class</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Acts as the client.</li>
<li>Creates objects of the receiver, invoker, and commands.</li>
<li>Command objects are created with references to the receiver and the necessary execution details.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
    CLASS-DATA log TYPE string_table.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;---------------------------------------------------------------------*
*&amp; Creating receiver, invoker and command objects and triggering
*&amp; the execution of commands
*&amp;---------------------------------------------------------------------*

    &quot;Creating an object of the receiver class representing a
    &quot;simplified image editor app
    &quot;Here, start values for the image are supplied, which are
    &quot;reflected in the current state that is retrieved.
    DATA(receiver) = NEW lcl_receiver( width = 800 height = 600 ).

    &quot;For logging and display purposes, the current state of the
    &quot;image is retrieved. The current state is retrieved and output
    &quot;after each operation in the example.
    DATA(state) = receiver-&gt;get_current_state( ).
    out-&gt;write( state ).

    &quot;Creating an object of the invoker class
    DATA(invoker) = NEW lcl_invoker( ).

    &quot;Creating concrete commands by linking them to the receiver
    &quot;In the example, a reference of the receiver class is passed as
    &quot;argument of the instance constructor.

    &quot;Resizing operation (1)
    &quot;Here and in all other concrete command creations, values are
    &quot;passed representing new values that should be applied for the
    &quot;operation.

    DATA(cmd1) = NEW lcl_cmd_resize( receiver = receiver width = 1024 height = 768 ).

    &quot;Passing the command object to the invoker that takes care of
    &quot;executing the command. However, the invoker does not know about
    &quot;the concrete details of the operation.
    invoker-&gt;exec_cmd( cmd1 ).

    state = receiver-&gt;get_current_state( ).
    out-&gt;write( state ).

    &quot;Resizing operation (2)
    DATA(cmd2) = NEW lcl_cmd_resize( receiver = receiver width = 1920 height = 1080 ).
    invoker-&gt;exec_cmd( cmd2 ).

    state = receiver-&gt;get_current_state( ).
    out-&gt;write( state ).

    &quot;Rotating operation (1)
    DATA(cmd3) = NEW lcl_cmd_rotate( receiver = receiver angle = 20 ).
    invoker-&gt;exec_cmd( cmd3 ).

    state = receiver-&gt;get_current_state( ).
    out-&gt;write( state ).

    &quot;Rotating operation (2)
    DATA(cmd4) = NEW lcl_cmd_rotate( receiver = receiver angle = 45 ).
    invoker-&gt;exec_cmd( cmd4 ).

    state = receiver-&gt;get_current_state( ).
    out-&gt;write( state ).

    &quot;Resizing operation (3)
    DATA(cmd5) = NEW lcl_cmd_resize( receiver = receiver width = 1280  height = 720  ).
    invoker-&gt;exec_cmd( cmd5 ).

    state = receiver-&gt;get_current_state( ).
    out-&gt;write( state ).

    &quot;Rotating operation (3)
    DATA(cmd6) = NEW lcl_cmd_rotate( receiver = receiver angle = 180 ).
    invoker-&gt;exec_cmd( cmd6 ).

    state = receiver-&gt;get_current_state( ).
    out-&gt;write( state ).

*&amp;---------------------------------------------------------------------*
*&amp; Undo operations
*&amp;---------------------------------------------------------------------*

    out-&gt;write( |\n{ repeat( val = `*` occ = 70 ) }\n| ).
    out-&gt;write( `********* Undo operations *********` ).

    DO 3 TIMES.
      invoker-&gt;undo( ).

      state = receiver-&gt;get_current_state( ).
      out-&gt;write( state ).
    ENDDO.

*&amp;---------------------------------------------------------------------*
*&amp; Redo operations
*&amp;---------------------------------------------------------------------*

    out-&gt;write( |\n{ repeat( val = `*` occ = 70 ) }\n| ).
    out-&gt;write( `********* Redo operations *********` ).

    DO 5 TIMES.
      invoker-&gt;redo( ).

      state = receiver-&gt;get_current_state( ).
      out-&gt;write( state ).
    ENDDO.

*&amp;---------------------------------------------------------------------*
*&amp; Log
*&amp;---------------------------------------------------------------------*

    out-&gt;write( |\n{ repeat( val = `*` occ = 70 ) }\n| ).
    out-&gt;write( `********* Log *********` ).
    out-&gt;write( log ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Command interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_command.
  METHODS: execute,
    undo.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Receiver class
*&amp;---------------------------------------------------------------------*

CLASS lcl_receiver DEFINITION.
  PUBLIC SECTION.
    DATA: wd  TYPE i,
          ht  TYPE i,
          ang TYPE i.

    METHODS:
      constructor IMPORTING width TYPE i height TYPE i,
      resize IMPORTING width TYPE i height TYPE i,
      rotate IMPORTING angle TYPE i,
      get_current_state RETURNING VALUE(state) TYPE string.
ENDCLASS.

CLASS lcl_receiver IMPLEMENTATION.
  METHOD constructor.
    wd  = width.
    ht = height.
    ang  = 0.
  ENDMETHOD.

  METHOD resize.
    wd  = width.
    ht = height.

    APPEND |New image size: { wd }x{ ht }| TO zcl_demo_abap=&gt;log.
  ENDMETHOD.

  METHOD rotate.
    ang = ( ang + angle ) MOD 360.

    APPEND |Image rotated to { ang } (angle used: { angle })| TO zcl_demo_abap=&gt;log.
  ENDMETHOD.

  METHOD get_current_state.
    state = |Current image state: { wd }x{ ht }, angle { ang } |.
    APPEND state TO zcl_demo_abap=&gt;log.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete command classes
*&amp;---------------------------------------------------------------------*

CLASS lcl_cmd_resize DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_command.
    METHODS: constructor IMPORTING receiver TYPE REF TO object
                                   width    TYPE i
                                   height   TYPE i.
  PRIVATE SECTION.
    DATA: rec             TYPE REF TO object,
          wd              TYPE i,
          ht              TYPE i,
          previous_width  TYPE i,
          previous_height TYPE i.
ENDCLASS.

CLASS lcl_cmd_resize IMPLEMENTATION.
  METHOD constructor.
    rec = receiver.
    wd  = width.
    ht = height.
  ENDMETHOD.

  METHOD lif_command~execute.
    IF rec IS BOUND AND rec IS INSTANCE OF lcl_receiver.
      DATA(img) = CAST lcl_receiver( rec ).
      previous_width  = img-&gt;wd.
      previous_height = img-&gt;ht.
      img-&gt;resize( width = wd height = ht ).
    ENDIF.
  ENDMETHOD.

  METHOD lif_command~undo.
    IF rec IS BOUND AND rec IS INSTANCE OF lcl_receiver.
      DATA(img) = CAST lcl_receiver( rec ).
      DATA(current_wd) = img-&gt;wd.
      DATA(current_ht) = img-&gt;ht.
      img-&gt;resize( width = previous_width height = previous_height ).
      APPEND |Resizing undone: { previous_width }x{ previous_height } (previous value: { current_wd }x{ current_ht })| TO zcl_demo_abap=&gt;log.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_cmd_rotate DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_command.
    METHODS: constructor IMPORTING receiver TYPE REF TO object
                                   angle    TYPE i.
  PRIVATE SECTION.
    DATA: rec            TYPE REF TO object,
          ang            TYPE i,
          previous_angle TYPE i.
ENDCLASS.

CLASS lcl_cmd_rotate IMPLEMENTATION.
  METHOD constructor.
    rec = receiver.
    ang = angle.
  ENDMETHOD.

  METHOD lif_command~execute.
    IF rec IS BOUND AND rec IS INSTANCE OF lcl_receiver.
      DATA(img) = CAST lcl_receiver( rec ).
      previous_angle = img-&gt;ang.
      img-&gt;rotate( angle = ang ).
    ENDIF.
  ENDMETHOD.

  METHOD lif_command~undo.
    IF rec IS BOUND AND rec IS INSTANCE OF lcl_receiver.
      DATA(img) = CAST lcl_receiver( rec ).
      DATA(current_value) = img-&gt;ang.
      img-&gt;ang = previous_angle.
      APPEND |Rotation undone: { previous_angle } (previous value: { current_value })| TO zcl_demo_abap=&gt;log.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Invoker classes
*&amp;---------------------------------------------------------------------*

CLASS lcl_invoker DEFINITION.
  PUBLIC SECTION.
    METHODS:
      exec_cmd IMPORTING cmd TYPE REF TO lif_command,
      undo,
      redo.
  PRIVATE SECTION.
    DATA: undo_tab TYPE TABLE OF REF TO lif_command WITH EMPTY KEY,
          redo_tab TYPE TABLE OF REF TO lif_command WITH EMPTY KEY.
ENDCLASS.

CLASS lcl_invoker IMPLEMENTATION.
  METHOD exec_cmd.
    APPEND `---` TO zcl_demo_abap=&gt;log.
    IF cmd IS BOUND.
      cmd-&gt;execute( ).
      APPEND cmd TO undo_tab.
      CLEAR redo_tab.
    ELSE.
      RETURN.
    ENDIF.
  ENDMETHOD.

  METHOD undo.
    APPEND `---` TO zcl_demo_abap=&gt;log.
    APPEND `Undo operation triggered` TO zcl_demo_abap=&gt;log.
    DATA(tabix) = lines( undo_tab ).
    READ TABLE undo_tab INTO DATA(cmd) INDEX tabix.
    IF sy-subrc = 0.
      cmd-&gt;undo( ).
      DELETE undo_tab INDEX tabix.
      APPEND cmd TO redo_tab.
    ELSE.
      APPEND `Undo operation not possible` TO zcl_demo_abap=&gt;log.
    ENDIF.
  ENDMETHOD.

  METHOD redo.
    APPEND `---` TO zcl_demo_abap=&gt;log.
    APPEND `Redo operation triggered` TO zcl_demo_abap=&gt;log.
    DATA(tabix) = lines( redo_tab ).
    READ TABLE redo_tab INTO DATA(cmd) INDEX tabix.
    IF sy-subrc = 0.
      cmd-&gt;execute( ).
      DELETE redo_tab INDEX tabix.
      APPEND cmd TO undo_tab.
    ELSE.
      APPEND `Redo operation not possible` TO zcl_demo_abap=&gt;log.
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Composite</h2>
<ul>
<li>The composite design pattern may be useful when you need to work with objects that form hierarchical, tree-like structures.</li>
<li>The composite refers to a component that can contain subordinate components in the tree-like structure. Subordinate components can be <em>leaves</em> (individual components without subordinate components) or other composites (that can have further subordinates).</li>
<li>Addressing a composite typically means addressing its subordinate objects as well. In terms of coding, when a method is called on a composite object, it delegates processing to its subordinate objects. If a subordinate object has its own subordinates, the operation is further delegated. This approach allows operations to be performed across the entire object hierarchy, on individual composites (including their subordinates), or on single leaf objects.</li>
<li>This setup enables clients to uniformly address objects within the hierarchy, typically through a common interface implemented by all components. It also allows for flexible extension by adding composites and leaves without affecting existing code.</li>
<li>A potential setup, illustrated in the following example, may look like this:</li>
<li>A component interface that defines common operations shared by all implementing classes.</li>
<li>A leaf class that implements the component interface and whose objects represent individual objects without subordinates.</li>
<li>A composite class whose objects represent more complex objects, consisting of subordinate objects, which may be leaves or other composites, forming the tree-like structure. Like leaf classes, composite classes implement the component interface, typically delegating processing to subordinate objects to, for example, combine results.</li>
<li>With the common interface, clients can uniformly address the objects, no matter if interacting with the entire hierarchy, composites, or individual leaf objects. Clients need not be aware of dealing with a composite or leaf object.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>This example tries to illustrate the composite design pattern using an organizational hierarchy with managers and employees as demo context.</li>
<li>The example code demonstrates the composite design pattern by including the following declarations and implementations:</li>
<li>CCIMP include (<em>Local Types</em> tab in ADT):</li>
<li><code>lif_org</code></li>
<li>Represents the component interface that defines operations for both leaf nodes (individual employees) and composite nodes (managers with subordinates).</li>
<li>Among the operations are:</li>
<li><code>get_salary</code>: Returns the individual or total salary (for leaf nodes, the value is the same; for composite nodes, it adds the manager&#x27;s salary to the salaries of subordinates).</li>
<li><code>get_headcount</code>: Returns the count of individual members (for leaf nodes, the count is 1; for composite nodes, it is 1 plus the count of all subordinates).</li>
<li><code>get_employee_hierarchy</code>: Returns the organizational structure as a string table with proper indentation.</li>
<li><code>get_data</code>: Returns employee data.</li>
<li><code>set_manager</code>/<code>get_manager</code>: Sets or gets the reference to the manager node.</li>
<li><code>get_employees_by_role</code>: Returns employees filtered by job role.</li>
<li><code>get_employees_by_office</code>: Returns employees filtered by office location.</li>
<li><code>get_employee_info</code>: Returns JSON with employee information and reporting line.</li>
<li><code>assign_training</code>: Assigns training.</li>
<li>The type <code>ty_employee_data</code> defines the structure for employee information. The <code>tt_org</code> table type is used to collect organization members.</li>
<li><code>lcl_employee</code></li>
<li>Represents the leaf class and implements the component interface.</li>
<li>Objects of this class represent individual employees in the organizational hierarchy who have no subordinates.</li>
<li>They store employee information (<code>employee_data</code>) and a reference to the manager (<code>mngr</code>) as instance attributes.</li>
<li><code>lcl_manager</code></li>
<li>Represents the composite class for managers who can have subordinates.</li>
<li>Objects of this class represent managers in the organizational hierarchy who can have both kinds of subordinates, employees and other managers.</li>
<li>Like objects of the <code>lcl_employee</code> class, objects of <code>lcl_manager</code> store employee information (of the manager, who is also an employee) and a reference to their manager (a higher-level manager).</li>
<li>Because composites can have subordinates, the <code>subordinates_tab</code> table holds references to those subordinates.</li>
<li>In addition to the shared interface methods, there are composite-specific methods:</li>
<li><code>add_subordinate</code>: Adds an employee or manager as a subordinate and establishes the manager reference.</li>
<li><code>remove_subordinate</code>: Removes a component from the subordinates.</li>
<li><code>get_subordinates</code>: Returns all direct subordinates.</li>
<li>Further notes on the example:</li>
<li>The client can uniformly interact with the entire organization, departments (represented by heads of department managers), sub-managers, or individual employees due to the common interface.</li>
<li>Several methods reflect the composite design pattern by implementing recursive method calls. For example, they accumulate headcount and salary numbers across the hierarchy, build the hierarchy visualization recursively, filter employees recursively, and assign training recursively.</li>
<li>Most example method implementations reflect moving down the hierarchy. Since both leaf and composite objects maintain references to their managers, the example also includes a sample implementation for moving up the hierarchy. The information returned by the <code>get_employee_info</code> method, formatted in JSON, includes details about the reporting line.</li>
<li>The <code>remove_subordinate</code> method removes a component from the subordinates. The example implementation specifies that if a manager (a composite) is removed, their subordinates are reassigned to the next higher-level manager.</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as the client in the example. Here, the client creates and manages the hierarchy.</li>
<li>Individual objects are created for both managers as composites and employees as leaf nodes. Each object is instantiated with specific employee data (ID, name, job role, salary, office). The hierarchical structure is established using the <code>add_subordinate</code> method to build the organization tree. The CEO represents the root node, with department heads as subordinates, each of whom may have further subordinates.</li>
<li>The example implementation demonstrates the following operations:</li>
<li>Retrieving the employee hierarchy for the entire organization and specific departments.</li>
<li>Retrieving employees by role and office for the entire organization and specific departments.</li>
<li>Assigning trainings to all employees, to all employees of a specific department, or to a single employee.</li>
<li>Retrieving employee information as JSON, including the reporting line.</li>
<li>Retrieving headcount and salary information for the entire organization, specific departments, and a specific employee.</li>
<li>Removing subordinates, which is only possible for managers within their downward reporting line. After removal, the entire organization hierarchy and headcount is retrieved and displayed to demonstrate successful removal and, if a manager (a composite) was removed, the reassignment of subordinates.</li>
<li>Throughout the implementation, the example demonstrates that the client can uniformly interact with the hierarchy by calling the same methods. Depending on the operation, it can be performed on the entire organization (starting with the CEO), the engineering department (starting with the head of engineering), the sales department (starting with the head of sales), and so on.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA example_number TYPE i.
    METHODS set_example_divider IMPORTING out  TYPE REF TO if_oo_adt_classrun_out
                                          text TYPE string.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;---------------------------------------------------------------------*
*&amp; Creating members of the organization and setting up the
*&amp; organizational hierarchy
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Creating members of the organization and setting up the organizational hierarchy| ).

    &quot;The CEO object represents to the root node of the organizational hierarchy
    DATA(ceo) = NEW lcl_manager( is_data = VALUE #( id = 1 name = `Jasmin` job_role = `CEO` salary = 350000 office = `New York` ) ).
    DATA(hr_specialist) = NEW lcl_employee( is_data = VALUE #( id = 2 name = `Grace` job_role = `HR Specialist` salary = 85000 office = `New York` ) ).
    DATA(admin_assistant1) = NEW lcl_employee( is_data = VALUE #( id = 3 name = `Kim` job_role = `Administrative Assistant` salary = 85000 office = `New York` ) ).

    &quot;Engineering department
    DATA(head_eng) = NEW lcl_manager( is_data = VALUE #( id = 4 name = `Michael` job_role = `Head of Engineering` salary = 220000 office = `San Francisco` ) ).
    DATA(admin_assistant2) = NEW lcl_employee( is_data = VALUE #( id = 5 name = `Matthew` job_role = `Administrative Assistant` salary = 85000 office = `New York` ) ).
    DATA(dev_manager) = NEW lcl_manager( is_data = VALUE #( id = 6 name = `Liam` job_role = `Development Manager` salary = 180000 office = `Berlin` ) ).
    DATA(dev1) = NEW lcl_employee( is_data = VALUE #( id = 7 name = `Ava` job_role = `Developer` salary = 130000 office = `Shanghai` ) ).
    DATA(dev2) = NEW lcl_employee( is_data = VALUE #( id = 8 name = `James` job_role = `Developer` salary = 120000 office = `Sydney` ) ).
    DATA(dev3) = NEW lcl_employee( is_data = VALUE #( id = 9 name = `Charlotte` job_role = `Developer` salary = 115000 office = `Cape Town` ) ).
    DATA(qa_manager) = NEW lcl_manager( is_data = VALUE #( id = 10 name = `Sophia` job_role = `QA Manager` salary = 170000 office = `Tokyo` ) ).
    DATA(qa_tester) = NEW lcl_employee( is_data = VALUE #( id = 11 name = `Isabella` job_role = `QA Tester` salary = 95000 office = `Buenos Aires` ) ).
    DATA(qa_automation) = NEW lcl_employee( is_data = VALUE #( id = 12 name = `William` job_role = `QA Automation Engineer` salary = 110000 office = `Toronto` ) ).

    &quot;Sales department
    DATA(head_sales) = NEW lcl_manager( is_data = VALUE #( id = 13 name = `Olivia` job_role = `Head of Sales` salary = 210000 office = `London` ) ).
    DATA(sales_rep1) = NEW lcl_employee( is_data = VALUE #( id = 14 name = `Mia` job_role = `Sales Representative` salary = 90000 office = `Paris` ) ).
    DATA(sales_rep2) = NEW lcl_employee( is_data = VALUE #( id = 15 name = `Lucas` job_role = `Sales Representative` salary = 88000 office = `Dubai` ) ).
    DATA(sales_analyst) = NEW lcl_employee( is_data = VALUE #( id = 16 name = `Amelia` job_role = `Sales Analyst` salary = 95000 office = `Mumbai` ) ).

    &quot;Building the hierarchy using the add_subordinate method,
    &quot;reflecting the various hierarchies and reporting lines.
    &quot;The add_subordinate method also establishes a reference
    &quot;to the manager. To display the hierarchy in a meaningful
    &quot;sequence (since the add_subordinate method just appends
    &quot;lines to a table with a reference type, without further
    &quot;sorting or ordering implementation for simplification),
    &quot;the organization`s members are added in a specific order
    &quot;for display purposes.
    ceo-&gt;add_subordinate( hr_specialist ).
    ceo-&gt;add_subordinate( admin_assistant1 ).

    ceo-&gt;add_subordinate( head_eng ).
    head_eng-&gt;add_subordinate( admin_assistant2 ).
    head_eng-&gt;add_subordinate( dev_manager ).

    dev_manager-&gt;add_subordinate( dev1 ).
    dev_manager-&gt;add_subordinate( dev2 ).
    dev_manager-&gt;add_subordinate( dev3 ).

    head_eng-&gt;add_subordinate( qa_manager ).
    qa_manager-&gt;add_subordinate( qa_tester ).
    qa_manager-&gt;add_subordinate( qa_automation ).

    ceo-&gt;add_subordinate( head_sales ).
    head_sales-&gt;add_subordinate( sales_rep1 ).
    head_sales-&gt;add_subordinate( sales_rep2 ).
    head_sales-&gt;add_subordinate( sales_analyst ).

    &quot;Retrieving and displaying the employee hierarchy of
    &quot;the entire organization
    out-&gt;write( |Hierarchy of the entire organization:\n\n| ).
    DATA(org) = ceo-&gt;lif_org~get_employee_hierarchy( ).
    out-&gt;write( org ).
    out-&gt;write( |\n| ).

    out-&gt;write( |Hierarchy of the engineering department:\n\n| ).
    DATA(org_eng_dep) = head_eng-&gt;lif_org~get_employee_hierarchy( ).
    out-&gt;write( org_eng_dep ).
    out-&gt;write( |\n| ).

    out-&gt;write( |Hierarchy of the sales department:\n\n| ).
    DATA(org_sales_dep) = head_sales-&gt;lif_org~get_employee_hierarchy( ).
    out-&gt;write( org_sales_dep ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Retrieving employees by role
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Retrieving employees by role| ).

    &quot;Developers in the entire organization
    DATA(role) = `Developer`.
    DATA(devs_in_org) = ceo-&gt;lif_org~get_employees_by_role( role ).
    DATA(count) = lines( devs_in_org ).
    out-&gt;write( |There { COND #( WHEN count = 1 THEN `is` ELSE `are` ) } { count } { to_lower( role ) }{ COND #( WHEN count &lt;&gt; 1 THEN `s` ) } in the entire organization:| ).
    LOOP AT devs_in_org INTO DATA(dev).
      out-&gt;write( |- { dev-&gt;get_data( )-name }| ).
    ENDLOOP.
    out-&gt;write( |\n| ).

    &quot;Administrative assistants in the engineering department
    role = `Administrative Assistant`.
    DATA(admin_in_eng_dep) = head_eng-&gt;lif_org~get_employees_by_role( role ).
    count = lines( admin_in_eng_dep ).
    out-&gt;write( |There { COND #( WHEN count = 1 THEN `is` ELSE `are` ) } { count } { to_lower( role ) }{ COND #( WHEN count &lt;&gt; 1 THEN `s` ) } in the engineering department:| ).
    LOOP AT admin_in_eng_dep INTO DATA(adm).
      out-&gt;write( |- { adm-&gt;get_data( )-name }| ).
    ENDLOOP.
    out-&gt;write( |\n| ).

    role = `Sales Representative`.
    DATA(sales_reps_in_eng_dep) = head_eng-&gt;lif_org~get_employees_by_role( role ).
    count = lines( sales_reps_in_eng_dep ).
    out-&gt;write( |There { COND #( WHEN count = 1 THEN `is` ELSE `are` ) } { count } { to_lower( role ) }{ COND #( WHEN count &lt;&gt; 1 THEN `s` ) } in the engineering department.| ).
    LOOP AT sales_reps_in_eng_dep INTO DATA(sales_rep).
      out-&gt;write( |- { sales_rep-&gt;get_data( )-name }| ).
    ENDLOOP.
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Retrieving employees by office
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Retrieving employees by office| ).

    DATA(office) = `New York`.
    DATA(org_ny_location) = ceo-&gt;lif_org~get_employees_by_office( office ).
    count = lines( org_ny_location ).
    out-&gt;write( |There { COND #( WHEN count = 1 THEN `is` ELSE `are` ) } { count } member{ COND #( WHEN count &lt;&gt; 1 THEN `s` ) } in the organization located in the { office } office:| ).
    LOOP AT org_ny_location INTO DATA(ny).
      out-&gt;write( |- { ny-&gt;get_data( )-name }| ).
    ENDLOOP.
    out-&gt;write( |\n| ).

    DATA(eng_dep_ny_location) = head_eng-&gt;lif_org~get_employees_by_office( office ).
    count = lines( eng_dep_ny_location ).
    out-&gt;write( |There { COND #( WHEN count = 1 THEN `is` ELSE `are` ) } { count } member{ COND #( WHEN count &lt;&gt; 1 THEN `s` ) } in the engineering department located in the { office } office:| ).
    LOOP AT eng_dep_ny_location INTO DATA(ny_eng).
      out-&gt;write( |- { ny_eng-&gt;get_data( )-name }| ).
    ENDLOOP.
    out-&gt;write( |\n| ).

    DATA(sales_dep_ny_location) = head_sales-&gt;lif_org~get_employees_by_office( office ).
    count = lines( sales_dep_ny_location ).
    out-&gt;write( |There { COND #( WHEN count = 1 THEN `is` ELSE `are` ) } { count } member{ COND #( WHEN count &lt;&gt; 1 THEN `s` ) } in the sales department located in the { office } office.| ).
    LOOP AT sales_dep_ny_location INTO DATA(ny_sales).
      out-&gt;write( |- { ny_sales-&gt;get_data( )-name }| ).
    ENDLOOP.
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Assigning training
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Assigning training| ).

    &quot;Assigning training to all members of the organization
    out-&gt;write( `Training A` ).
    DATA(trainings_assigned) = ceo-&gt;lif_org~assign_training( `Training A` ).
    out-&gt;write( trainings_assigned ).
    out-&gt;write( |\n| ).

    &quot;Assigning training to all members of the engineering department
    out-&gt;write( `Training B` ).
    trainings_assigned = head_eng-&gt;lif_org~assign_training( `Training B` ).
    out-&gt;write( trainings_assigned ).
    out-&gt;write( |\n| ).

    &quot;Assigning training to a specific member
    out-&gt;write( `Training C` ).
    trainings_assigned = qa_tester-&gt;lif_org~assign_training( `Training C` ).
    out-&gt;write( trainings_assigned ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Retrieving employee information as JSON (inluding reporting line)
*&amp;---------------------------------------------------------------------*

    &quot;The example is designed in a way that the ID must refer to a subordinate
    &quot;of the reference used. The example implementation does not, for example,
    &quot;work for ID 12 via the head_sales reference.

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Retrieving employee information as JSON (inluding reporting line)| ).

    out-&gt;write( `Retrieving information about member with ID 3 in the hierarchy via the ceo reference` ).
    out-&gt;write( |\n| ).
    DATA(json_id_3) = ceo-&gt;lif_org~get_employee_info( 3 ).
    out-&gt;write( json_id_3 ).
    out-&gt;write( |\n| ).

    out-&gt;write( `Retrieving information about member with ID 16 in the hierarchy via the head_sales reference` ).
    out-&gt;write( |\n| ).
    DATA(json_id_16) = head_sales-&gt;lif_org~get_employee_info( 16 ).
    out-&gt;write( json_id_16 ).
    out-&gt;write( |\n| ).

    out-&gt;write( `Retrieving information about member with ID 12 in the hierarchy via the qa_manager reference` ).
    out-&gt;write( |\n| ).
    DATA(json_id_12a) = qa_manager-&gt;lif_org~get_employee_info( 12 ).
    out-&gt;write( json_id_12a ).
    out-&gt;write( |\n| ).

    out-&gt;write( `Retrieving information about member with ID 12 in the hierarchy via the head_eng reference` ).
    out-&gt;write( |\n| ).
    DATA(json_id_12b) = head_eng-&gt;lif_org~get_employee_info( 12 ).
    out-&gt;write( json_id_12b ).
    out-&gt;write( |\n| ).

    out-&gt;write( `Retrieving information about member with ID 12 in the hierarchy via the ceo reference` ).
    out-&gt;write( |\n| ).
    DATA(json_id_12c) = ceo-&gt;lif_org~get_employee_info( 12 ).
    out-&gt;write( json_id_12c ).
    out-&gt;write( |\n| ).

    out-&gt;write( `No direct managers in case of ID 1 (the root node)` ).
    out-&gt;write( |\n| ).
    DATA(json_id_1) = ceo-&gt;lif_org~get_employee_info( 1 ).
    out-&gt;write( json_id_1 ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Retrieving headcount
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Retrieving headcount| ).

    &quot;Total headcount retrieved via the root node
    DATA(headcount) = ceo-&gt;lif_org~get_headcount( ).
    out-&gt;write( |Total headcount of the entire organization: { headcount }\n| ).

    &quot;Headcount of engineering department
    headcount = head_eng-&gt;lif_org~get_headcount( ).
    out-&gt;write( |Engineering department headcount: { headcount }\n| ).

    &quot;Headcount of sales department
    headcount = head_sales-&gt;lif_org~get_headcount( ).
    out-&gt;write( |Sales department headcount: { headcount }\n| ).

    &quot;Headcount of a specific member that has no subordinates
    headcount = dev1-&gt;lif_org~get_headcount( ).
    out-&gt;write( |Headcount of a specific member: { headcount }\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Retrieving salary
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Retrieving salary| ).

    &quot;Salary of the CEO + the entire organization
    ceo-&gt;lif_org~get_salary( IMPORTING individual_salary  = DATA(ind_salary)
                                       accumulated_salary = DATA(acc_salary) ).

    out-&gt;write( |Individual salary of the CEO: { ind_salary }| ).
    out-&gt;write( |Total salary of the entire organization: { acc_salary }\n| ).

    &quot;Salary of the engineering department head + the entire engineering department
    head_eng-&gt;lif_org~get_salary( IMPORTING individual_salary  = ind_salary
                                            accumulated_salary = acc_salary ).

    out-&gt;write( |Individual salary of the engineering department head: { ind_salary }| ).
    out-&gt;write( |Total salary of the entire engineering department: { acc_salary }\n| ).

    &quot;Salary of the sales department head + the entire sales department
    head_sales-&gt;lif_org~get_salary( IMPORTING individual_salary  = ind_salary
                                              accumulated_salary = acc_salary ).

    out-&gt;write( |Individual salary of the sales department head: { ind_salary }| ).
    out-&gt;write( |Total salary of the entire sales department: { acc_salary }\n| ).

    &quot;Salary of a specific member
    dev1-&gt;lif_org~get_salary( IMPORTING individual_salary  = ind_salary
                                        accumulated_salary = acc_salary ).

    out-&gt;write( |Individual salary of a specific member: { ind_salary }| ).
    out-&gt;write( |Total salary of a specific member (no subordinates): { acc_salary }\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Removing subordinates
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Removing subordinates| ).

    &quot;A composite trying to remove itself is ruled out.
    ceo-&gt;remove_subordinate( ceo  ).
    DATA(org_test1) = ceo-&gt;lif_org~get_employee_hierarchy( ).
    DATA(hc1) = ceo-&gt;lif_org~get_headcount( ).

    &quot;A composite trying to remove itself is ruled out.
    dev_manager-&gt;remove_subordinate( dev_manager  ).
    DATA(org_test2) = ceo-&gt;lif_org~get_employee_hierarchy( ).
    DATA(hc2) = ceo-&gt;lif_org~get_headcount( ).
    ASSERT org_test2 = org_test1.
    ASSERT hc2 = hc1.

    &quot;A manager (composite) trying to remove an employee (leaf) that is not
    &quot;a subordinate is ruled out.
    dev_manager-&gt;remove_subordinate( admin_assistant1 ).
    DATA(org_test3) = ceo-&gt;lif_org~get_employee_hierarchy( ).
    DATA(hc3) = ceo-&gt;lif_org~get_headcount( ).
    ASSERT hc3 = hc1.
    ASSERT org_test3 = org_test1.

    &quot;Removal example 1
    &quot;The removal is performed via the ceo reference (the root node).
    out-&gt;write( |--------------- Removing member with ID 2 ---------------\n| ).
    ceo-&gt;remove_subordinate( hr_specialist  ).
    out-&gt;write( |New total headcount: { ceo-&gt;lif_org~get_headcount( ) }\n| ).
    out-&gt;write( `New hierarchy:` ).
    org = ceo-&gt;lif_org~get_employee_hierarchy( ).
    out-&gt;write( org ).
    out-&gt;write( |\n| ).

    &quot;Removal example 2
    &quot;The removal is performed via the head_sales reference.
    out-&gt;write( |--------------- Removing member with ID 15 ---------------\n| ).
    head_sales-&gt;remove_subordinate( sales_rep2 ).
    out-&gt;write( |New total headcount: { ceo-&gt;lif_org~get_headcount( ) }\n| ).
    out-&gt;write( `New hierarchy:` ).
    org = ceo-&gt;lif_org~get_employee_hierarchy( ).
    out-&gt;write( org ).
    out-&gt;write( |\n| ).

    &quot;Removal example 3
    &quot;The removal is performed via the ceo reference (the root node). In this
    &quot;example, a composite is removed. The example is implemented in a way that
    &quot;the subordinate members arere assigned to the manager of the deleted manager.
    out-&gt;write( |--------------- Removing member with ID 10 ---------------\n| ).
    ceo-&gt;remove_subordinate( qa_manager ).
    out-&gt;write( |New total headcount: { ceo-&gt;lif_org~get_headcount( ) }\n| ).
    out-&gt;write( `New hierarchy:` ).
    org = ceo-&gt;lif_org~get_employee_hierarchy( ).
    out-&gt;write( org ).
    out-&gt;write( |\n| ).

    &quot;Removal example 4
    &quot;The removal is performed via the ceo reference (the root node). In this example,
    &quot;another composite is removed.
    out-&gt;write( |--------------- Removing member with ID 13 ---------------\n| ).
    ceo-&gt;remove_subordinate( head_sales ).
    out-&gt;write( |New total headcount: { ceo-&gt;lif_org~get_headcount( ) }\n| ).
    out-&gt;write( `New hierarchy:` ).
    org = ceo-&gt;lif_org~get_employee_hierarchy( ).
    out-&gt;write( org ).
    out-&gt;write( |\n| ).

    &quot;Removal example 5
    &quot;The removal is performed via the ceo reference (the root node). In this example,
    &quot;another composite is removed.
    out-&gt;write( |--------------- Removing member with ID 4 ---------------\n| ).
    ceo-&gt;remove_subordinate( head_eng ).
    out-&gt;write( |New total headcount: { ceo-&gt;lif_org~get_headcount( ) }\n| ).
    out-&gt;write( `New hierarchy:` ).
    org = ceo-&gt;lif_org~get_employee_hierarchy( ).
    out-&gt;write( org ).
    out-&gt;write( |\n| ).
  ENDMETHOD.

  METHOD set_example_divider.
    out-&gt;write( |*&amp;{ repeat( val = `-` occ = 70 ) }*| ).
    out-&gt;write( |*&amp; Example { text }| ).
    out-&gt;write( |*&amp;{ repeat( val = `-` occ = 70 ) }*| ).
    out-&gt;write( |\n| ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Component interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_org.

  &quot;Type for information about individual organization members
  TYPES: BEGIN OF ty_employee_data,
           id       TYPE i,
           name     TYPE string,
           job_role TYPE string,
           office   TYPE string,
           salary   TYPE i,
         END OF ty_employee_data,
         tt_org TYPE TABLE OF REF TO lif_org WITH EMPTY KEY.

  &quot;Returns salary of individual members and combined
  &quot;salary of manager and subordinates
  METHODS get_salary
    EXPORTING individual_salary  TYPE i
              accumulated_salary TYPE i.

  &quot;Returns headcount of individual members or combined
  &quot;headcount of manager and subordinates
  METHODS get_headcount
    RETURNING VALUE(count) TYPE i.

  &quot;Returns the organizational hierarchy
  METHODS get_employee_hierarchy
    IMPORTING level                   TYPE i DEFAULT 0
    RETURNING VALUE(employee_details) TYPE string_table.

  &quot;Returns employee data
  METHODS get_data
    RETURNING VALUE(data) TYPE ty_employee_data.

  &quot;Sets the manager
  METHODS set_manager
    IMPORTING manager TYPE REF TO lif_org.

  &quot;Returns the manager
  METHODS get_manager
    RETURNING VALUE(manager) TYPE REF TO lif_org.

  &quot;Returns employees filtered by role
  METHODS get_employees_by_role
    IMPORTING role             TYPE string
    RETURNING VALUE(employees) TYPE tt_org.

  &quot;Returns employees filtered by office
  METHODS get_employees_by_office
    IMPORTING office           TYPE string
    RETURNING VALUE(employees) TYPE tt_org.

  &quot;Returns information about specific members as JSON,
  &quot;including the reporting line
  METHODS get_employee_info
    IMPORTING employee_id TYPE i
    RETURNING VALUE(json) TYPE string.

  &quot;Assigns a training
  METHODS assign_training
    IMPORTING training_name    TYPE string
    RETURNING VALUE(assignees) TYPE string_table.

  &quot;Types for the JSON creation in the get_employee_info
  &quot;method implemenation
  TYPES: BEGIN OF ty_manager_info,
           id       TYPE i,
           name     TYPE string,
           job_role TYPE string,
         END OF ty_manager_info,
         tt_manager_info TYPE TABLE OF ty_manager_info WITH EMPTY KEY,
         BEGIN OF ty_employee_json,
           id              TYPE i,
           name            TYPE string,
           job_role        TYPE string,
           direct_managers TYPE tt_manager_info,
         END OF ty_employee_json.

ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Leaf
*&amp;---------------------------------------------------------------------*

CLASS lcl_employee DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES lif_org.
    METHODS constructor
      IMPORTING is_data TYPE lif_org~ty_employee_data.

  PRIVATE SECTION.
    DATA: employee_data TYPE lif_org~ty_employee_data,
          mngr          TYPE REF TO lif_org.
ENDCLASS.

CLASS lcl_employee IMPLEMENTATION.
  METHOD constructor.
    &quot;Assumption: No duplicate IDs are expected.
    employee_data = is_data.
  ENDMETHOD.

  METHOD lif_org~get_data.
    data = employee_data.
  ENDMETHOD.

  METHOD lif_org~set_manager.
    mngr = manager.
  ENDMETHOD.

  METHOD lif_org~get_salary.
    individual_salary = employee_data-salary.
    &quot;Assiging the same value to accumulated_salary as
    &quot;leaves do not have subordinates.
    accumulated_salary = employee_data-salary.
  ENDMETHOD.

  METHOD lif_org~get_headcount.
    count = 1.
  ENDMETHOD.

  METHOD lif_org~get_employee_hierarchy.
    DATA(indent) = ` `.
    DO level TIMES.
      indent &amp;&amp;= `       |`.
    ENDDO.
    APPEND |{ indent }-- (LEAF) ID { employee_data-id }, { employee_data-name }, { employee_data-job_role }, { employee_data-office }| TO employee_details.
  ENDMETHOD.

  METHOD lif_org~get_employees_by_role.
    IF employee_data-job_role = role.
      APPEND me TO employees.
    ENDIF.
  ENDMETHOD.

  METHOD lif_org~get_employees_by_office.
    IF employee_data-office = office.
      APPEND me TO employees.
    ENDIF.
  ENDMETHOD.

  METHOD lif_org~get_employee_info.
    IF employee_data-id &lt;&gt; employee_id.
      RETURN.
    ENDIF.

    DATA: employee_json   TYPE lif_org~ty_employee_json,
          managers_tab    TYPE lif_org~tt_manager_info,
          current_manager TYPE REF TO lif_org.

    employee_json-id       = employee_data-id.
    employee_json-name     = employee_data-name.
    employee_json-job_role = employee_data-job_role.

    &quot;Moving up the hierachy to retrieve managers
    current_manager = mngr.
    WHILE current_manager IS BOUND.
      DATA(manager_data) = current_manager-&gt;get_data( ).
      APPEND VALUE #( id = manager_data-id name = manager_data-name job_role = manager_data-job_role ) TO managers_tab.
      current_manager = current_manager-&gt;get_manager( ).
    ENDWHILE.

    employee_json-direct_managers = managers_tab.

    json = /ui2/cl_json=&gt;serialize( data          = employee_json
                                    format_output = abap_true
                                    pretty_name   = /ui2/cl_json=&gt;pretty_mode-camel_case ).
  ENDMETHOD.

  METHOD lif_org~assign_training.
    APPEND |Assigning training &#x27;{ training_name }&#x27; to employee { employee_data-name }| TO assignees.
  ENDMETHOD.

  METHOD lif_org~get_manager.
    manager = mngr.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Composite
*&amp;---------------------------------------------------------------------*

CLASS lcl_manager DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES lif_org.

    METHODS constructor
      IMPORTING is_data TYPE lif_org~ty_employee_data.

    METHODS add_subordinate
      IMPORTING component TYPE REF TO lif_org.

    METHODS remove_subordinate
      IMPORTING component TYPE REF TO lif_org.

    METHODS get_subordinates
      RETURNING VALUE(subordinates) TYPE lif_org~tt_org.

  PRIVATE SECTION.
    DATA: employee_data    TYPE lif_org~ty_employee_data,
          mngr             TYPE REF TO lif_org,
          subordinates_tab TYPE lif_org~tt_org.
ENDCLASS.

CLASS lcl_manager IMPLEMENTATION.
  METHOD constructor.
    &quot;Assumption: No duplicate IDs are expected.
    employee_data = is_data.
  ENDMETHOD.

  METHOD lif_org~get_data.
    data = employee_data.
  ENDMETHOD.

  METHOD add_subordinate.
    APPEND component TO subordinates_tab.
    &quot;Setting the manager reference on the child
    component-&gt;set_manager( me ).
  ENDMETHOD.

  METHOD remove_subordinate.
    &quot;Example logic:
    &quot;- Checking if the component is a direct subordinate. If it is a leaf, it is removed directly.
    &quot;  If it is a manager, its subordinates are assigned to the manager&#x27;s manager. Then, the
    &quot;  component is removed.
    &quot;- If the component is not a direct subordinate, then the search is delegated to subordinates.
    &quot;- Each subordinate is checked if a type cast to manager can be performed. The remove_subordinate
    &quot;  method is called recursively. If the cast cannot be performed, it means the subordinate is a
    &quot;  leaf node which cannot contain other components. In that case, the iteration is continued with
    &quot;  the next subordinate.

    READ TABLE subordinates_tab INTO DATA(ref) WITH KEY table_line = component.
    IF sy-subrc = 0.
      IF ref IS INSTANCE OF lcl_manager.
        DATA(manager_of_manager) = ref-&gt;get_manager( ).
        DATA(subordinates_of_manager) = CAST lcl_manager( ref )-&gt;get_subordinates( ).

        LOOP AT subordinates_of_manager INTO DATA(sub).
          sub-&gt;set_manager( manager_of_manager ).
          CAST lcl_manager( manager_of_manager )-&gt;add_subordinate( sub ).
        ENDLOOP.

        DELETE subordinates_tab WHERE table_line = component.
        RETURN.
      ELSE.
        DELETE subordinates_tab WHERE table_line = component.
        RETURN.
      ENDIF.
    ENDIF.

    LOOP AT subordinates_tab INTO sub.
      IF sub IS INSTANCE OF lcl_manager.
        &quot;Type cast to manager as only managers can have subordinates
        DATA(manager) = CAST lcl_manager( sub ).
        manager-&gt;remove_subordinate( component ).
      ELSE.
        &quot;Continuing with the iteration as the current node is
        &quot;a leaf node, which does not have subordinates.
        CONTINUE.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD lif_org~set_manager.
    mngr = manager.
  ENDMETHOD.

  METHOD lif_org~get_manager.
    manager = mngr.
  ENDMETHOD.

  METHOD lif_org~get_salary.
    individual_salary = employee_data-salary.
    accumulated_salary = employee_data-salary.

    LOOP AT subordinates_tab INTO DATA(sub).
      sub-&gt;get_salary( IMPORTING accumulated_salary = DATA(acc_salary) ).
      accumulated_salary += acc_salary.
    ENDLOOP.
  ENDMETHOD.

  METHOD lif_org~get_headcount.
    count = 1.
    LOOP AT subordinates_tab INTO DATA(sub).
      count += sub-&gt;get_headcount( ).
    ENDLOOP.
  ENDMETHOD.

  METHOD lif_org~get_employee_hierarchy.
    DATA(indent) = ` `.
    DO level TIMES.
      indent &amp;&amp;= `       |`.
    ENDDO.

    APPEND |{ indent }-- (COMPOSITE) ID { employee_data-id }, { employee_data-name }, { employee_data-job_role }, { employee_data-office }| TO employee_details.

    LOOP AT subordinates_tab INTO DATA(sub).
      DATA(line) = sub-&gt;get_employee_hierarchy( level = level + 1 ).
      APPEND LINES OF line TO employee_details.
    ENDLOOP.
  ENDMETHOD.

  METHOD lif_org~get_employees_by_role.
    IF employee_data-job_role = role.
      APPEND me TO employees.
    ENDIF.

    LOOP AT subordinates_tab INTO DATA(sub).
      DATA(empl) = sub-&gt;get_employees_by_role( role ).
      APPEND LINES OF empl TO employees.
    ENDLOOP.
  ENDMETHOD.

  METHOD lif_org~get_employees_by_office.
    IF employee_data-office = office.
      APPEND me TO employees.
    ENDIF.

    LOOP AT subordinates_tab INTO DATA(sub).
      DATA(off) = sub-&gt;get_employees_by_office( office ).
      APPEND LINES OF off TO employees.
    ENDLOOP.
  ENDMETHOD.

  METHOD lif_org~get_employee_info.
    IF employee_data-id = employee_id.
      DATA: employee_json   TYPE lif_org~ty_employee_json,
            managers_tab    TYPE lif_org~tt_manager_info,
            current_manager TYPE REF TO lif_org.

      employee_json-id       = employee_data-id.
      employee_json-name     = employee_data-name.
      employee_json-job_role = employee_data-job_role.

      current_manager = mngr.
      WHILE current_manager IS BOUND.
        DATA(manager_data) = current_manager-&gt;get_data( ).
        APPEND VALUE #( id = manager_data-id name = manager_data-name job_role = manager_data-job_role ) TO managers_tab.
        current_manager = current_manager-&gt;get_manager( ).
      ENDWHILE.

      employee_json-direct_managers = managers_tab.

      json = /ui2/cl_json=&gt;serialize( data = employee_json
                                      format_output = abap_true
                                      pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).
      RETURN.
    ENDIF.

    LOOP AT subordinates_tab INTO DATA(sub).
      DATA(lv_sub_json) = sub-&gt;get_employee_info( employee_id ).
      IF lv_sub_json IS NOT INITIAL.
        json = lv_sub_json.
        RETURN.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD lif_org~assign_training.
    APPEND |Assigning training &#x27;{ training_name }&#x27; to manager { employee_data-name } and team| TO assignees.

    LOOP AT subordinates_tab INTO DATA(sub).
      DATA(trainings) = sub-&gt;assign_training( training_name = training_name ).
      APPEND LINES OF trainings TO assignees.
    ENDLOOP.
  ENDMETHOD.

  METHOD get_subordinates.
    subordinates = subordinates_tab.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Data Access Object (DAO)</h2>
<ul>
<li>A Data Access Object (DAO) provides an API for performing CRUD operations on a database table.</li>
<li>By providing an object-oriented approach for these operations, you can centralize and encapsulate standard operations, eliminating the need to write them throughout the code.</li>
<li>A potential setup, illustrated in the following example, may include:</li>
<li>An interface that defines methods for accessing database tables.</li>
<li>A class that implements the interface. The example DAO class here uses the singleton design pattern to provide users with a single object of the DAO class.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<div class="note">[!NOTE] The example uses a demo database table (`zdemo_abap_carr`) from the ABAP cheat sheet repository.</div>
<ul>
<li>This example tries to illustrate the Data Access Object (DAO) design pattern using the following declarations and implementations:</li>
<li>CCIMP include (<em>Local Types</em> tab in ADT):</li>
<li>Interface <code>lif_dao</code></li>
<li>Describes a DAO for the database table <code>zdemo_abap_carr</code>, providing a single API to interact with it.</li>
<li>Defines CRUD methods to interact with the database table, including <code>count_entries</code> to return the number of entries, <code>does_entry_exist</code> to check if a record with a specific key exists, <code>get_entry</code> to return a single row for the specified key, <code>get_all_entries</code> to return all rows in an internal table, <code>create_entry</code> to insert a single row, <code>create_entries</code> to insert multiple rows from an internal table, <code>upsert_entry</code> to insert or update a row, and <code>delete_entry</code> to delete a row by key.</li>
<li>Class <code>lcl_dao</code></li>
<li>Implements the <code>lif_dao</code> interface and is implemented as a singleton.</li>
<li><code>CREATE PRIVATE</code> prevents direct instantiation of the class. Users can obtain a reference to the interface (stored in the static attribute <code>oref</code>) via the static <code>get_dao</code> method.</li>
<li>The methods use ABAP SQL <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements.</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from the local class <code>lcl_dao</code>.</li>
<li>Acts as the client in the example.</li>
<li>The implementation illustrates all operations available through the interface methods.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
    METHODS prep_dbtab.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA example_number TYPE i.
    METHODS set_example_divider IMPORTING out  TYPE REF TO if_oo_adt_classrun_out
                                          text TYPE string.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Preparing the demo database table
    prep_dbtab( ).

    &quot;Getting DAO
    DATA(dao) = lcl_dao=&gt;get_dao( ).

*&amp;---------------------------------------------------------------------*
*&amp; Counting entries
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }) Counting entries| ).

    DATA(count) = dao-&gt;count_entries( ).

    out-&gt;write( |Number of database table entries: { count }| ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Getting entries
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }) Getting entries| ).

    &quot;Getting all entries
    DATA(entries) = dao-&gt;get_all_entries( ).
    out-&gt;write( `All database table entries:` ).
    out-&gt;write( entries ).
    out-&gt;write( |\n| ).

    &quot;Getting single entries
    &quot;Non-existent entry
    DATA(entry) = dao-&gt;get_entry( &#x27;ZZ&#x27; ).
    IF entry IS INITIAL.
      out-&gt;write( `The returned data object is initial.` ).
    ELSE.
      out-&gt;write( entry ).
    ENDIF.
    out-&gt;write( |\n| ).

    &quot;Using the does_entry_exist method to check the existence
    DATA(exists) = dao-&gt;does_entry_exist( &#x27;ZZ&#x27; ).
    out-&gt;write( |The entry with ID &quot;ZZ&quot; { COND #( WHEN exists = abap_true THEN `exists` ELSE `does not exist` ) }.| ).
    out-&gt;write( |\n| ).
    out-&gt;write( |\n| ).

    &quot;Existent single entries
    entry = dao-&gt;get_entry( &#x27;AB&#x27; ).
    out-&gt;write( entry ).
    out-&gt;write( |\n| ).

    entry = dao-&gt;get_entry( &#x27;EF&#x27; ).
    out-&gt;write( entry ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Creating entries
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }) Creating entries| ).

    &quot;Creating single entries
    DATA(carr_data) = VALUE lif_dao=&gt;ts_carr( carrid = &#x27;MN&#x27; carrname = &#x27;MN Regional&#x27;  currcode = &#x27;CHF&#x27; url = &#x27;url_for_MN&#x27; ).

    DATA(done) = dao-&gt;create_entry( carr_data ).

    out-&gt;write( |Insert operation { COND #( WHEN done = abap_true THEN `done` ELSE `not done` ) }.| ).
    out-&gt;write( |\n| ).

    exists = dao-&gt;does_entry_exist( &#x27;MN&#x27; ).
    out-&gt;write( |The entry with ID &quot;MN&quot; { COND #( WHEN exists = abap_true THEN `exists` ELSE `does not exist` ) }.| ).
    out-&gt;write( |\n| ).

    &quot;Creating single entry with existing ID
    done = dao-&gt;create_entry( carr_data ).

    out-&gt;write( |Insert operation { COND #( WHEN done = abap_true THEN `done` ELSE `not done` ) }.| ).
    out-&gt;write( |\n| ).

    exists = dao-&gt;does_entry_exist( &#x27;MN&#x27; ).
    out-&gt;write( |The entry with ID &quot;MN&quot; { COND #( WHEN exists = abap_true THEN `exists` ELSE `does not exist` ) }.| ).
    out-&gt;write( |\n| ).

    &quot;Creating multiple entries
    DATA(carr_tab) = VALUE lif_dao=&gt;tt_carr( ( carrid = &#x27;OP&#x27; carrname = &#x27;OP Cargo&#x27; currcode = &#x27;CNY&#x27; url = &#x27;url_for_OP&#x27; )
                                             ( carrid = &#x27;QR&#x27; carrname = &#x27;QR International&#x27; currcode = &#x27;INR&#x27; url = &#x27;url_for_QR&#x27; ) ).

    done = dao-&gt;create_entries( carr_tab ).

    out-&gt;write( |Insert operation { COND #( WHEN done = abap_true THEN `done` ELSE `not or partly not done` ) }.| ).
    out-&gt;write( |\n| ).

    &quot;Example input with one already existing entry
    carr_tab = VALUE lif_dao=&gt;tt_carr( ( carrid = &#x27;OP&#x27; carrname = &#x27;OP Cargo&#x27; currcode = &#x27;CNY&#x27; url = &#x27;url_for_OP&#x27; )
                                       ( carrid = &#x27;ST&#x27; carrname = &#x27;ST Air Service&#x27; currcode = &#x27;BRL&#x27; url = &#x27;url_for_ST&#x27; ) ).

    done = dao-&gt;create_entries( carr_tab ).

    out-&gt;write( |Insert operation { COND #( WHEN done = abap_true THEN `done` ELSE `not or partly not done` ) }.| ).
    out-&gt;write( |\n| ).

    &quot;Getting all database table entries
    entries = dao-&gt;get_all_entries( ).
    out-&gt;write( `All database table entries:` ).
    out-&gt;write( entries ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Upserting entries
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }) Upserting entries| ).

    out-&gt;write( `--- Operation with ID &quot;MN&quot; ---` ).
    out-&gt;write( |\n| ).

    exists = dao-&gt;does_entry_exist( &#x27;MN&#x27; ).
    out-&gt;write( |The entry with ID &quot;MN&quot; { COND #( WHEN exists = abap_true THEN `exists` ELSE `does not exist` ) }.| ).
    out-&gt;write( |\n| ).
    out-&gt;write( |\n| ).
    IF exists = abap_true.
      entry = dao-&gt;get_entry( &#x27;MN&#x27; ).
      out-&gt;write( entry ).
      out-&gt;write( |\n| ).
    ENDIF.

    carr_data = VALUE lif_dao=&gt;ts_carr( carrid = &#x27;MN&#x27; carrname = &#x27;Air MN&#x27; currcode = &#x27;AED&#x27; url = &#x27;url_for_MN&#x27; ).

    DATA(operation) = dao-&gt;upsert_entry( carr_data ).
    out-&gt;write( |Entry was { COND #( WHEN operation = lif_dao=&gt;update THEN `updated` ELSE `inserted` ) }.| ).
    out-&gt;write( |\n| ).
    out-&gt;write( |\n| ).

    entry = dao-&gt;get_entry( &#x27;MN&#x27; ).
    out-&gt;write( entry ).
    out-&gt;write( |\n| ).

    out-&gt;write( `--- Operation with ID &quot;YZ&quot; ---` ).
    out-&gt;write( |\n| ).

    exists = dao-&gt;does_entry_exist( &#x27;YZ&#x27; ).
    out-&gt;write( |The entry with ID &quot;YZ&quot; { COND #( WHEN exists = abap_true THEN `exists` ELSE `does not exist` ) }.| ).
    out-&gt;write( |\n| ).
    IF exists = abap_true.
      entry = dao-&gt;get_entry( &#x27;YZ&#x27; ).
      out-&gt;write( entry ).
      out-&gt;write( |\n| ).
    ENDIF.

    carr_data = VALUE lif_dao=&gt;ts_carr( carrid = &#x27;YZ&#x27; carrname = &#x27;YZ Air Lines&#x27; currcode = &#x27;MXN&#x27; url = &#x27;url_for_YZ&#x27; ).

    operation = dao-&gt;upsert_entry( carr_data ).
    out-&gt;write( |Entry was { COND #( WHEN operation = lif_dao=&gt;update THEN `updated` ELSE `inserted` ) }.| ).
    out-&gt;write( |\n| ).
    out-&gt;write( |\n| ).

    entry = dao-&gt;get_entry( &#x27;YZ&#x27; ).
    out-&gt;write( entry ).

    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Deleting entries
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }) Deleting entries| ).

    &quot;Non-existent entry
    done = dao-&gt;delete_entry( &#x27;XY&#x27; ).

    out-&gt;write( |Delete operation { COND #( WHEN done = abap_true THEN `done` ELSE `not done` ) } for ID &quot;XY&quot;.| ).
    out-&gt;write( |\n| ).

    done = dao-&gt;delete_entry( &#x27;YZ&#x27; ).

    out-&gt;write( |Delete operation { COND #( WHEN done = abap_true THEN `done` ELSE `not done` ) } for ID &quot;YZ&quot;.| ).
    out-&gt;write( |\n| ).

    done = dao-&gt;delete_entry( &#x27;AB&#x27; ).

    out-&gt;write( |Delete operation { COND #( WHEN done = abap_true THEN `done` ELSE `not done` ) } for ID &quot;AB&quot;.| ).
    out-&gt;write( |\n| ).

    &quot;Getting count
    count = dao-&gt;count_entries( ).

    out-&gt;write( |Number of database table entries: { count }| ).
    out-&gt;write( |\n| ).

    &quot;Getting all entries
    entries = dao-&gt;get_all_entries( ).
    out-&gt;write( `All database table entries:` ).
    out-&gt;write( entries ).
  ENDMETHOD.

  METHOD set_example_divider.
    out-&gt;write( |*&amp;{ repeat( val = `-` occ = 70 ) }*| ).
    out-&gt;write( |*&amp; { text }| ).
    out-&gt;write( |*&amp;{ repeat( val = `-` occ = 70 ) }*| ).
    out-&gt;write( |\n| ).
  ENDMETHOD.

  METHOD prep_dbtab.
    DELETE FROM zdemo_abap_carr.

    INSERT zdemo_abap_carr FROM TABLE @( VALUE #(
      ( carrid = &#x27;AB&#x27; carrname = &#x27;AB Airways&#x27;     currcode = &#x27;USD&#x27; url = &#x27;url_for_AB&#x27; )
      ( carrid = &#x27;CD&#x27; carrname = &#x27;CD Air&#x27;         currcode = &#x27;EUR&#x27; url = &#x27;url_for_CD&#x27; )
      ( carrid = &#x27;EF&#x27; carrname = &#x27;EF Aviation&#x27;    currcode = &#x27;GBP&#x27; url = &#x27;url_for_EF&#x27; )
      ( carrid = &#x27;GH&#x27; carrname = &#x27;GH Airlines&#x27;    currcode = &#x27;JPY&#x27; url = &#x27;url_for_GH&#x27; )
      ( carrid = &#x27;IJ&#x27; carrname = &#x27;IJ Skyways&#x27;     currcode = &#x27;AUD&#x27; url = &#x27;url_for_IJ&#x27; )
      ( carrid = &#x27;KL&#x27; carrname = &#x27;KL Air Express&#x27; currcode = &#x27;ZAR&#x27; url = &#x27;url_for_KL&#x27; ) ) ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_dao.

  TYPES: ts_carr TYPE zdemo_abap_carr,
         tt_carr TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY,
         BEGIN OF ENUM enum_op,
           update,
           insert,
         END OF ENUM enum_op.

  METHODS count_entries
    RETURNING VALUE(count) TYPE i.

  METHODS does_entry_exist
    IMPORTING carrid        TYPE ts_carr-carrid
    RETURNING VALUE(exists) TYPE abap_boolean.

  METHODS get_entry
    IMPORTING carrid       TYPE ts_carr-carrid
    RETURNING VALUE(entry) TYPE ts_carr.

  METHODS get_all_entries
    RETURNING VALUE(entries) TYPE tt_carr.

  METHODS create_entry
    IMPORTING entry       TYPE ts_carr
    RETURNING VALUE(done) TYPE abap_boolean.

  METHODS create_entries
    IMPORTING entries     TYPE tt_carr
    RETURNING VALUE(done) TYPE abap_boolean.

  METHODS upsert_entry
    IMPORTING entry            TYPE ts_carr
    RETURNING VALUE(operation) TYPE enum_op.

  METHODS delete_entry
    IMPORTING carrid      TYPE ts_carr-carrid
    RETURNING VALUE(done) TYPE abap_boolean.

ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete class
*&amp;---------------------------------------------------------------------*

CLASS lcl_dao DEFINITION FINAL CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES lif_dao.
    CLASS-METHODS get_dao RETURNING VALUE(dao) TYPE REF TO lif_dao.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-DATA oref TYPE REF TO lif_dao.
ENDCLASS.

CLASS lcl_dao IMPLEMENTATION.

  METHOD lif_dao~count_entries.
    SELECT COUNT( * ) FROM zdemo_abap_carr INTO @count.
  ENDMETHOD.

  METHOD lif_dao~create_entries.
    INSERT zdemo_abap_carr FROM TABLE @entries ACCEPTING DUPLICATE KEYS.

    IF sy-subrc = 0.
      done = abap_true.
    ENDIF.
  ENDMETHOD.

  METHOD lif_dao~create_entry.
    INSERT zdemo_abap_carr FROM @entry.

    IF sy-subrc = 0.
      done = abap_true.
    ENDIF.
  ENDMETHOD.

  METHOD lif_dao~delete_entry.
    DELETE FROM zdemo_abap_carr WHERE carrid = @carrid.

    IF sy-subrc = 0.
      done = abap_true.
    ENDIF.
  ENDMETHOD.

  METHOD lif_dao~does_entry_exist.
    SELECT SINGLE @abap_true FROM zdemo_abap_carr WHERE carrid = @carrid INTO @exists.
  ENDMETHOD.

  METHOD lif_dao~get_all_entries.
    SELECT * FROM zdemo_abap_carr ORDER BY carrid INTO TABLE @entries.
  ENDMETHOD.

  METHOD lif_dao~get_entry.
    SELECT SINGLE * FROM zdemo_abap_carr WHERE carrid = @carrid INTO @entry.
  ENDMETHOD.

  METHOD lif_dao~upsert_entry.
    DATA(exists) = lif_dao~does_entry_exist( entry-carrid ).

    IF exists = abap_true.
      UPDATE zdemo_abap_carr FROM @entry.
      operation = lif_dao=&gt;update.
    ELSE.
      INSERT zdemo_abap_carr FROM @entry.
      operation = lif_dao=&gt;insert.
    ENDIF.
  ENDMETHOD.

  METHOD get_dao.
    IF oref IS NOT BOUND.
      oref = NEW lcl_dao( ).
    ENDIF.

    dao = oref.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Decorator</h2>
<ul>
<li>Enhances and modifies existing objects by wrapping them in other objects (objects of decorator classes) without modifying the original object setup and class code.</li>
<li>Useful when flexibility is needed to handle various combinations and functionalities of objects.</li>
<li>An exemplary class setup may include:</li>
<li>An interface that defines common functions</li>
<li>A base class implementing the interface; objects of this class are meant to be enhanced (decorated)</li>
<li>An abstract decorator class that delegates functionality enhancement</li>
<li>Concrete decorator classes that enhance existing objects</li>
<li>Objects of the base class can be wrapped in concrete decorator objects, enhancing functionality since all objects share features by implementing the interface</li>
<li>Advantages:</li>
<li>Users can decorate objects with any decorator since all implement the interface.</li>
<li>All classes implement the interface, allowing all objects to be accessed through the same interface reference variable.</li>
<li>Users can work with any base class object, be it a <em>direct</em> object of the base class or a decorated object.</li>
<li>The pattern offers flexibility as you can dynamically enhance objects using any decorators to achieve any desired object.</li>
<li>Maintenance can be simplified because each decorator class encapsulates specific functionality, and you can easily extend functionality by adding more decorator classes.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p>The following example demonstrates the decorator design pattern in a pizza creation context. Starting with a basic pizza (object), you can create various pizzas (decorate the pizza object) by adding ingredients, which also changes the pizza&#x27;s cost:</p>
<ul>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes in the CCIMP include.</li>
<li>Demonstrates the decorator design pattern by creating an <code>lcl_basic_pizza</code> object. This object is enhanced (decorated) by wrapping it in objects of concrete decorator classes <code>lcl_decorator_*</code>.</li>
<li>You can run the class by choosing F9 in ADT. The example displays output in the ADT console.</li>
<li>CCIMP include (<em>Local Types</em> tab in ADT):</li>
<li><code>lif_pizza</code></li>
<li>An interface defining a common setup for all decorators and decorated objects.</li>
<li>Implemented by all other local classes in the example, including the concrete base class and decorator classes.</li>
<li>Defines the methods <code>create_pizza</code> for pizza creation and <code>get_costs</code> for cost calculation.</li>
<li><code>lcl_basic_pizza</code></li>
<li>Objects of the class represent basic objects that can be decorated.</li>
<li>Implements the <code>lif_pizza</code> interface.</li>
<li>Defines the instance <code>constructor</code> that specifies an integer as importing parameter to set the base cost.</li>
<li><code>lcl_pizza_decorator</code></li>
<li>Represents an abstract decorator class.</li>
<li>Implements the <code>lif_pizza</code> interface.</li>
<li>As an abstract class, object creation is restricted to its subclasses (the concrete decorator classes).</li>
<li>The instance constructor receives the decorated pizza object, linking concrete decorators to the object being decorated. This reference is assigned to an interface reference variable in the protected section, allowing subclass access (though not relevant for this example). Subclasses call the constructor.</li>
<li>The implemented interface methods delegate calls to the wrapped/decorated object using the interface reference variable.</li>
<li><code>lcl_decorator_*</code> classes</li>
<li>Represent concrete decorator classes.</li>
<li>Inherit from the abstract decorator class <code>lcl_pizza_decorator</code>.</li>
<li>Their objects can wrap and enhance existing objects.</li>
<li>Since <code>lcl_pizza_decorator</code> implements <code>lif_pizza</code>, the <code>lcl_decorator_*</code> classes can also redefine the interface methods.</li>
<li>The superclass <code>lcl_pizza_decorator</code> defines an instance constructor expecting a reference (<code>REF TO lif_pizza</code>) as an importing parameter. It is mandatory that the subclasses call the superclass&#x27;s constructor, yet it is not mandatory for the constructor to be explicitly defined and implemented. The subclasses in the example explicitly define and implement the instance constructor. You can, for example, check out the <code>lcl_decorator_salami</code> class, and remove the definition <code>METHODS constructor IMPORTING pizza TYPE REF TO lif_pizza.</code> and its implementation. There will not be syntax errors when creating objects in the global class using <code>lcl_decorator_salami</code>. Due to inheritance, a reference is still required to be passed for the importing parameter although not explicitly specified in the local subclass.</li>
<li>Implementations of interface methods in these classes make simple modifications, like adding ingredients and adjusting total costs. Each concrete decorator class introduces its own functionality, allowing dynamic stacking of decorations. The <code>super-&gt;...</code> calls trigger the calling of superclass implementations. Since the link to the decorated object is estrablished, ingredients are added to the existing ingredients, and costs are added to the existing costs.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.
    DATA(divider) = |{ repeat( val = `_` occ = 75 ) }\n|.

    &quot;---------------- Basic pizza ----------------
    DATA(basic_pizza) = NEW lcl_basic_pizza( 10 ).
    DATA(basic_pizza_created) = basic_pizza-&gt;lif_pizza~create_pizza( ).
    DATA(basic_pizza_costs) = basic_pizza-&gt;lif_pizza~get_costs( ).

    out-&gt;write( `Basic pizza` ).
    out-&gt;write( |\nIngredients:| ).
    out-&gt;write( basic_pizza_created ).
    out-&gt;write( |\nCosts:| ).
    out-&gt;write( basic_pizza_costs ).
    out-&gt;write( divider ).

    &quot;---------------- Salami pizza ----------------
    DATA(salami_pizza) = NEW lcl_decorator_salami( pizza = basic_pizza ).
    DATA(salami_pizza_created) = salami_pizza-&gt;lif_pizza~create_pizza( ).
    DATA(salami_pizza_costs) = salami_pizza-&gt;lif_pizza~get_costs( ).

    out-&gt;write( `Salami pizza` ).
    out-&gt;write( |\nIngredients:| ).
    out-&gt;write( salami_pizza_created ).
    out-&gt;write( |\nCosts:| ).
    out-&gt;write( salami_pizza_costs ).
    out-&gt;write( divider ).

    &quot;---------------- Vegetable pizza ----------------
    DATA(vegetarian_pizza) = NEW lcl_decorator_vegetables( pizza = basic_pizza ).
    DATA(vegetarian_pizza_created) = vegetarian_pizza-&gt;lif_pizza~create_pizza( ).
    DATA(vegetarian_pizza_costs) = vegetarian_pizza-&gt;lif_pizza~get_costs( ).

    out-&gt;write( `Vegetable pizza` ).
    out-&gt;write( |\nIngredients:| ).
    out-&gt;write( vegetarian_pizza_created ).
    out-&gt;write( |\nCosts:| ).
    out-&gt;write( vegetarian_pizza_costs ).
    out-&gt;write( divider ).

    &quot;---------------- Vegetable/salami pizza ----------------
    DATA(vegetable_salami_pizza) = NEW lcl_decorator_vegetables(
      pizza = NEW lcl_decorator_salami(
      pizza = NEW lcl_basic_pizza( 10 ) ) ).
    DATA(vegetable_salami_pizza_created) = vegetable_salami_pizza-&gt;lif_pizza~create_pizza( ).
    DATA(vegetable_salami_pizza_costs) = vegetable_salami_pizza-&gt;lif_pizza~get_costs( ).

    out-&gt;write( `Vegetable/salami pizza` ).
    out-&gt;write( |\nIngredients:| ).
    out-&gt;write( vegetable_salami_pizza_created ).
    out-&gt;write( |\nCosts:| ).
    out-&gt;write( vegetable_salami_pizza_costs ).
    out-&gt;write( divider ).

    &quot;---------------- Mushroom/salami pizza ----------------
    DATA(mushrooms_salami_pizza) = NEW lcl_decorator_mushrooms(
      pizza = NEW lcl_decorator_salami(
      pizza = NEW lcl_basic_pizza( 10 ) ) ).
    DATA(mushrooms_salami_pizza_created) = mushrooms_salami_pizza-&gt;lif_pizza~create_pizza( ).
    DATA(mushrooms_salami_pizza_costs) = mushrooms_salami_pizza-&gt;lif_pizza~get_costs( ).

    out-&gt;write( `Mushrooms/salami pizza` ).
    out-&gt;write( |\nIngredients:| ).
    out-&gt;write( mushrooms_salami_pizza_created ).
    out-&gt;write( |\nCosts:| ).
    out-&gt;write( mushrooms_salami_pizza_costs ).
    out-&gt;write( divider ).

    &quot;--- Various pizzas (created using the same interface reference variable) ---
    DATA some_pizza TYPE REF TO lif_pizza.
    some_pizza = NEW lcl_basic_pizza( 10 ).
    DATA(some_pizza_created_a) = some_pizza-&gt;create_pizza( ).
    DATA(some_pizza_costs_a) = some_pizza-&gt;get_costs( ).

    some_pizza = NEW lcl_decorator_vegetables( pizza = some_pizza ).
    DATA(some_pizza_created_b) = some_pizza-&gt;create_pizza( ).
    DATA(some_pizza_costs_b) = some_pizza-&gt;get_costs( ).

    some_pizza = NEW lcl_decorator_salami( pizza = some_pizza ).
    DATA(some_pizza_created_c) = some_pizza-&gt;create_pizza( ).
    DATA(some_pizza_costs_c) = some_pizza-&gt;get_costs( ).

    &quot;---------------- Allergy-friendly vegetable pizza ----------------
    DATA(allergy_friendly_vegetbl_pizza) = NEW lcl_decorator_allergy_friendly(
        pizza = NEW lcl_decorator_vegetables(
        pizza = NEW lcl_basic_pizza( 10 ) ) ).
    DATA(all_friendly_veg_pizza_created) = allergy_friendly_vegetbl_pizza-&gt;lif_pizza~create_pizza( ).
    DATA(all_friendly_veg_pizza_costs) = allergy_friendly_vegetbl_pizza-&gt;lif_pizza~get_costs( ).

    out-&gt;write( `Allergy-friendly vegetable pizza` ).
    out-&gt;write( |\nIngredients:| ).
    out-&gt;write( all_friendly_veg_pizza_created ).
    out-&gt;write( |\nCosts:| ).
    out-&gt;write( all_friendly_veg_pizza_costs ).
    out-&gt;write( divider ).

    &quot;---------------- Pizza with all ingredients ----------------
    &quot;Using all concrete decorator classes of the example
    DATA(misc_pizza) = NEW lcl_decorator_allergy_friendly(
       pizza = NEW lcl_decorator_mushrooms(
       pizza = NEW lcl_decorator_salami(
       pizza = NEW lcl_decorator_vegetables(
       pizza = NEW lcl_basic_pizza( 10 ) ) ) ) ).
    DATA(misc_pizza_created) = misc_pizza-&gt;lif_pizza~create_pizza( ).
    DATA(misc_pizza_costs) = misc_pizza-&gt;lif_pizza~get_costs( ).

    out-&gt;write( `Pizza with all ingredients` ).
    out-&gt;write( |\nIngredients:| ).
    out-&gt;write( misc_pizza_created ).
    out-&gt;write( |\nCosts:| ).
    out-&gt;write( misc_pizza_costs ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>**********************************************************************
&quot;Interface

INTERFACE lif_pizza.
  METHODS create_pizza RETURNING VALUE(ingredients) TYPE string_table.
  METHODS get_costs RETURNING VALUE(costs) TYPE i.
ENDINTERFACE.

**********************************************************************
&quot;Basic pizza to be decorated

CLASS lcl_basic_pizza DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_pizza.
    METHODS constructor IMPORTING basic_pizza_costs TYPE i.
  PRIVATE SECTION.
    DATA pizza_costs TYPE i.
ENDCLASS.

CLASS lcl_basic_pizza IMPLEMENTATION.
  METHOD constructor.
    pizza_costs = basic_pizza_costs.
  ENDMETHOD.

  METHOD lif_pizza~create_pizza.
    ingredients = VALUE #( ( `dough` ) ( `tomato sauce` ) ( `cheese` ) ).
  ENDMETHOD.

  METHOD lif_pizza~get_costs.
    costs = pizza_costs.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
&quot;Abstract decorator class

CLASS lcl_pizza_decorator DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES lif_pizza.
    METHODS constructor IMPORTING pizza TYPE REF TO lif_pizza.
  PROTECTED SECTION.
    DATA decorated_pizza TYPE REF TO lif_pizza.
ENDCLASS.

CLASS lcl_pizza_decorator IMPLEMENTATION.
  METHOD constructor.
    decorated_pizza = pizza.
  ENDMETHOD.

  METHOD lif_pizza~create_pizza.
    ingredients = decorated_pizza-&gt;create_pizza( ).
  ENDMETHOD.

  METHOD lif_pizza~get_costs.
    costs = decorated_pizza-&gt;get_costs( ).
  ENDMETHOD.
ENDCLASS.

**********************************************************************
&quot;Concrete decorator classes

CLASS lcl_decorator_salami DEFINITION INHERITING FROM lcl_pizza_decorator.
  PUBLIC SECTION.
    METHODS constructor IMPORTING pizza TYPE REF TO lif_pizza.
    METHODS lif_pizza~create_pizza REDEFINITION.
    METHODS lif_pizza~get_costs REDEFINITION.
ENDCLASS.

CLASS lcl_decorator_salami IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( pizza ).
  ENDMETHOD.

  METHOD lif_pizza~create_pizza.
    ingredients = super-&gt;lif_pizza~create_pizza( ).
    APPEND `salami` TO ingredients.
  ENDMETHOD.

  METHOD lif_pizza~get_costs.
    costs = super-&gt;lif_pizza~get_costs( ) + 1.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_decorator_mushrooms DEFINITION INHERITING FROM lcl_pizza_decorator.
  PUBLIC SECTION.
    METHODS constructor IMPORTING pizza TYPE REF TO lif_pizza.
    METHODS lif_pizza~create_pizza REDEFINITION.
    METHODS lif_pizza~get_costs REDEFINITION.
ENDCLASS.

CLASS lcl_decorator_mushrooms IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( pizza ).
  ENDMETHOD.

  METHOD lif_pizza~create_pizza.
    ingredients = super-&gt;lif_pizza~create_pizza( ).
    APPEND `mushrooms` TO ingredients.
  ENDMETHOD.

  METHOD lif_pizza~get_costs.
    costs = super-&gt;lif_pizza~get_costs( ) + 1.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_decorator_vegetables DEFINITION INHERITING FROM lcl_pizza_decorator.
  PUBLIC SECTION.
    METHODS constructor IMPORTING pizza TYPE REF TO lif_pizza.
    METHODS lif_pizza~create_pizza REDEFINITION.
    METHODS lif_pizza~get_costs REDEFINITION.
ENDCLASS.

CLASS lcl_decorator_vegetables IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( pizza ).
  ENDMETHOD.

  METHOD lif_pizza~create_pizza.
    ingredients = super-&gt;lif_pizza~create_pizza( ).
    APPEND LINES OF VALUE string_table( ( `red pepper` ) ( `zucchini` ) ( `broccoli` ) ) TO ingredients.
  ENDMETHOD.

  METHOD lif_pizza~get_costs.
    costs = super-&gt;lif_pizza~get_costs( ) + 2.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_decorator_allergy_friendly DEFINITION INHERITING FROM lcl_pizza_decorator.
  PUBLIC SECTION.
    METHODS constructor IMPORTING pizza TYPE REF TO lif_pizza.
    METHODS lif_pizza~create_pizza REDEFINITION.
    METHODS lif_pizza~get_costs REDEFINITION.
ENDCLASS.

CLASS lcl_decorator_allergy_friendly IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( pizza ).
  ENDMETHOD.

  METHOD lif_pizza~create_pizza.
    ingredients = super-&gt;lif_pizza~create_pizza( ).
    REPLACE ALL OCCURRENCES OF `dough` IN TABLE ingredients WITH `gluten-free dough`.
    REPLACE ALL OCCURRENCES OF `cheese` IN TABLE ingredients WITH `lactose-free cheese`.
  ENDMETHOD.

  METHOD lif_pizza~get_costs.
    costs = super-&gt;lif_pizza~get_costs( ) + 1.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Facade</h2>
<ul>
<li>Assume you must handle complex functionality that may involve creating objects from multiple classes and calling methods, maybe even in a specific sequence and involving certain dependencies.</li>
<li>The facade design pattern&#x27;s purpose is to provide a simplified API, hiding the complexity from users and allowing them to achieve desired results without dealing with and knowing about underlying complexities.</li>
<li>Users can interact with this straightforward API instead of handling intricate steps and details.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The simplified example uses a travel search context. Users receive information about available flights, hotels, and rental cars. This information is retrieved by creating instances of multiple classes and various method calls. A facade class provides a simplified API that manages complex underlying functionality. Users interact only with the facade class, eliminating the need to handle individual class objects directly.</li>
<li>The example demonstrates the facade design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the <code>CCIMP</code> are relevant for the for conceptual considerations.</li>
<li>The global class represents the user of the simplified API the facade class offers.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Contains multiple local classes (<code>lcl_*</code>) that provide information about available flights, hotels and rental cars.</li>
<li>The simple classes include a method that calls a method in another class. Information is retrieved based on origin, destination, and travel time span.</li>
<li>The <code>lcl_travel_facade</code> class serves as the facade class. The <code>plan_travel</code> method includes object creations and method calls. For simplicity, the method returns information about available flights, hotels, and rental cars in a string table.</li>
<li>The class execution involves the following:</li>
<li>The global class contains several method calls to the facade class.</li>
<li>Based on the parameters passed, travel options are evaluated. As a result, a string table is output showing travel search information.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.

  METHOD if_oo_adt_classrun~main.
    DATA(travel_object) = NEW lcl_travel_facade( ).
    DATA(travel_options_1) = travel_object-&gt;plan_travel(
                from      = &#x27;Frankfurt&#x27;
                to        = &#x27;Shanghai&#x27;
                arrival   = &#x27;20250511&#x27;
                departure = &#x27;20250521&#x27; ).

    out-&gt;write( travel_options_1 ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

    DATA(travel_options_2) = travel_object-&gt;plan_travel(
                from      = &#x27;Frankfurt&#x27;
                to        = &#x27;Shanghai&#x27;
                arrival   = &#x27;20250605&#x27;
                departure = &#x27;20250617&#x27; ).

    out-&gt;write( travel_options_2 ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

    DATA(travel_options_3) = travel_object-&gt;plan_travel(
                  from      = &#x27;Frankfurt&#x27;
                  to        = &#x27;Shanghai&#x27;
                  arrival   = &#x27;20250403&#x27;
                  departure = &#x27;20250410&#x27; ).

    out-&gt;write( travel_options_3 ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>&quot;Class that includes a method to get flights from a data source
&quot;In this simple, self-contained example, the data source is
&quot;simulated by an internal table that includes demo data.
CLASS lcl_flight_retrieval DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF flight_struc,
             from        TYPE c LENGTH 20,
             to          TYPE c LENGTH 20,
             flight_date TYPE d,
             flight_time TYPE t,
           END OF flight_struc,
           flight_tab_type TYPE TABLE OF flight_struc WITH EMPTY KEY.

    METHODS get_flights
      IMPORTING
        from           TYPE string
        to             TYPE string
        flight_date    TYPE d
      RETURNING
        VALUE(flights) TYPE flight_tab_type.
    CLASS-METHODS class_constructor.
  PRIVATE SECTION.
    CLASS-DATA flight_tab TYPE flight_tab_type.
ENDCLASS.

CLASS lcl_flight_retrieval IMPLEMENTATION.
  METHOD get_flights.
    SELECT * FROM @flight_tab AS tab
      WHERE from = @from AND to = @to AND flight_date = @flight_date
      INTO TABLE @flights.
  ENDMETHOD.
  METHOD class_constructor.
    flight_tab = VALUE #(
     ( from = &#x27;Frankfurt&#x27; to = &#x27;Shanghai&#x27; flight_date = &#x27;20250511&#x27; flight_time = &#x27;050000&#x27; )
     ( from = &#x27;Frankfurt&#x27; to = &#x27;Shanghai&#x27; flight_date = &#x27;20250511&#x27; flight_time = &#x27;200000&#x27; )
     ( from = &#x27;Frankfurt&#x27; to = &#x27;Shanghai&#x27; flight_date = &#x27;20250605&#x27; flight_time = &#x27;151500&#x27; )
     ( from = &#x27;Frankfurt&#x27; to = &#x27;Shanghai&#x27; flight_date = &#x27;20250725&#x27; flight_time = &#x27;070000&#x27; )
     ( from = &#x27;Shanghai&#x27; to = &#x27;Frankfurt&#x27; flight_date = &#x27;20250410&#x27; flight_time = &#x27;194500&#x27; )
     ( from = &#x27;Shanghai&#x27; to = &#x27;Frankfurt&#x27; flight_date = &#x27;20250521&#x27; flight_time = &#x27;123000&#x27; )
     ( from = &#x27;Shanghai&#x27; to = &#x27;Frankfurt&#x27; flight_date = &#x27;20250805&#x27; flight_time = &#x27;184500&#x27; ) ).
  ENDMETHOD.
ENDCLASS.

&quot;An object of the lcl_flight_search class is required for searching flights. This object is
&quot;created by the facade class. The lcl_flight_search class implementation includes the calling
&quot;of a method of the lcl_flight_retrieval class to retrieve a list of available flights.
CLASS lcl_flight_search DEFINITION.
  PUBLIC SECTION.
    METHODS search_flights
      IMPORTING
        from               TYPE string
        to                 TYPE string
        arrival            TYPE d
        departure          TYPE d
      RETURNING
        VALUE(flight_list) TYPE string_table.
ENDCLASS.

CLASS lcl_flight_search IMPLEMENTATION.
  METHOD search_flights.
    DATA(flight_obj) = NEW lcl_flight_retrieval( ).
    DATA(result) = flight_obj-&gt;get_flights(
                    from        = from
                    to          = to
                    flight_date = arrival ).

    IF result IS INITIAL.
      APPEND |X  \| There&#x27;s no flight from { from } to { to } available on { arrival }.| TO flight_list.
    ELSE.
      LOOP AT result INTO DATA(flight_wa).
        APPEND |OK \| Flight from { flight_wa-from } to { flight_wa-to } available on { flight_wa-flight_date } at { flight_wa-flight_time }.| TO flight_list.
      ENDLOOP.
    ENDIF.

    result = flight_obj-&gt;get_flights(
                  from        = to
                  to          = from
                  flight_date = departure ).

    IF result IS INITIAL.
      APPEND |X  \| There&#x27;s no flight from { to } to { from } available on { departure }.| TO flight_list.
    ELSE.
      LOOP AT result INTO flight_wa.
        APPEND |OK \| Flight from { flight_wa-from } to { flight_wa-to } available on { flight_wa-flight_date } at { flight_wa-flight_time }.| TO flight_list.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

&quot;Class to get hotels from a data source
&quot;In this simple, self-contained example, the data source is
&quot;simulated by an internal table that includes demo data with
&quot;hotel details such as unavailable dates.
CLASS lcl_hotel_retrieval DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF hotel_struc,
             city         TYPE c LENGTH 20,
             hotel_name   TYPE c LENGTH 20,
             is_available TYPE abap_boolean,
           END OF hotel_struc,
           hotel_tab_type TYPE TABLE OF hotel_struc WITH EMPTY KEY.

    METHODS get_hotels
      IMPORTING
        city          TYPE string
        arrival       TYPE d
        departure     TYPE  d
      RETURNING
        VALUE(hotels) TYPE hotel_tab_type.
    CLASS-METHODS class_constructor.
  PRIVATE SECTION.
    CLASS-DATA hotel_tab TYPE hotel_tab_type.
    TYPES: BEGIN OF hotel_struc_availability,
             city             TYPE c LENGTH 20,
             hotel_name       TYPE c LENGTH 20,
             unavailable_date TYPE d,
           END OF hotel_struc_availability,
           hotel_tab_availability_type TYPE TABLE OF hotel_struc_availability WITH EMPTY KEY.
    CLASS-DATA hotel_tab_availability TYPE hotel_tab_availability_type.
    DATA date_tab TYPE TABLE OF d WITH EMPTY KEY.
    DATA flag TYPE abap_boolean.
ENDCLASS.

CLASS lcl_hotel_retrieval IMPLEMENTATION.
  METHOD get_hotels.
    SELECT * FROM @hotel_tab_availability AS tab
      WHERE city = @city
      INTO TABLE @DATA(hotel_list).

    LOOP AT hotel_list INTO DATA(waf) GROUP BY ( key = waf-hotel_name ) ASCENDING INTO DATA(keyf).
      LOOP AT GROUP keyf INTO DATA(memberf).
        APPEND memberf-unavailable_date TO date_tab.
      ENDLOOP.

      &quot;Checking whether hotels are available during the travel time span
      LOOP AT date_tab INTO DATA(date).
        IF date &gt;= arrival AND date &lt;= departure.
          flag = abap_false.
          EXIT.
        ELSE.
          flag = abap_true.
        ENDIF.
      ENDLOOP.

      IF flag = abap_true.
        APPEND VALUE #( city = memberf-city hotel_name = memberf-hotel_name is_available = abap_true ) TO hotels.
      ENDIF.

      CLEAR flag.
      CLEAR date_tab.
    ENDLOOP.

  ENDMETHOD.
  METHOD class_constructor.
    hotel_tab_availability = VALUE #(
        ( city = &#x27;Frankfurt&#x27; hotel_name = &#x27;ABC&#x27; unavailable_date = &#x27;20250512&#x27; )
        ( city = &#x27;Frankfurt&#x27; hotel_name = &#x27;ABC&#x27; unavailable_date = &#x27;20250612&#x27; )
        ( city = &#x27;Frankfurt&#x27; hotel_name = &#x27;DEF&#x27; unavailable_date = &#x27;20250512&#x27; )
        ( city = &#x27;Frankfurt&#x27; hotel_name = &#x27;DEF&#x27; unavailable_date = &#x27;20250712&#x27; )
        ( city = &#x27;Frankfurt&#x27; hotel_name = &#x27;GHI&#x27; unavailable_date = &#x27;20250512&#x27; )
        ( city = &#x27;Frankfurt&#x27; hotel_name = &#x27;GHI&#x27; unavailable_date = &#x27;20250812&#x27; )
        ( city = &#x27;Shanghai&#x27; hotel_name = &#x27;JKL&#x27; unavailable_date = &#x27;20250512&#x27; )
        ( city = &#x27;Shanghai&#x27; hotel_name = &#x27;JKL&#x27; unavailable_date = &#x27;20250610&#x27; )
        ( city = &#x27;Shanghai&#x27; hotel_name = &#x27;MNO&#x27; unavailable_date = &#x27;20250712&#x27; )
        ( city = &#x27;Shanghai&#x27; hotel_name = &#x27;MNO&#x27; unavailable_date = &#x27;20250611&#x27; )
        ( city = &#x27;Shanghai&#x27; hotel_name = &#x27;PQR&#x27; unavailable_date = &#x27;20250408&#x27; )
        ( city = &#x27;Shanghai&#x27; hotel_name = &#x27;PQR&#x27; unavailable_date = &#x27;20250912&#x27; )
        ( city = &#x27;Shanghai&#x27; hotel_name = &#x27;PQR&#x27; unavailable_date = &#x27;20250612&#x27; ) ).
  ENDMETHOD.
ENDCLASS.

&quot;An object of the lcl_hotel_search class is required for searching hotels. This object is
&quot;created by the facade class. The lcl_hotel_search class implementation includes the calling
&quot;of a method of the lcl_hotel_retrieval class to retrieve a list of available hotels.
CLASS lcl_hotel_search DEFINITION.
  PUBLIC SECTION.
    METHODS search_hotel
      IMPORTING
        destination       TYPE string
        arrival           TYPE d
        departure         TYPE d
      RETURNING
        VALUE(hotel_list) TYPE string_table.
ENDCLASS.

CLASS lcl_hotel_search IMPLEMENTATION.
  METHOD search_hotel.

    DATA(hotel_obj) = NEW lcl_hotel_retrieval( ).
    DATA(result) = hotel_obj-&gt;get_hotels(
                    city      = destination
                    arrival   = arrival
                    departure = departure ).

    IF result IS INITIAL.
      APPEND |X  \| There&#x27;s no hotel available in { destination } during your trip from { arrival } to { departure }.| TO hotel_list.
    ELSE.
      LOOP AT result INTO DATA(hotel_wa).
        APPEND |OK \| Hotel &quot;{ hotel_wa-hotel_name }&quot; in { destination } is availble during your trip from { arrival } to { departure }.| TO hotel_list.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

&quot;Class to get rental cars from a data source
&quot;In this simple, self-contained example, the data source is
&quot;simulated by an internal table that includes demo data with
&quot;rental car details such as unavailable dates.
CLASS lcl_rental_car_retrieval DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF rental_car_struc,
             city         TYPE c LENGTH 20,
             car          TYPE c LENGTH 20,
             is_available TYPE abap_boolean,
           END OF rental_car_struc,
           rental_car_tab_type TYPE TABLE OF rental_car_struc WITH EMPTY KEY.

    METHODS get_rental_cars
      IMPORTING
        city               TYPE string
        arrival            TYPE d
        departure          TYPE  d
      RETURNING
        VALUE(rental_cars) TYPE rental_car_tab_type.
    CLASS-METHODS class_constructor.
  PRIVATE SECTION.
    CLASS-DATA rental_car_tab TYPE rental_car_tab_type.
    TYPES: BEGIN OF rental_car_struc_availability,
             city             TYPE c LENGTH 20,
             car              TYPE c LENGTH 20,
             unavailable_date TYPE d,
           END OF rental_car_struc_availability,
           rent_car_tab_availability_type TYPE TABLE OF rental_car_struc_availability WITH EMPTY KEY.
    CLASS-DATA rental_car_availability_tab TYPE rent_car_tab_availability_type.
    DATA date_tab TYPE TABLE OF d WITH EMPTY KEY.
    DATA flag TYPE abap_boolean.
ENDCLASS.

CLASS lcl_rental_car_retrieval IMPLEMENTATION.
  METHOD get_rental_cars.
    SELECT * FROM @rental_car_availability_tab AS tab
      WHERE city = @city
      INTO TABLE @DATA(rental_car_list).

    LOOP AT rental_car_list INTO DATA(waf) GROUP BY ( key = waf-car ) ASCENDING INTO DATA(keyf).
      LOOP AT GROUP keyf INTO DATA(memberf).
        APPEND memberf-unavailable_date TO date_tab.
      ENDLOOP.

      LOOP AT date_tab INTO DATA(date).
        IF date &gt;= arrival AND date &lt;= departure.
          flag = abap_false.
          EXIT.
        ELSE.
          flag = abap_true.
        ENDIF.
      ENDLOOP.

      IF flag = abap_true.
        APPEND VALUE #( city = memberf-city car = memberf-car is_available = abap_true ) TO rental_cars.
      ENDIF.

      CLEAR flag.
      CLEAR date_tab.
    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    rental_car_availability_tab = VALUE #(
      ( city = &#x27;Frankfurt&#x27; car = &#x27;Car 1&#x27; unavailable_date = &#x27;20250512&#x27; )
      ( city = &#x27;Frankfurt&#x27; car = &#x27;Car 1&#x27; unavailable_date = &#x27;20250612&#x27; )
      ( city = &#x27;Frankfurt&#x27; car = &#x27;Car 2&#x27; unavailable_date = &#x27;20250512&#x27; )
      ( city = &#x27;Frankfurt&#x27; car = &#x27;Car 2&#x27; unavailable_date = &#x27;20250712&#x27; )
      ( city = &#x27;Frankfurt&#x27; car = &#x27;Car 3&#x27; unavailable_date = &#x27;20250512&#x27; )
      ( city = &#x27;Frankfurt&#x27; car = &#x27;Car 3&#x27; unavailable_date = &#x27;20250812&#x27; )
      ( city = &#x27;Shanghai&#x27; car = &#x27;Car 4&#x27; unavailable_date = &#x27;20250512&#x27; )
      ( city = &#x27;Shanghai&#x27; car = &#x27;Car 4&#x27; unavailable_date = &#x27;20250612&#x27; )
      ( city = &#x27;Shanghai&#x27; car = &#x27;Car 5&#x27; unavailable_date = &#x27;20250607&#x27; )
      ( city = &#x27;Shanghai&#x27; car = &#x27;Car 5&#x27; unavailable_date = &#x27;20250712&#x27; )
      ( city = &#x27;Shanghai&#x27; car = &#x27;Car 5&#x27; unavailable_date = &#x27;20250812&#x27; )
      ( city = &#x27;Shanghai&#x27; car = &#x27;Car 6&#x27; unavailable_date = &#x27;20250912&#x27; )
      ( city = &#x27;Shanghai&#x27; car = &#x27;Car 6&#x27; unavailable_date = &#x27;20251012&#x27; ) ).
  ENDMETHOD.
ENDCLASS.

&quot;An object of the lcl_rental_car_search class is required for searching rental cars. This object is
&quot;created by the facade class. The lcl_rental_car_search class implementation includes the calling
&quot;of a method of the lcl_rental_car_retrieval class to retrieve a list of available rental cars.
CLASS lcl_rental_car_search DEFINITION.
  PUBLIC SECTION.
    METHODS search_rental_car
      IMPORTING
        destination            TYPE string
        arrival                TYPE d
        departure              TYPE d
      RETURNING
        VALUE(rental_car_list) TYPE string_table.
ENDCLASS.

CLASS lcl_rental_car_search IMPLEMENTATION.
  METHOD search_rental_car.
    DATA(rental_car_obj) = NEW lcl_rental_car_retrieval( ).
    DATA(res) = rental_car_obj-&gt;get_rental_cars(
                  city      = destination
                  arrival   = arrival
                  departure = departure ).

    IF res IS INITIAL.
      APPEND |X  \| There&#x27;s no rental car available in { destination } during your trip from { arrival } to { departure }.| TO rental_car_list.
    ELSE.
      LOOP AT res INTO DATA(rental_car_wa).
        APPEND |OK \| &quot;{ rental_car_wa-car }&quot; is available as rental car in { destination } during your trip from { arrival } to { departure }.| TO rental_car_list.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

&quot;Facade class that represents a simplified API, hiding the complexity from users and allowing
&quot;them to achieve desired results without dealing with and knowing about underlying complexities.
&quot;It includes various object creations and method calls.
CLASS lcl_travel_facade DEFINITION.
  PUBLIC SECTION.
    METHODS plan_travel
      IMPORTING
        from                       TYPE string
        to                         TYPE string
        arrival                    TYPE d
        departure                  TYPE d
      RETURNING
        VALUE(reservation_options) TYPE string_table.
ENDCLASS.

CLASS lcl_travel_facade IMPLEMENTATION.
  METHOD plan_travel.
    &quot;Abort proceeding with the example when the departure is before the arrival.
    IF departure &lt;= arrival.
      ASSERT 1 = 0.
    ENDIF.

    &quot;Creating multipled objects
    DATA(flight_search) = NEW lcl_flight_search( ).
    DATA(hotel_search) = NEW lcl_hotel_search( ).
    DATA(rental_car_search) = NEW lcl_rental_car_search( ).

    &quot;Adding travel search information to a string table for demonstration and output purposes
    APPEND |Travel options for: { from } - { to }, { arrival } - { departure }| TO reservation_options.
    DATA(flights) = flight_search-&gt;search_flights( from = from to = to arrival = arrival departure = departure ).
    APPEND `---------- FLIGHTS -----------------------------------------------------------------------------` TO reservation_options.
    APPEND LINES OF flights TO reservation_options.
    DATA(hotels) = hotel_search-&gt;search_hotel( destination = to arrival = arrival departure = departure  ).
    APPEND `---------- HOTELS ------------------------------------------------------------------------------` TO reservation_options.
    APPEND LINES OF hotels TO reservation_options.
    DATA(rental_cars) = rental_car_search-&gt;search_rental_car( destination = to arrival = arrival departure = departure ).
    APPEND `---------- RENTAL CARS -------------------------------------------------------------------------` TO reservation_options.
    APPEND LINES OF rental_cars TO reservation_options.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Factory Method</h2>
<ul>
<li>Used, for example, to:</li>
<li>Provide users with an object of a class instead of them creating the objects themselves.</li>
<li>Control and simplify class instantiation for external users.</li>
<li>Offer a stable API for class users, so they only need to call one stable method. This way, the code may be modified or extended, and the changes to the class do not affect users.</li>
<li>Typically, using the <code>CREATE PRIVATE</code> addition in a class definition prevents object creation outside the class. A factory method, usually a static method, then supplies users with class objects. You can also include input parameters in the factory method to control instantiation.</li>
<li>Example of a predefined ABAP class with factory methods: <code>CL_ABAP_REGEX</code>.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>This example demonstrates the factory design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the <code>CCIMP</code> are relevant for the for conceptual considerations.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Defines the <code>lif_factory</code> interface, specifying a method that is implemented in all classes that implement the interface.</li>
<li>Contains multiple local classes (<code>lcl_**</code>) implementing <code>lif_factory</code>. Each class returns a string in its method.</li>
<li>Class <code>lcl_factory_cl</code> containing a factory method:</li>
<li>Defined as <code>CREATE PRIVATE</code> to prevent object creation outside the class.</li>
<li>Offers the <code>create_hello</code> factory method returning an interface reference. This method uses an input value to create the appropriate object, which the reference points to. Here, the input is an enumerated type that is defined in the interface.</li>
<li>The class execution includes the following:</li>
<li>Multiple objects are created using the factory method with different input parameters.</li>
<li>Based on the parameter, a specific object is created. The <code>say_hello</code> method will return a string as implemented in the resepctive class.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Saying hello in English
    DATA(oref_en) = lcl_factory_cl=&gt;create_hello( lif_factory=&gt;en ).
    DATA(hello_en) = oref_en-&gt;say_hello( ).
    out-&gt;write( hello_en ).

    &quot;Saying hello in French
    DATA(oref_fr) = lcl_factory_cl=&gt;create_hello( lif_factory=&gt;fr ).
    DATA(hello_fr) = oref_fr-&gt;say_hello( ).
    out-&gt;write( hello_fr ).

    &quot;Saying hello in Italian
    DATA(oref_it) = lcl_factory_cl=&gt;create_hello( lif_factory=&gt;it ).
    DATA(hello_it) = oref_it-&gt;say_hello( ).
    out-&gt;write( hello_it ).

    &quot;Saying hello in Spanish
    DATA(oref_es) = lcl_factory_cl=&gt;create_hello( lif_factory=&gt;es ).
    DATA(hello_es) = oref_es-&gt;say_hello( ).
    out-&gt;write( hello_es ).

    &quot;Saying hello in German
    DATA(oref_de) = lcl_factory_cl=&gt;create_hello( lif_factory=&gt;de ).
    DATA(hello_de) = oref_de-&gt;say_hello( ).
    out-&gt;write( hello_de ).

    &quot;Default hello
    DATA(oref_default) = lcl_factory_cl=&gt;create_hello( lif_factory=&gt;init ).
    DATA(hello_default) = oref_default-&gt;say_hello( ).
    out-&gt;write( hello_default ).

  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>INTERFACE lif_factory.
  TYPES: basetype TYPE i,
         BEGIN OF ENUM enum_langu BASE TYPE basetype,
           init VALUE IS INITIAL,
           en   VALUE 1,
           fr   VALUE 2,
           it   VALUE 3,
           es   VALUE 4,
           de   VALUE 5,
         END OF ENUM enum_langu.

  METHODS say_hello RETURNING VALUE(hi) TYPE string.
ENDINTERFACE.

CLASS lcl_en DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_factory.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_en IMPLEMENTATION.
  METHOD lif_factory~say_hello.
    hi = `Hi`.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_fr DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_factory.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_fr IMPLEMENTATION.
  METHOD lif_factory~say_hello.
    hi = `Salut`.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_it DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_factory.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_it IMPLEMENTATION.
  METHOD lif_factory~say_hello.
    hi = `Ciao`.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_es DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_factory.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_es IMPLEMENTATION.
  METHOD lif_factory~say_hello.
    hi = `Hola`.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_de DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES lif_factory.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_de IMPLEMENTATION.
  METHOD lif_factory~say_hello.
    hi = `Hallo`.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

CLASS lcl_factory_cl DEFINITION FINAL CREATE PRIVATE.

  PUBLIC SECTION.
    CLASS-METHODS create_hello IMPORTING language     TYPE lif_factory=&gt;enum_langu
                               RETURNING VALUE(hello) TYPE REF TO lif_factory.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_factory_cl IMPLEMENTATION.
  METHOD create_hello.
    hello = SWITCH #( language
                      WHEN lif_factory=&gt;en THEN NEW lcl_en( )
                      WHEN lif_factory=&gt;fr THEN NEW lcl_fr( )
                      WHEN lif_factory=&gt;it THEN NEW lcl_it( )
                      WHEN lif_factory=&gt;es THEN NEW lcl_es( )
                      WHEN lif_factory=&gt;de THEN NEW lcl_de( )
                      &quot;E.g. raising an exception or returning a default object
                      ELSE NEW lcl_en( ) ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Fluent Interface</h2>
<ul>
<li>Enables method chaining</li>
<li>Achieves method chaining by returning a reference to the current object. There may be variations in the implementation, for example, the returned object may be a modified copy or the modified original.</li>
<li>Such a design may consolidate method calls for a simpler, more readable code flow, instead of having individual method calls.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>This example demonstrates the fluent interface design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements <code>if_oo_adt_classrun</code> and calls methods from local classes.</li>
<li>Acts as a consumer of APIs (local classes) defined in the CCIMP include.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Example 1 (String building)</li>
<li>Local interface <code>lif_string_processing</code>:</li>
<li>Defines multiple methods for string modification</li>
<li>Most of the methods specify a reference to the interface as returning parameter</li>
<li>Local class <code>lcl_string_processing</code>:</li>
<li>Specifies the <code>CREATE PRIVATE</code> addition to prevent instantiation from outside the class</li>
<li>However, as <code>lcl_string</code> is declared as friend, <code>lcl_string</code> can instantiate the class.</li>
<li>Implements the interface</li>
<li>The method implementations return a modified copy of the original object</li>
<li>Local class <code>lcl_string</code>:</li>
<li>Contains a static factory method returning an instance of <code>lcl_string_processing</code> (the returning parameter is typed with <code>TYPE REF TO lif_string_processing</code>)</li>
<li>The factory method requires a string to be supplied, which represents the base string that can be modified using the methods that <code>lif_string_processing</code> offers</li>
<li>Example 2 (Simple calculations)</li>
<li>Local class <code>lcl_calc</code>:</li>
<li>Represents a simpler example of the fluent interface pattern</li>
<li>Instantiable class</li>
<li>Methods of the class return an object reference of the class</li>
<li>The class execution includes the following by demonstrating chained method calls:</li>
<li>Example 1: Multiple instances are created showing the variety of methods the interface offers for modifying a string (adding strings to strings, precedings strings with strings, splitting strings into a string table, performing replacements, transforming to lowercase and uppercase, reversing strings, inserting strings, removing spaces, retrieving the modified string)</li>
<li>Example 2: Multiple instances are created performing consecutive calculations; note that there is no proper exception handling in the simple example (e.g. a zero division is just ignored)</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;---------------------------------------------------------------------*
*&amp; Example 1
*&amp;---------------------------------------------------------------------*

    &quot;Adding strings
    &quot;Retrieving the resulting string using the attribute &#x27;str&#x27;
    DATA(str1) = lcl_string=&gt;string( `Lorem` )-&gt;add( ` ` )-&gt;add( `ipsum` )-&gt;str.

    &quot;Instead of extra method calls using the reference variable
    DATA(str1b_ref) = lcl_string=&gt;string( `Lorem` ).
    str1b_ref-&gt;add( ` ` ).
    str1b_ref-&gt;add( `ipsum` ).
    DATA(str1b) = str1b_ref-&gt;str.

    &quot;Retrieving the resulting string using the method &#x27;get_string&#x27;
    DATA(str2) = lcl_string=&gt;string( `Lorem` )-&gt;add( ` ` )-&gt;add( `ipsum` )-&gt;add( ` ` )-&gt;add( `dolor` )-&gt;add( ` ` )-&gt;add( `sit` )-&gt;add( ` ` )-&gt;add( `amet` )-&gt;get_string( ).

    &quot;Preceding strings
    DATA(str3) = lcl_string=&gt;string( `world` )-&gt;precede( ` ` )-&gt;precede( `Hello` )-&gt;str.
    DATA(str4) = lcl_string=&gt;string( `B` )-&gt;add( `A` )-&gt;precede( `A` )-&gt;add( `P` )-&gt;str.

    &quot;Splitting into string table
    DATA(tab1) = lcl_string=&gt;string( `Lorem` )-&gt;add( `#` )-&gt;add( `ipsum` )-&gt;add( `#` )-&gt;add( `dolor` )-&gt;add( `#` )-&gt;add( `sit` )-&gt;add( `#` )-&gt;add( `amet` )-&gt;split_into_table( `#` ).
    DATA(tab2) = lcl_string=&gt;string( `Lorem` )-&gt;add( ` ` )-&gt;add( `ipsum` )-&gt;split_into_table( ` ` ).

    &quot;Replacements
    DATA(str5) = lcl_string=&gt;string( `Lorem#ipsum#dolor#sit#amet` )-&gt;replace_all( sub = `#` with = ` ` )-&gt;str.
    DATA(str6) = lcl_string=&gt;string( `Lorem#ipsum#dolor#sit#amet` )-&gt;replace_occ( sub = `#` with = ` ` occ = 1 )-&gt;str.
    DATA(str7) = lcl_string=&gt;string( `Lorem#ipsum#dolor#sit#amet` )-&gt;replace_occ( sub = `#` with = ` ` occ = 2 )-&gt;str.
    DATA(str8) = lcl_string=&gt;string( `Lorem#ipsum#dolor#sit#amet` )-&gt;replace_occ( sub = `#` with = ` ` occ = -2 )-&gt;str.
    DATA(tab3) = lcl_string=&gt;string( `hello` )-&gt;add( `#` )-&gt;add( `world` )-&gt;replace_all( sub = `#` with = `,` )-&gt;split_into_table( `,` ).

    &quot;Transforming to lowercase and uppercase
    DATA(str9) = lcl_string=&gt;string( `ab` )-&gt;add( `ap` )-&gt;uppercase( )-&gt;str.
    DATA(str10) = lcl_string=&gt;string( `AP` )-&gt;precede( `AB` )-&gt;lowercase( )-&gt;str.
    DATA(str11) = lcl_string=&gt;string( `AB` )-&gt;lowercase( )-&gt;add( `ap` )-&gt;uppercase( )-&gt;str. &quot;First lowercasing overridden

    &quot;Reversing string
    DATA(str12) = lcl_string=&gt;string( `OLL` )-&gt;add( `AH` )-&gt;lowercase( )-&gt;reverse_string( )-&gt;str.

    &quot;Inserting string
    DATA(str13) = lcl_string=&gt;string( `abcghi` )-&gt;insert_string( string = `def` off = 3 )-&gt;str.
    DATA(str14) = lcl_string=&gt;string( `vwxyz` )-&gt;insert_string( string = `stu` off = 0 )-&gt;str.

    &quot;Removing spaces
    &quot;All spaces
    DATA(str15) = lcl_string=&gt;string( ` a b  c` )-&gt;add( ` d  e   f     gh i   ` )-&gt;remove_all_spaces( )-&gt;str.
    &quot;Leading and trailing spaces
    DATA(str16) = lcl_string=&gt;string( `      ab c d   e f     g   h i     ` )-&gt;remove_leading_trailing_spaces( )-&gt;str.
    DATA(str17) = lcl_string=&gt;string( `abc     ` )-&gt;remove_leading_trailing_spaces( )-&gt;add( `def` )-&gt;str.

    &quot;Displaying results in the console
    out-&gt;write( data = str1 name = `str1` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str1b name = `str1b` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str2 name = `str2` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str3 name = `str3` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str4 name = `str4` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = tab1 name = `tab1` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = tab2 name = `tab2` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str5 name = `str5` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str6 name = `str6` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str7 name = `str7` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str8 name = `str8` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = tab3 name = `tab3` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str9 name = `str9` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str10 name = `str10` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str11 name = `str11` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str12 name = `str12` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str13 name = `str13` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str14 name = `str14` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str15 name = `str15` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str16 name = `str16` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = str17 name = `str17` ).
    out-&gt;write( |\n| ).

**********************************************************************

*&amp;---------------------------------------------------------------------*
*&amp; Example 2
*&amp;---------------------------------------------------------------------*

    DATA(calc1) = NEW lcl_calc( 1 )-&gt;plus( 2 )-&gt;get_result( ).
    DATA(calc2) = NEW lcl_calc( 1 )-&gt;minus( 2 )-&gt;get_result( ).
    DATA(calc3) = NEW lcl_calc( 5 )-&gt;plus( 2 )-&gt;minus( 1 )-&gt;multiply( 3 )-&gt;get_result( ).
    DATA(calc4) = NEW lcl_calc( 10 )-&gt;multiply( 10 )-&gt;divide( 2 )-&gt;get_result( ).
    DATA(calc5) = NEW lcl_calc( 0 )-&gt;plus( 1 )-&gt;divide( 5 )-&gt;get_result( ).
    DATA(calc6) = NEW lcl_calc( &#x27;1.2&#x27; )-&gt;plus( &#x27;1.4&#x27; )-&gt;minus( &#x27;0.1&#x27; )-&gt;multiply( &#x27;2.5&#x27; )-&gt;divide( 2 )-&gt;get_result( ).

    &quot;Arithmetic errors are just ignored in the example
    DATA(calc7) = NEW lcl_calc( 1 )-&gt;divide( 0 )-&gt;plus( 1 )-&gt;get_result( ).

    &quot;Method chaining with a standalone statements
    NEW lcl_calc( 1 )-&gt;plus( 2 )-&gt;multiply( 5 )-&gt;minus( 5 )-&gt;divide( 2 )-&gt;get_result( RECEIVING result = DATA(calc8) ).

    IF NEW lcl_calc( 1 )-&gt;plus( 2 )-&gt;minus( 3 )-&gt;plus( 4 )-&gt;minus( 5 )-&gt;get_result( ) &lt;= 0.
      DATA(if_statement) = `The result is equal to or lower than 0`.
    ELSE.
      if_statement = `The result is greater than 0`.
    ENDIF.

    out-&gt;write( data = calc1 name = `calc1` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = calc2 name = `calc2` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = calc3 name = `calc3` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = calc3 name = `calc3` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = calc4 name = `calc4` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = calc5 name = `calc5` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = calc6 name = `calc6` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = calc7 name = `calc7` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = calc8 name = `calc8` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = if_statement name = `if_statement` ).

  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Example 1
*&amp;---------------------------------------------------------------------*

INTERFACE lif_string_processing.
  DATA str TYPE string READ-ONLY.
  METHODS add IMPORTING string     TYPE clike
              RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS precede IMPORTING string     TYPE clike
                  RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS replace_all IMPORTING sub        TYPE clike
                                with       TYPE clike
                      RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS replace_occ IMPORTING sub        TYPE clike
                                with       TYPE clike
                                occ        TYPE i DEFAULT 1
                      RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS lowercase RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS uppercase RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS remove_leading_trailing_spaces RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS remove_all_spaces RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS reverse_string RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS insert_string IMPORTING string     TYPE clike
                                  off        TYPE i
                        RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  METHODS get_string RETURNING VALUE(str) TYPE string.
  METHODS split_into_table IMPORTING split_at   TYPE clike
                           RETURNING VALUE(tab) TYPE string_table.
ENDINTERFACE.

CLASS lcl_string DEFINITION DEFERRED.
CLASS lcl_string_processing DEFINITION FINAL CREATE PRIVATE FRIENDS lcl_string.
  PUBLIC SECTION.
    INTERFACES lif_string_processing.
    ALIASES: add FOR lif_string_processing~add,
             get_string FOR lif_string_processing~get_string,
             insert_string FOR lif_string_processing~insert_string,
             precede FOR lif_string_processing~precede,
             remove_all_spaces FOR lif_string_processing~remove_all_spaces,
             remove_leading_trailing_spaces FOR lif_string_processing~remove_leading_trailing_spaces,
             replace_all FOR lif_string_processing~replace_all,
             replace_occ FOR lif_string_processing~replace_occ,
             reverse_string FOR lif_string_processing~reverse_string,
             split_into_table FOR lif_string_processing~split_into_table,
             lowercase FOR lif_string_processing~lowercase,
             uppercase FOR lif_string_processing~uppercase.
  PROTECTED SECTION.
  PRIVATE SECTION.
    ALIASES string_content FOR lif_string_processing~str.
    METHODS constructor IMPORTING content TYPE string.
    DATA oref TYPE REF TO lcl_string_processing.
ENDCLASS.

CLASS lcl_string_processing IMPLEMENTATION.
  METHOD add.
    oref-&gt;string_content &amp;&amp;= string.
    ref = oref.
  ENDMETHOD.

  METHOD get_string.
    str = oref-&gt;string_content.
  ENDMETHOD.

  METHOD insert_string.
    TRY.
        oref-&gt;string_content = insert( val = oref-&gt;string_content sub = string off = off ).
      CATCH cx_sy_range_out_of_bounds.
    ENDTRY.
    ref = oref.
  ENDMETHOD.

  METHOD precede.
    oref-&gt;string_content = string &amp;&amp; oref-&gt;string_content.
    ref = oref.
  ENDMETHOD.

  METHOD remove_all_spaces.
    oref-&gt;string_content = condense( val = oref-&gt;string_content to = `` ).
    ref = oref.
  ENDMETHOD.

  METHOD remove_leading_trailing_spaces.
    oref-&gt;string_content = condense( val = oref-&gt;string_content from = `` ).
    ref = oref.
  ENDMETHOD.

  METHOD replace_all.
    oref-&gt;string_content = replace( val = oref-&gt;string_content sub = sub with = with  occ = 0 ).
    ref = oref.
  ENDMETHOD.

  METHOD replace_occ.
    oref-&gt;string_content = replace( val = oref-&gt;string_content sub = sub with = with occ = occ ).
    ref = oref.
  ENDMETHOD.

  METHOD reverse_string.
    oref-&gt;string_content = reverse( oref-&gt;string_content ).
    ref = oref.
  ENDMETHOD.

  METHOD split_into_table.
    SPLIT oref-&gt;string_content AT split_at INTO TABLE tab.
  ENDMETHOD.

  METHOD lowercase.
    oref-&gt;string_content = to_lower( oref-&gt;string_content ).
    ref = oref.
  ENDMETHOD.

  METHOD uppercase.
    oref-&gt;string_content = to_upper( oref-&gt;string_content ).
    ref = oref.
  ENDMETHOD.

  METHOD constructor.
    string_content = content.
    oref = me.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_string DEFINITION FINAL CREATE PRIVATE FRIENDS lcl_string_processing.
  PUBLIC SECTION.
    CLASS-METHODS string IMPORTING string     TYPE clike
                         RETURNING VALUE(ref) TYPE REF TO lif_string_processing.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_string IMPLEMENTATION.
  METHOD string.
    ref = NEW lcl_string_processing( string ).
  ENDMETHOD.
ENDCLASS.

**********************************************************************

*&amp;---------------------------------------------------------------------*
*&amp; Example 2
*&amp;---------------------------------------------------------------------*

CLASS lcl_calc DEFINITION FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS constructor IMPORTING num TYPE decfloat34.
    METHODS plus IMPORTING num        TYPE decfloat34
                 RETURNING VALUE(ref) TYPE REF TO lcl_calc.
    METHODS minus IMPORTING num        TYPE decfloat34
                  RETURNING VALUE(ref) TYPE REF TO lcl_calc.
    METHODS multiply IMPORTING num        TYPE decfloat34
                     RETURNING VALUE(ref) TYPE REF TO lcl_calc.
    METHODS divide IMPORTING num        TYPE decfloat34
                   RETURNING VALUE(ref) TYPE REF TO lcl_calc.
    METHODS get_result RETURNING VALUE(result) TYPE decfloat34.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA number TYPE decfloat34.
ENDCLASS.

CLASS lcl_calc IMPLEMENTATION.
  METHOD constructor.
    number = num.
  ENDMETHOD.

  METHOD divide.
    TRY.
        number /= num.
      CATCH cx_sy_arithmetic_error.
    ENDTRY.
    ref = me.
  ENDMETHOD.

  METHOD minus.
    TRY.
        number -= num.
      CATCH cx_sy_arithmetic_error.
    ENDTRY.
    ref = me.
  ENDMETHOD.

  METHOD multiply.
    TRY.
        number *= num.
      CATCH cx_sy_arithmetic_error.
    ENDTRY.
    ref = me.
  ENDMETHOD.

  METHOD plus.
    TRY.
        number += num.
      CATCH cx_sy_arithmetic_error.
    ENDTRY.
    ref = me.
  ENDMETHOD.

  METHOD get_result.
    result = number.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Flyweight</h2>
<ul>
<li>The flyweight design pattern may be useful when you have a large number of objects that share similar data. For example, these objects might have both unique and shared components. The idea behind the pattern is to avoid duplicating the shared components in each object by separating them for reuse. Such an approach can reduce the number of objects needed and reduce memory consumption.</li>
<li>A potential setup, illustrated in the following example, may look like this:</li>
<li>A flyweight interface that defines methods for processing shared parts.</li>
<li>A concrete flyweight class that implements the interface to handle shared parts. Objects of this class represent shareable objects and contain the shared data.</li>
<li>A flyweight factory class that manages existing flyweight objects with the shared data in an internal table. If a flyweight object is requested by the client, the table is searched, and if found, the object is returned. If a flyweight object does not yet exist, a new object is created, added to the internal table, and returned.</li>
<li>The client uses the flyweight objects through the flyweight factory and passes unique states.</li>
</ul>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example demonstrates the flyweight design pattern through the following declarations and implementations. Note that the example is simplified, and various class setup strategies may apply.</li>
<li>The context of this hypothetical example is as follows:</li>
<li>There are many customers, each of whom can have an object created for them. Depending on events - such as subscriptions, orders, New Year, ect. - each customer should receive a specific message. Hypothetically, another event object is created for this purpose and for each customer, but the event objects (the messages) are identical across all customers and stay consistent. Customer object and such an event/message object go together so that specific messages can be sent for specific customers. The trivial example uses simple strings, but it is assumed that the objects to be created involve large data sets and consume a considerable amount of memory.</li>
<li>In this context, the message represents the shared data (as it can be reused for all customers), while customer-specific information (such as ID, name, and email) constitutes the unique data. In this example, the notification is represented by filling a string table.</li>
<li>Instead of creating separate objects for each customer and event, reusable data like the notification message for different events is stored in flyweight objects.</li>
<li>When a client wants to trigger a notification for a specific customer regarding an event, it is first checked whether a flyweight object containing the shared data already exists. If it does, the existing object is returned and used instead of creating a duplicate. Otherwise, a new flyweight object is created, added to a reference storage (an internal table), and returned.</li>
<li>Global class (<em>Global Class</em> tab in ADT):</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Acts as the client to demonstrate the design pattern. The declarations and implementations in the <em>CCIMP include</em> are relevant for conceptual considerations.</li>
<li>The client requests flyweight objects via the factory class, and provides unique states to the method that handles the unique and shared data.</li>
<li>CCIMP include (<em>Local Types</em> tab in ADT):</li>
<li>Interface <code>lif_flyweight</code>:</li>
<li>Defines the common interface for concrete flyweight classes.</li>
<li>Includes the <code>notify</code> method for flyweight classes to implement, which accepts a reference to a customer object and returns text in a string table.</li>
<li>Class <code>lcl_customer</code>:</li>
<li>Holds the unique state of each customer.</li>
<li>The <code>get_customer_info</code> method retrieves unique customer information that is to be connected with the shared data, with the <code>customer_info</code> attribute storing detailed customer information.</li>
<li>Class <code>lcl_flyweight</code>:</li>
<li>Represents concrete flyweight objects.</li>
<li>Implements the <code>lif_flyweight</code> interface.</li>
<li>Holds shared data via the <code>text</code> attribute and processes notifications through the <code>notify</code> method.</li>
<li>Class <code>lcl_flyweight_factory</code>:</li>
<li>Provides access to flyweight objects stored in an internal table (<code>flyweight_tab</code>).</li>
<li>Checks for existing flyweight objects. If one exists, it returns that object to ensure reuse. Otherwise, it creates a new object, adds it to the internal table, and returns it.</li>
<li>The example includes the filling of a log table, indicating whether a flyweight object is created or reused.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.

    TYPES: BEGIN OF ts_customer_info,
             customer_id TYPE i,
             name        TYPE c LENGTH 30,
             email       TYPE c LENGTH 30,
             birthday    TYPE d,
             address     TYPE c LENGTH 50,
           END OF ts_customer_info.

    CLASS-METHODS class_constructor.

    CLASS-DATA: customer_data TYPE TABLE OF ts_customer_info WITH EMPTY KEY,
                log           TYPE string_table.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    DATA(customer_a) = NEW lcl_customer( 1 ).

    DATA(fw_a) = lcl_flyweight_factory=&gt;get_flyweight_object( `SIGNUP` ).
    DATA(msg_a) = fw_a-&gt;notify( customer_a ).
    out-&gt;write( data = msg_a name = `msg_a` ).
    out-&gt;write( |\n| ).

    DATA(customer_b) = NEW lcl_customer( 2 ).
    DATA(fw_b) = lcl_flyweight_factory=&gt;get_flyweight_object( `SIGNUP` ).
    DATA(msg_b) = fw_b-&gt;notify( customer_b ).
    out-&gt;write( data = msg_b name = `msg_b` ).
    out-&gt;write( |\n| ).

    DATA(fw_c) = lcl_flyweight_factory=&gt;get_flyweight_object( `SIGNUP` ).
    DATA(msg_c) = fw_c-&gt;notify( NEW lcl_customer( 3 ) ).
    out-&gt;write( data = msg_c name = `msg_c` ).
    out-&gt;write( |\n| ).

    DATA(fw_d) = lcl_flyweight_factory=&gt;get_flyweight_object( `ORDER` ).
    DATA(msg_d) = fw_d-&gt;notify( customer_a ).
    out-&gt;write( data = msg_d name = `msg_d` ).
    out-&gt;write( |\n| ).

    DATA(fw_e) = lcl_flyweight_factory=&gt;get_flyweight_object( `ORDER` ).
    DATA(msg_e) = fw_e-&gt;notify( customer_b ).
    out-&gt;write( data = msg_e name = `msg_e` ).
    out-&gt;write( |\n| ).

    &quot;Displaying log table
    out-&gt;write( log ).
    out-&gt;write( |\n| ).

    CLEAR log.

    &quot;Checking out all events in the example
    DATA(event_tab) = VALUE string_table( ( `SIGNUP` )
                                          ( `ORDER` )
                                          ( `SHIPPING` )
                                          ( `NEW_YEAR` ) ).

    DATA msg_tab TYPE string_table.

    LOOP AT event_tab INTO DATA(evt).
      DO lines( customer_data ) TIMES.
        DATA(fw) = lcl_flyweight_factory=&gt;get_flyweight_object( evt ).
        DATA(msg) = fw-&gt;notify( NEW lcl_customer( sy-index ) ).

        APPEND |-------------------- Example for event &quot;{ evt }&quot;, customer ID &quot;{ sy-index }&quot; --------------------| TO msg_tab.
        APPEND LINES OF msg TO msg_tab.
        APPEND INITIAL LINE TO msg_tab.
      ENDDO.
    ENDLOOP.

    out-&gt;write( data = msg_tab name = `msg_tab` ).

    &quot;Displaying log table
    out-&gt;write( log ).
  ENDMETHOD.

  METHOD class_constructor.
    customer_data = VALUE #(
      ( customer_id = 1 name = &#x27;Jon Doe&#x27;       email = &#x27;jon_doe@example.com&#x27;      birthday = &#x27;19801101&#x27; address = &#x27;Some Street 1, London&#x27; )
      ( customer_id = 2 name = &#x27;Jane Smith&#x27;    email = &#x27;jane_smith@example.com&#x27;   birthday = &#x27;19900515&#x27; address = &#x27;Another Ave 2, New York&#x27; )
      ( customer_id = 3 name = &#x27;Alice Brown&#x27;   email = &#x27;alice_brown@example.com&#x27;  birthday = &#x27;19870322&#x27; address = &#x27;Red Road 3, Sydney&#x27; )
      ( customer_id = 4 name = &#x27;Bob White&#x27;     email = &#x27;bob_white@example.com&#x27;    birthday = &#x27;19751230&#x27; address = &#x27;Blue Blvd 4, Paris&#x27; )
      ( customer_id = 5 name = &#x27;Charlie Black&#x27; email = &#x27;charlie_black@example.com&#x27; birthday = &#x27;19991111&#x27; address = &#x27;Green Street 5, Berlin&#x27; )
      ( customer_id = 6 name = &#x27;Diana Green&#x27;   email = &#x27;diana_green@example.com&#x27;  birthday = &#x27;19860418&#x27; address = &#x27;Yellow Lane 6, Tokyo&#x27; )
      ( customer_id = 7 name = &#x27;Edward King&#x27;   email = &#x27;edward_king@example.com&#x27;  birthday = &#x27;19930708&#x27; address = &#x27;High Street 7, Toronto&#x27; )
      ( customer_id = 8 name = &#x27;Fiona Blue&#x27;    email = &#x27;fiona_blue@example.com&#x27;   birthday = &#x27;19820114&#x27; address = &#x27;Blue Water 8, Auckland&#x27; )
      ( customer_id = 9 name = &#x27;George Gray&#x27;   email = &#x27;george_gray@example.com&#x27;  birthday = &#x27;19790925&#x27; address = &#x27;Gray Path 9, Mumbai&#x27; )
      ( customer_id = 10 name = &#x27;Hannah Gold&#x27;  email = &#x27;hannah_gold@example.com&#x27;  birthday = &#x27;19881208&#x27; address = &#x27;Golden Street 10, Cairo&#x27; ) ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl_customer DEFINITION DEFERRED.

*&amp;---------------------------------------------------------------------*
*&amp; Flyweight interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_flyweight.
  METHODS notify IMPORTING customer_ref TYPE REF TO lcl_customer
                 RETURNING VALUE(msg)   TYPE string_table.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Class for holding a unique state
*&amp;---------------------------------------------------------------------*

CLASS lcl_customer DEFINITION.
  PUBLIC SECTION.
    METHODS: constructor IMPORTING id TYPE i,
      get_customer_info RETURNING VALUE(customer_info) TYPE zcl_demo_abap=&gt;ts_customer_info.
  PRIVATE SECTION.
    DATA: customer_info TYPE zcl_demo_abap=&gt;ts_customer_info,
          msg           TYPE string_table.
ENDCLASS.

CLASS lcl_customer IMPLEMENTATION.
  METHOD constructor.
    &quot;For the self-contained example, the customer data, representing
    &quot;the unique data, is designed as content of an internal table.
    &quot;Based on an ID, the customer data is retrieved.
    SELECT SINGLE *
      FROM @zcl_demo_abap=&gt;customer_data AS tab
      WHERE customer_id = @id
      INTO @customer_info.

    &quot;For simplicity, this example only covers the best case
    &quot;scenario where actual data is avaialble.
    IF customer_info IS INITIAL.
      ASSERT 1 = 0.
    ENDIF.
  ENDMETHOD.

  METHOD get_customer_info.
    customer_info = me-&gt;customer_info.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete flyweight class
*&amp;---------------------------------------------------------------------*

CLASS lcl_flyweight DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES lif_flyweight.
    METHODS constructor IMPORTING text TYPE string.
  PRIVATE SECTION.
    DATA text TYPE string.
ENDCLASS.

CLASS lcl_flyweight IMPLEMENTATION.
  METHOD constructor.
    me-&gt;text = text.
  ENDMETHOD.

  METHOD lif_flyweight~notify.
    DATA(customer_info) = customer_ref-&gt;get_customer_info( ).

    msg = VALUE #( ( |Hallo, { customer_info-name }. { me-&gt;text }| )
                   ( |Customer info: ID: { customer_info-customer_id }, Name: { customer_info-name }, Birthday: { customer_info-birthday }, | &amp;&amp;
                     |Address: { customer_info-address }, Email: { customer_info-email }| ) ).
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Flyweight factory class
*&amp;---------------------------------------------------------------------*

CLASS lcl_flyweight_factory DEFINITION FINAL CREATE PRIVATE.
  PUBLIC SECTION.
    CLASS-METHODS get_flyweight_object IMPORTING event      TYPE string
                                       RETURNING VALUE(obj) TYPE REF TO lif_flyweight.
  PRIVATE SECTION.
    TYPES: BEGIN OF ts_flyweight,
             evt    TYPE string,
             fw_obj TYPE REF TO lif_flyweight,
           END OF ts_flyweight,
           tt_flyweight TYPE HASHED TABLE OF ts_flyweight WITH UNIQUE KEY evt.
    CLASS-DATA flyweight_tab TYPE tt_flyweight.
ENDCLASS.

CLASS lcl_flyweight_factory IMPLEMENTATION.
  METHOD get_flyweight_object.
    READ TABLE flyweight_tab WITH TABLE KEY evt = event INTO DATA(wa).
    IF sy-subrc = 0.
      obj = wa-fw_obj.
      &quot;Adding information to a log table for display purposes.
      APPEND |Entry exists for key &quot;{ event }&quot;. Object reused.| TO zcl_demo_abap=&gt;log.
    ELSE.
      CASE event.
        WHEN `SIGNUP`.
          obj = NEW lcl_flyweight( text = `Thanks for signing up.` ).
        WHEN `ORDER`.
          obj = NEW lcl_flyweight( text = `Your order has been confirmed.` ).
        WHEN `SHIPPING`.
          obj = NEW lcl_flyweight( text = `Your order has been shipped.` ).
        WHEN `NEW_YEAR`.
          obj = NEW lcl_flyweight( text = `Happy New Year to you!` ).
        WHEN OTHERS.
          &quot;For simplicity, this example only covers the best case
          &quot;scenario where only supported events are processed.
          &quot;Here might go exception raising for unsupported events.
          ASSERT 1 = 0.
      ENDCASE.

      INSERT VALUE #( evt = event fw_obj = obj ) INTO TABLE flyweight_tab.

      &quot;Adding information to a log table for display purposes.
      APPEND |Entry does not exist for key &quot;{ event }&quot;. New object created and added to the internal table.| TO zcl_demo_abap=&gt;log.
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Iterator</h2>
<ul>
<li>The iterator design pattern may be useful for processing collections, represented by a group of objects, sequentially. It allows you to iterate across a group of objects without revealing internal details to the client or ensure that all objects of the collections are iterated (and, for example, avoid the processing of individual objects more than once).</li>
<li>A potential setup, illustrated in the following example, may look like this:</li>
<li>An iterator interface that defines operations for iterating across collections, such as retrieving individual elements, moving forward or backward, and checking for the end of the collection. The concrete iteration logic is implemented by concrete iterators that implement the interface. This approach enables flexible extension by adding new collections or iterators.</li>
<li>Concrete iterators that implement the iterator interface contain specific logic for processing objects of a collection. These iterators may be associated with collections by passing collections to their instance constructors.</li>
<li>A collection interface typically defines a method for creating/retrieving an iterator object linked to a specific concrete iterator.</li>
<li>Concrete collection classes that implement the collection interface and include the actual collection of objects. They implement the iterator retrieval method and provide themselves as collection object linked to the iterator.</li>
<li>Clients can retrieve the iterator and use it to iterate across the collection without concerning themselves with the internal details of the objects. They may also create items of the collections.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example code demonstrates the iterator design pattern by including the following declarations and implementations:</li>
<li>CCIMP include (<em>Local Types</em> tab in ADT):</li>
<li><code>lif_iterator</code></li>
<li>This interface defines the operations for iterators that implement it.</li>
<li>The interface includes the <code>get_next</code> and <code>get_previous</code> methods for iterating across collections. The <code>has_next</code> method checks for additional items to iterate over. The <code>get_current_position</code> method provides the current index, while <code>reset</code> returns to the start of the collection.</li>
<li><code>lif_collection</code></li>
<li>This interface specifies methods for managing collections.</li>
<li>The <code>get_iterator</code> method returns an iterator instance that allows access to the collection&#x27;s items.</li>
<li>Additionally, the <code>get_number_of_items</code> and <code>get_item_at_position</code> methods are included for further interaction options with collections.</li>
<li><code>lcl_iterator</code></li>
<li>This class implements the <code>lif_iterator</code> interface and represents an iterator.</li>
<li>In the example implementation, the instance constructor initializes the iterator, linking it to a specific collection.</li>
<li>It implements the methods of the <code>lif_iterator</code> interface, providing the logic to process the collection&#x27;s items.</li>
<li>The class is designed to support two sample implementations of concrete collections.</li>
<li><code>lcl_collection_strings</code>, <code>lcl_collection_line2string</code></li>
<li>Both classes represent concrete collections and implement the <code>lif_collection</code> interface.</li>
<li>The <code>get_iterator</code> method returns an instance of <code>lcl_iterator</code> linked to the respective collection.</li>
<li>In the simplified example, <code>lcl_collection_strings</code> holds a string table, which can be iterated. The class allows adding strings to the collection using the <code>add</code> method.</li>
<li><code>lcl_collection_line2string</code> requires an index table to be supplied via the instance constructor. This internal table is then iterated. The demo purpose of the example is to convert all table components to strings and return an entire table line as a comma-separated list. The implementation includes checks to ensure that all components are convertible to strings.</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as the client in the example. The client creates or supplies collections and retrieves iterators to iterate over the collection items.</li>
<li>The global class code demonstrates 3 example contexts:</li>
<li>Example 1: Demonstrates <code>lcl_collection_strings</code>. Several strings are added to the collection. The code shows various options the demo code offers, such as creating a collection, retrieving an iterator, retrieving the number of items in the collection, retrieving an item at a specific position, moving backward and forward within the collection, retrieving the current position, checking if there a more items to be processed, resetting, two separate iterators iterating across the same collection.</li>
<li>Example 2: Demonstrates <code>lcl_collection_line2string</code>. Some demo internal tables are created and supplied for iteration.</li>
<li>Example 3: Demonstrates a released ABAP class used for processing XML data. For more information, refer to the <em>Working with XML and JSON in ABAP</em> cheat sheet. The class reflects an iterator setup. In the example, XML data is created, processed, item names and values are output, reflecting the iteration process.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;---------------------------------------------------------------------*
*&amp; Example 1
*&amp;---------------------------------------------------------------------*

    out-&gt;write( `------------------------- Example 1 -------------------------` ).
    out-&gt;write( |\n| ).

    DATA: col       TYPE REF TO lcl_collection_strings,
          iterator  TYPE REF TO lif_iterator,
          iterator2 TYPE REF TO lif_iterator,
          item      TYPE string,
          position  TYPE i,
          count     TYPE i.

    &quot;Creating a collection and adding items
    col = NEW lcl_collection_strings( ).
    col-&gt;add( `lorem` ).
    col-&gt;add( `ipsum` ).
    col-&gt;add( `dolor` ).
    col-&gt;add( `sit` ).
    col-&gt;add( `amet` ).

    &quot;Checking the available methods
    &quot;Getting the number of items in the collection
    count = col-&gt;lif_collection~get_number_of_items( ).
    out-&gt;write( |Number of items in the collection: { count }| ).

    &quot;Getting an item from a specific position
    position = 2.
    item = col-&gt;lif_collection~get_item_at_position( position ).
    out-&gt;write( |Item at position { position }: &quot;{ item }&quot;| ).
    out-&gt;write( |\n| ).

    &quot;Getting an iterator for the collection
    iterator = col-&gt;lif_collection~get_iterator( ).

    &quot;Iterating accross the collection
    out-&gt;write( `Iterating accross the collection:` ).
    &quot;Performing the iteration as long as there are items to be processed
    WHILE iterator-&gt;has_next( ) = abap_true.
      &quot;Getting the next item
      item = iterator-&gt;get_next( ).
      &quot;Determining the current position
      position = iterator-&gt;get_current_position( ).
      out-&gt;write( |{ position } { item }| ).
    ENDWHILE.
    out-&gt;write( |\n| ).

    &quot;Checking the move backward and forward methods
    out-&gt;write( `Moving backward and forward:` ).

    item = iterator-&gt;get_previous( ).
    position  = iterator-&gt;get_current_position( ).
    out-&gt;write( |Move backward one step; position: &quot;{ position }&quot; item: &quot;{ item }&quot;| ).

    item = iterator-&gt;get_previous( ).
    position = iterator-&gt;get_current_position( ).
    out-&gt;write( |Move backward one step; position: &quot;{ position }&quot; item: &quot;{ item }&quot;| ).

    item = iterator-&gt;get_next( ).
    position  = iterator-&gt;get_current_position( ).
    out-&gt;write( |Move forward one step; position: &quot;{ position }&quot; item: &quot;{ item }&quot;| ).

    DO 3 TIMES.
      item = iterator-&gt;get_previous( ).
      position  = iterator-&gt;get_current_position( ).
      out-&gt;write( |Move backward one step; position: &quot;{ position }&quot; item: &quot;{ item }&quot;| ).
    ENDDO.

    item = iterator-&gt;get_next( ).
    position  = iterator-&gt;get_current_position( ).
    out-&gt;write( |Move forward one step; position: &quot;{ position }&quot; item: &quot;{ item }&quot;| ).

    out-&gt;write( |\n| ).

    &quot;Resetting the iteration
    out-&gt;write( `Reset:` ).
    iterator-&gt;reset( ).
    position = iterator-&gt;get_current_position( ).
    out-&gt;write( |Position after reset: &quot;{ position }&quot;| ).

    out-&gt;write( `Get next item after reset:` ).
    item = iterator-&gt;get_next( ).
    position = iterator-&gt;get_current_position( ).
    out-&gt;write( |{ position } { item }| ).
    out-&gt;write( |\n| ).

    &quot;Resetting and iterating
    out-&gt;write( `Iteration after reset:` ).
    iterator-&gt;reset( ).
    WHILE iterator-&gt;has_next( ) = abap_true.
      item = iterator-&gt;get_next( ).
      position = iterator-&gt;get_current_position( ).
      out-&gt;write( |{ position } { item }| ).
    ENDWHILE.
    out-&gt;write( |\n| ).

    &quot;Two separate iterators iterating across the same collection
    out-&gt;write( `Two separate iterators iterating across the same collection:` ).
    iterator  = col-&gt;lif_collection~get_iterator( ).
    iterator2 = col-&gt;lif_collection~get_iterator( ).

    &quot;Different movements
    iterator-&gt;get_next( ).
    iterator-&gt;get_next( ).
    iterator2-&gt;get_next( ).

    position = iterator-&gt;get_current_position( ).
    out-&gt;write( |First iterator, current position: { position }| ).

    position = iterator2-&gt;get_current_position( ).
    out-&gt;write( |Second iterator, current position: { position }| ).

    item = iterator-&gt;get_next( ).
    out-&gt;write( |First iterator, next element: &quot;{ item }&quot;| ).

    item = iterator2-&gt;get_next( ).
    out-&gt;write( |Second iterator, next element: &quot;{ item }&quot;| ).
    out-&gt;write( |\n| ).

    &quot;Unavailable position
    out-&gt;write( `Unavailable position:` ).
    position = 10.
    item = col-&gt;lif_collection~get_item_at_position( position ).
    out-&gt;write( |{ position } { item }| ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 2
*&amp;---------------------------------------------------------------------*

    out-&gt;write( |{ repeat( val = `*` occ = 100 ) }\n| ).
    out-&gt;write( `------------------------- Example 2 -------------------------` ).
    out-&gt;write( |\n| ).

    out-&gt;write( `--- itab1 --- ` ).
    out-&gt;write( |\n| ).

    TYPES: BEGIN OF struct,
             comp1 TYPE i,
             comp2 TYPE c LENGTH 3,
             comp3 TYPE string,
             comp4 TYPE n LENGTH 5,
           END OF struct,
           ty_tab TYPE TABLE OF struct WITH EMPTY KEY.

    DATA(itab1) = VALUE ty_tab( ( comp1 = 100 comp2 = &#x27;abc&#x27; comp3 = `hello` comp4 = &#x27;123&#x27; )
                                ( comp1 = 200 comp2 = &#x27;def&#x27; comp3 = `world` comp4 = &#x27;456&#x27; )
                                ( comp1 = 300 comp2 = &#x27;ghi&#x27; comp3 = `ABAP` comp4 = &#x27;789&#x27; )
                                ( comp1 = 400 comp2 = &#x27;jkl&#x27; comp3 = sy-uname comp4 = &#x27;12345&#x27; ) ).

    DATA(col_itab) = NEW lcl_collection_line2string( itab1 ).

    count = col_itab-&gt;lif_collection~get_number_of_items( ).
    out-&gt;write( |Number of items in the collection: { count }| ).

    position = 2.
    item = col_itab-&gt;lif_collection~get_item_at_position( position ).
    out-&gt;write( |Item at position { position }: { item }| ).
    out-&gt;write( |\n| ).

    &quot;Getting an iterator for  the collection
    iterator = col_itab-&gt;lif_collection~get_iterator( ).

    &quot;Iterating across the collection
    out-&gt;write( |Iterating across the collection| ).
    WHILE iterator-&gt;has_next( ) = abap_true.
      item = iterator-&gt;get_next( ).
      position  = iterator-&gt;get_current_position( ).
      out-&gt;write( |{ position } { item }| ).
    ENDWHILE.

    out-&gt;write( |\n| ).
    out-&gt;write( `--- itab2 --- ` ).
    out-&gt;write( |\n| ).

    &quot;Using an internal table with elementary line type
    DATA(itab2) = VALUE string_table( ( `hello` ) ( `world` ) ( `ABAP` ) ).

    col_itab = NEW lcl_collection_line2string( itab2 ).

    count = col_itab-&gt;lif_collection~get_number_of_items( ).
    out-&gt;write( |Number of items in the collection: { count }| ).

    position = 2.
    item = col_itab-&gt;lif_collection~get_item_at_position( position ).
    out-&gt;write( |Item at position { position }: { item }| ).
    out-&gt;write( |\n| ).

    &quot;Getting an iterator for the collection
    iterator = col_itab-&gt;lif_collection~get_iterator( ).

    &quot;Iterating across the collection
    out-&gt;write( |Iterating across the collection| ).
    WHILE iterator-&gt;has_next( ) = abap_true.
      item = iterator-&gt;get_next( ).
      position  = iterator-&gt;get_current_position( ).
      out-&gt;write( |{ position } { item }| ).
    ENDWHILE.
    out-&gt;write( |\n| ).

    out-&gt;write( `--- Internal tables not supported by the example --- ` ).
    out-&gt;write( |\n| ).
    out-&gt;write( `--- itab3 --- ` ).
    out-&gt;write( |\n| ).

    TYPES: BEGIN OF struct2,
             comp1 TYPE i,
             comp2 TYPE string_table,
           END OF struct2,
           ty_tab2 TYPE TABLE OF struct2 WITH EMPTY KEY.

    DATA(itab3) = VALUE ty_tab2( ( comp1 = 100  ) ).

    TRY.
        col_itab = NEW lcl_collection_line2string( itab3 ).
      CATCH lcx_error INTO DATA(err).
        out-&gt;write( err-&gt;get_text( ) ).
    ENDTRY.
    out-&gt;write( |\n| ).
    out-&gt;write( `--- itab4 --- ` ).
    out-&gt;write( |\n| ).

    TYPES ty_tab_data TYPE TABLE OF REF TO data.
    DATA itab4 TYPE ty_tab_data.
    APPEND REF string( `nope` ) TO itab4.

    TRY.
        col_itab = NEW lcl_collection_line2string( itab4 ).
      CATCH lcx_error INTO err.
        out-&gt;write( err-&gt;get_text( ) ).
    ENDTRY.
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 3
*&amp;---------------------------------------------------------------------*

    &quot;The following example demonstrates a released ABAP class, used for
    &quot;processing XML data. For more information, refer to the Working with
    &quot;XML and JSON in ABAP cheat sheet.
    &quot;The class reflects an iterator setup. XML data is processed, item
    &quot;names and values are added to a string table.

    out-&gt;write( |{ repeat( val = `*` occ = 100 ) }\n| ).
    out-&gt;write( `------------------------- Example 3 -------------------------` ).
    out-&gt;write( |\n\n| ).

    &quot;Demo XML data
    DATA(some_xml) = cl_abap_conv_codepage=&gt;create_out( )-&gt;convert(
          `&lt;?xml version=&quot;1.0&quot;?&gt;` &amp;&amp;
          `&lt;node&gt;` &amp;&amp;
          ` &lt;subnode1&gt;` &amp;&amp;
          `  &lt;hallo&gt;hi&lt;/hallo&gt;` &amp;&amp;
          ` &lt;/subnode1&gt;` &amp;&amp;
          ` &lt;subnode2&gt;` &amp;&amp;
          `  &lt;letter&gt;a&lt;/letter&gt;` &amp;&amp;
          `  &lt;date&gt;01-01-2025&lt;/date&gt;` &amp;&amp;
          ` &lt;/subnode2&gt;` &amp;&amp;
          ` &lt;subnode3&gt;`  &amp;&amp;
          `  &lt;text&gt;abc&lt;/text&gt;` &amp;&amp;
          `  &lt;text&gt;def&lt;/text&gt;` &amp;&amp;
          `  &lt;text&gt;ghi&lt;/text&gt;` &amp;&amp;
          `  &lt;text&gt;jkl&lt;/text&gt;` &amp;&amp;
          ` &lt;/subnode3&gt;` &amp;&amp;
          `&lt;/node&gt;` ).

    &quot;Creating one factory object of the access class cl_ixml_core using the
    &quot;create method. It is used to access the iXML library.
    DATA(ixml_pa) = cl_ixml_core=&gt;create( ).
    &quot;Creating an input stream that is used for the input of XML data
    DATA(stream_factory_pa) = ixml_pa-&gt;create_stream_factory( ).
    &quot;Creating an XML document stored in DOM format in the memory
    DATA(document_pa) = ixml_pa-&gt;create_document( ).
    &quot;Creating a parser. It requires the following input parameters: input stream to be parsed,
    &quot;the XML document to which the stream is parsed, a factory required to create a stream
    DATA(parser_pa) = ixml_pa-&gt;create_parser(
                        istream = stream_factory_pa-&gt;create_istream_xstring( string = some_xml )
                        document = document_pa
                        stream_factory = stream_factory_pa ).

    &quot;Parsing XML data to a DOM representation in one go. It is put in the memory.
    &quot;Note: You can also parse sequentially, and not in one go.
    DATA(parsing_check) = parser_pa-&gt;parse( ).
    IF parsing_check = 0.
      &quot;Creating an iterator
      DATA(iterator_pa) = document_pa-&gt;create_iterator( ).

      &quot;For the iteration, you can use the get_next method to process the nodes one after another.
      DATA(node_pa) = iterator_pa-&gt;get_next( ).

      WHILE NOT node_pa IS INITIAL.
        DATA(node_type) = node_pa-&gt;get_type( ).
        CASE node_type.
          WHEN if_ixml_node=&gt;co_node_element.
            out-&gt;write( |Element: &quot;{ node_pa-&gt;get_name( ) }&quot;| ).
          WHEN if_ixml_node=&gt;co_node_text OR if_ixml_node=&gt;co_node_cdata_section.
            out-&gt;write( |Text: &quot;{ node_pa-&gt;get_value( ) }&quot;| ).
          WHEN OTHERS.
           ...
        ENDCASE.
        &quot;Retrieving the next node
        node_pa = iterator_pa-&gt;get_next( ).
      ENDWHILE.
    ELSE.
      out-&gt;write( `Parsing was not successful` ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Iterator interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_iterator.
  METHODS: get_next RETURNING VALUE(item) TYPE string,
    get_previous RETURNING VALUE(item) TYPE string,
    has_next RETURNING VALUE(has_next) TYPE abap_boolean,
    get_current_position RETURNING VALUE(position) TYPE i,
    reset.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Collection interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_collection.
  METHODS: get_iterator RETURNING VALUE(iterator) TYPE REF TO lif_iterator,
    get_number_of_items RETURNING VALUE(count) TYPE i,
    get_item_at_position IMPORTING idx         TYPE i
                         RETURNING VALUE(item) TYPE string.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete iterator
*&amp;---------------------------------------------------------------------*

CLASS lcl_iterator DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_iterator.
    METHODS constructor IMPORTING collection TYPE REF TO lif_collection.
  PRIVATE SECTION.
    DATA: coll  TYPE REF TO lif_collection,
          index TYPE i.
ENDCLASS.

CLASS lcl_iterator IMPLEMENTATION.
  METHOD constructor.
    coll = collection.
    index = 0.
  ENDMETHOD.

  METHOD lif_iterator~has_next.
    IF coll IS BOUND.
      DATA(num_items) = coll-&gt;get_number_of_items( ).
      has_next = xsdbool( index &lt; num_items ).
    ELSE.
      has_next = abap_false.
    ENDIF.
  ENDMETHOD.

  METHOD lif_iterator~get_next.
    IF coll IS NOT BOUND.
      item = ``.
      RETURN.
    ENDIF.
    IF lif_iterator~has_next( ) = abap_true.
      index += 1.
      item = coll-&gt;get_item_at_position( index ).
    ELSE.
      item = ``.
    ENDIF.
  ENDMETHOD.

  METHOD lif_iterator~get_previous.
    IF coll IS NOT BOUND OR index &lt;= 1.
      item = ``.
      RETURN.
    ENDIF.
    index -= 1.
    item = coll-&gt;get_item_at_position( index ).
  ENDMETHOD.

  METHOD lif_iterator~get_current_position.
    position = index.
  ENDMETHOD.

  METHOD lif_iterator~reset.
    index = 0.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete collection (Example 1)
*&amp;---------------------------------------------------------------------*

CLASS lcl_collection_strings DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_collection.
    METHODS add IMPORTING item TYPE string.
  PRIVATE SECTION.
    DATA items TYPE string_table.
ENDCLASS.

CLASS lcl_collection_strings IMPLEMENTATION.
  METHOD lif_collection~get_iterator.
    iterator = NEW lcl_iterator( me ).
  ENDMETHOD.

  METHOD lif_collection~get_number_of_items.
    count = lines( items ).
  ENDMETHOD.

  METHOD lif_collection~get_item_at_position.
    IF idx BETWEEN 1 AND lines( items ).
      item = items[ idx ].
    ELSE.
      item = ``.
    ENDIF.
  ENDMETHOD.

  METHOD add.
    APPEND item TO items.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete collection (Example 2)
*&amp;---------------------------------------------------------------------*

&quot;Local exception class supporting the concrete collection class
CLASS lcx_error DEFINITION INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    INTERFACES if_t100_dyn_msg.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcx_error IMPLEMENTATION.
ENDCLASS.

CLASS lcl_collection_line2string DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_collection.
    METHODS constructor IMPORTING itab TYPE INDEX TABLE
                        RAISING   lcx_error.
  PRIVATE SECTION.
    DATA: it                 TYPE REF TO data,
          has_elem_line_type TYPE abap_boolean.
ENDCLASS.

CLASS lcl_collection_line2string IMPLEMENTATION.
  METHOD lif_collection~get_iterator.
    iterator = NEW lcl_iterator( me ).
  ENDMETHOD.

  METHOD lif_collection~get_number_of_items.
    count = lines( it-&gt;* ).
  ENDMETHOD.

  METHOD lif_collection~get_item_at_position.
    IF idx BETWEEN 1 AND lines( it-&gt;* ).
      FIELD-SYMBOLS &lt;fs&gt; TYPE INDEX TABLE.
      ASSIGN it-&gt;* TO &lt;fs&gt;.
      ASSIGN &lt;fs&gt;[ idx ] TO FIELD-SYMBOL(&lt;line&gt;).

      IF has_elem_line_type = abap_true.
        item = &lt;line&gt;.
      ELSE.
        DO.
          ASSIGN &lt;line&gt;-(sy-index) TO FIELD-SYMBOL(&lt;comp&gt;).
          &quot;Older syntax
          &quot;ASSIGN COMPONENT sy-index OF STRUCTURE &lt;line&gt; TO FIELD-SYMBOL(&lt;comp&gt;).
          IF sy-subrc = 0.
            item &amp;&amp;= COND #( WHEN sy-index = 1 THEN |{ &lt;comp&gt; }| ELSE |, { &lt;comp&gt; }| ).
          ELSE.
            EXIT.
          ENDIF.
        ENDDO.
      ENDIF.
    ELSE.
      item = ``.
    ENDIF.
  ENDMETHOD.

  METHOD constructor.
    &quot;Component check using RTTI
    &quot;The example only processes internal tables with elementary components.
    DATA(tdo_tab) = CAST cl_abap_tabledescr( cl_abap_typedescr=&gt;describe_by_data( itab ) ).

    TRY.
        DATA(table_comps) = CAST cl_abap_structdescr( tdo_tab-&gt;get_table_line_type( ) )-&gt;get_components( ).

        LOOP AT table_comps INTO DATA(wa) WHERE type-&gt;kind &lt;&gt; cl_abap_typedescr=&gt;kind_elem.
          DATA(message) = xco_cp=&gt;string( `Internal table not supported by the example (non-elementary component available)`
            )-&gt;as_message( xco_cp_message=&gt;type-&gt;error )-&gt;value.
          RAISE EXCEPTION TYPE lcx_error MESSAGE ID message-msgid TYPE message-msgty
                                         NUMBER message-msgno WITH message-msgv1 message-msgv2 message-msgv3 message-msgv4.
        ENDLOOP.

*&quot;As an alternative to the LOOP statement, you may also choose to use the newer READ TABLE ... WHERE syntax.
*READ TABLE table_comps TRANSPORTING NO fieldS WHERE type-&gt;kind &lt;&gt; cl_abap_typedescr=&gt;kind_elem.
*IF sy-subrc = 0.
*  DATA(msg) = xco_cp=&gt;string( `Internal table not supported by the example` )-&gt;as_message( xco_cp_message=&gt;type-&gt;error )-&gt;value.
*  RAISE EXCEPTION TYPE lcx_error MESSAGE ID msg-msgid TYPE msg-msgty NUMBER msg-msgno WITH msg-msgv1 msg-msgv2 msg-msgv3 msg-msgv4.
*ENDIF.

      CATCH cx_sy_move_cast_error.
        DATA(tab_line_type) = tdo_tab-&gt;get_table_line_type( ).
        IF tab_line_type IS INSTANCE OF cl_abap_elemdescr.
          has_elem_line_type = abap_true.
        ELSE.
          DATA(m) = xco_cp=&gt;string( `Internal table not supported by the example (line type not supported)`
            )-&gt;as_message( xco_cp_message=&gt;type-&gt;error )-&gt;value.
          RAISE EXCEPTION TYPE lcx_error MESSAGE ID m-msgid TYPE m-msgty
                                         NUMBER m-msgno WITH m-msgv1 m-msgv2 m-msgv3 m-msgv4.
        ENDIF.
    ENDTRY.

    CREATE DATA it LIKE itab.
    it-&gt;* = itab.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Mediator</h2>
<ul>
<li>The mediator design pattern assumes that a group of objects interacts with each other, which can lead to complexity.</li>
<li>Instead of direct interaction among these objects, a mediator serves as a central go to object that orchestrates and manages the interactions.</li>
<li>The individual members of the group of objects only need to know about the mediator, which takes care of the necessary steps without requiring any awareness of other objects&#x27; implementations.</li>
<li>This setup can be useful for avoiding tight coupling and dependencies, enabling greater flexibility and improved maintainability by centralizing the operational flow.</li>
<li>A potential setup, illustrated in the following example, may look like this:</li>
<li>A mediator interface that defines methods for interactions among members of a group of objects.</li>
<li>A concrete mediator that implements the mediator interface and is responsible for orchestrating interactions between members. This can be achieved by storing references to the member objects in instance attributes.</li>
<li>Members of a group of objects: These members need to interact with one another. They can do so by storing a reference to the mediator in all member objects, allowing interactions to occur through this mediator reference.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example uses a shopping scenario as demo context with several members of a group of objects (represented by shopping cart, payment processing, stock management, customer notifications) interacting with one another.</li>
<li>The example code demonstrates the mediator design pattern by including the following declarations and implementations:</li>
<li>CCIMP include (<em>Local Types</em> tab in ADT):</li>
<li><code>lif_mediator</code></li>
<li>Represents the mediator interface that declares methods for interaction among members of a group of objects.</li>
<li>An enumerated type defines the kinds of events (<code>item_added</code>, <code>item_reserved</code>, <code>item_removed</code>, etc.)</li>
<li>The <code>notify</code> method is used to handle the communication between the members. It is called by member classes to inform the mediator. For this purpose, the method includes various importing parameters. The <code>log</code> method handles logging for display purposes.</li>
<li><code>lif_member</code>:</li>
<li>Represents the interface for the member classes. It defines the <code>set_mediator</code> method to link members and mediator. In the example setup, this method is called in the instance constructor of the concrete mediator to establish the linking.</li>
<li>Member classes (Note: For simplicity, implementations in these classes are simulations.)</li>
<li><code>lcl_shopping_cart</code>: Manages products in the shopping cart with methods for adding and removing products. The <code>get_cart</code> method returns the current contents of the cart. The shopping cart itself is represented by a string table that holds the added products.</li>
<li><code>lcl_payment</code>: Processes payments for ordered products via the <code>process_payment</code> method.</li>
<li><code>lcl_stock</code>: Manages the stock with methods for reserving and releasing products.</li>
<li><code>lcl_notification</code>: Sends notifications to customers.</li>
<li><code>lcl_mediator</code>:</li>
<li>Represents the concrete mediator by implementing the mediator interface.</li>
<li>Contains references to objects of all members of the group. In the example, these references are bound by calling the <code>set_mediator</code> method in the instance constructor implementation.</li>
<li>Implements the <code>notify</code> method for orchestrating the member interactions based on the provided enumerated type. It also logs activity records via the <code>log</code> method.</li>
<li>Generally, the class manages the flow of the business logic by coordinating the operations and also their sequence. In the simplified example, the flow is as follows: When a product is added to the cart, the cart (that is, the member object of class <code>lcl_shopping_cart</code>) notifies the mediator. Then, the mediator instructs the stock manager to reserve the product. Once reserved, the mediator notes this confirmation. If a product is removed, the mediator instructs the stock object to release the it. When the checkout is initiated, the mediator processes the payment. After the payment, the mediator instructs the notification objet to send a confirmation.</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as the client in the example. Here, the client creates the set of members of a group of objects and links them through a mediator object. The example implementation includes for the client to add or remove products to a shopping cart, and trigger the checkout process.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA example_number TYPE i.
    METHODS set_example_divider IMPORTING out  TYPE REF TO if_oo_adt_classrun_out
                                          text TYPE string.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;---------------------------------------------------------------------*
*&amp; Example 1
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Purchasing products| ).
    out-&gt;write( |\n| ).

    &quot;Creating instances of concrete component classes
    DATA(product_manager) = NEW lcl_shopping_cart( ).
    DATA(payment_processor) = NEW lcl_payment( ).
    DATA(stock_manager) = NEW lcl_stock( ).
    DATA(notification_service) = NEW lcl_notification( ).

    &quot;Creating mediator instance and link component classes
    DATA(shopping_mediator) = NEW lcl_mediator( prod_m   = product_manager
                                                pay_proc = payment_processor
                                                inv_m    = stock_manager
                                                notif    = notification_service ).

    &quot;Adding products to the shopping cart
    product_manager-&gt;add_product( `Laptop` ).
    product_manager-&gt;add_product( `Mouse` ).
    product_manager-&gt;add_product( `Keyboard` ).

    &quot;Displaying the contents of the current shopping cart
    out-&gt;write( |Contents of shopping cart { example_number }:| ).
    DATA(cart_items) = product_manager-&gt;get_cart( ).
    LOOP AT cart_items INTO DATA(item).
      out-&gt;write( |  - { item }| ).
    ENDLOOP.
    out-&gt;write( |\n| ).

    &quot;Triggering the checkout for processing the payment and
    &quot;sending confirmation
    shopping_mediator-&gt;checkout( ).

    &quot;Displaying the log
    out-&gt;write( `Log:` ).
    DATA(log) = shopping_mediator-&gt;get_log( ).
    out-&gt;write( log ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 2
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Adding and removing products| ).
    out-&gt;write( |\n| ).

    product_manager = NEW lcl_shopping_cart( ).
    payment_processor = NEW lcl_payment( ).
    stock_manager = NEW lcl_stock( ).
    notification_service = NEW lcl_notification( ).

    &quot;Creating mediator instance and link component classes
    shopping_mediator = NEW lcl_mediator( prod_m   = product_manager
                                          pay_proc = payment_processor
                                          inv_m    = stock_manager
                                          notif    = notification_service ).

    product_manager-&gt;add_product( `Smartphone` ).
    product_manager-&gt;add_product( `Headphones` ).
    product_manager-&gt;add_product( `Phone Case` ).

    &quot;Removing an item from the shopping cart
    product_manager-&gt;remove_product( `Headphones` ).

    out-&gt;write( |Contents of shopping cart { example_number }:| ).
    cart_items = product_manager-&gt;get_cart( ).
    LOOP AT cart_items INTO item.
      out-&gt;write( |  - { item }| ).
    ENDLOOP.
    out-&gt;write( |\n| ).

    shopping_mediator-&gt;checkout( ).

    out-&gt;write( `Log:` ).
    log = shopping_mediator-&gt;get_log( ).
    out-&gt;write( log ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 3
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Empty shopping cart| ).
    out-&gt;write( |\n| ).

    product_manager = NEW lcl_shopping_cart( ).
    payment_processor = NEW lcl_payment( ).
    stock_manager = NEW lcl_stock( ).
    notification_service = NEW lcl_notification( ).

    &quot;Creating mediator instance and link component classes
    shopping_mediator = NEW lcl_mediator( prod_m   = product_manager
                                          pay_proc = payment_processor
                                          inv_m    = stock_manager
                                          notif    = notification_service ).

    out-&gt;write( |Contents of shopping cart { example_number }:| ).
    cart_items = product_manager-&gt;get_cart( ).
    LOOP AT cart_items INTO item.
      out-&gt;write( |  - { item }| ).
    ENDLOOP.
    out-&gt;write( |\n\n| ).

    shopping_mediator-&gt;checkout( ).

    out-&gt;write( `Log:` ).
    log = shopping_mediator-&gt;get_log( ).
    out-&gt;write( log ).
    out-&gt;write( |\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 4
*&amp;---------------------------------------------------------------------*

    example_number += 1.
    set_example_divider( out  = out
                         text = |{ example_number }: Adding and removing multiple products| ).
    out-&gt;write( |\n| ).

    product_manager = NEW lcl_shopping_cart( ).
    payment_processor = NEW lcl_payment( ).
    stock_manager = NEW lcl_stock( ).
    notification_service = NEW lcl_notification( ).

    &quot;Creating mediator instance and link component classes
    shopping_mediator = NEW lcl_mediator( prod_m   = product_manager
                                          pay_proc = payment_processor
                                          inv_m    = stock_manager
                                          notif    = notification_service ).

    &quot;Adding and removing multiple products
    product_manager-&gt;add_product( `Monitor` ).
    product_manager-&gt;add_product( `USB Drive` ).
    product_manager-&gt;remove_product( `USB Drive` ).
    product_manager-&gt;add_product( `Smartphone` ).
    product_manager-&gt;add_product( `Headphones` ).
    product_manager-&gt;add_product( `Phone Case` ).
    product_manager-&gt;add_product( `Printer` ).
    product_manager-&gt;add_product( `Scanner` ).
    product_manager-&gt;remove_product( `Printer` ).
    product_manager-&gt;add_product( `Mouse` ).
    product_manager-&gt;remove_product( `Phone Case` ).

    out-&gt;write( |Contents of shopping cart { example_number }:| ).
    cart_items = product_manager-&gt;get_cart( ).
    LOOP AT cart_items INTO item.
      out-&gt;write( |  - { item }| ).
    ENDLOOP.
    out-&gt;write( |\n\n| ).

    shopping_mediator-&gt;checkout( ).

    out-&gt;write( `Log:` ).
    log = shopping_mediator-&gt;get_log( ).
    out-&gt;write( log ).
  ENDMETHOD.

  METHOD set_example_divider.
    out-&gt;write( |*&amp;{ repeat( val = `-` occ = 70 ) }*| ).
    out-&gt;write( |*&amp; Example { text }| ).
    out-&gt;write( |*&amp;{ repeat( val = `-` occ = 70 ) }*| ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Mediator interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_mediator.
  TYPES: BEGIN OF ENUM ty_enum,
           item_added,
           item_reserved,
           item_removed,
           payment_done,
           notification,
         END OF ENUM ty_enum.

  METHODS: notify IMPORTING oref  TYPE REF TO object
                            event TYPE ty_enum
                            text  TYPE string OPTIONAL,
           log IMPORTING text TYPE string.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Interface for object group members
*&amp;---------------------------------------------------------------------*

INTERFACE lif_member.
  METHODS set_mediator IMPORTING mediator_oref TYPE REF TO lif_mediator.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Member class 1 (Shopping cart)
*&amp;---------------------------------------------------------------------*

CLASS lcl_shopping_cart DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_member.
    METHODS: add_product    IMPORTING product TYPE string,
      remove_product IMPORTING product TYPE string,
      get_cart       RETURNING VALUE(shopping_cart) TYPE string_table.
  PRIVATE SECTION.
    DATA: mediator  TYPE REF TO lif_mediator,
          shop_cart TYPE string_table,
          cl        TYPE string.
ENDCLASS.

CLASS lcl_shopping_cart IMPLEMENTATION.
  METHOD lif_member~set_mediator.
    mediator = mediator_oref.
    cl = cl_abap_typedescr=&gt;describe_by_object_ref( me )-&gt;get_relative_name( ).
  ENDMETHOD.

  METHOD add_product.
    APPEND product TO shop_cart.

    IF mediator IS BOUND.
      mediator-&gt;log( |{ cl }: Product &quot;{ product }&quot; added to cart.| ).
      mediator-&gt;notify( oref  = me
                        event = lif_mediator=&gt;item_added
                        text  = product ).
    ENDIF.
  ENDMETHOD.

  METHOD remove_product.
    DELETE shop_cart WHERE table_line = product.

    IF mediator IS BOUND.
      mediator-&gt;log( |{ cl }: Product &quot;{ product }&quot; removed from cart.|  ).
      mediator-&gt;notify( oref  = me
                        event = lif_mediator=&gt;item_removed
                        text  = product ).
    ENDIF.
  ENDMETHOD.

  METHOD get_cart.
    shopping_cart = shop_cart.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Member class 2 (Payment Processor)
*&amp;---------------------------------------------------------------------*

CLASS lcl_payment DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_member.
    METHODS process_payment IMPORTING products TYPE string_table.
  PRIVATE SECTION.
    DATA: mediator TYPE REF TO lif_mediator,
          cl       TYPE string.
ENDCLASS.

CLASS lcl_payment IMPLEMENTATION.
  METHOD lif_member~set_mediator.
    mediator = mediator_oref.
    cl = cl_abap_typedescr=&gt;describe_by_object_ref( me )-&gt;get_relative_name( ).
  ENDMETHOD.

  METHOD process_payment.
    IF products IS INITIAL.
      IF mediator IS BOUND.
        mediator-&gt;log( |{ cl }: No items to process payment for.|  ).
        RETURN.
      ENDIF.
    ENDIF.

    DATA(prod) = concat_lines_of( table = products sep = `, ` ).

    IF mediator IS BOUND.
      mediator-&gt;log( |{ cl }: Processing payment for { lines( products ) } products ({ prod }) ...|  ).
      mediator-&gt;log( |{ cl }: Payment processed successfully.|  ).
      mediator-&gt;notify( oref  = me
                        event = lif_mediator=&gt;payment_done
                        text  = prod ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Member class 3 (Stock Manager)
*&amp;---------------------------------------------------------------------*

CLASS lcl_stock DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_member.
    METHODS: reserve_stock IMPORTING product TYPE string,
      release_stock IMPORTING product TYPE string.
  PRIVATE SECTION.
    DATA: mediator TYPE REF TO lif_mediator,
          cl       TYPE string.
ENDCLASS.

CLASS lcl_stock IMPLEMENTATION.
  METHOD lif_member~set_mediator.
    mediator = mediator_oref.
    cl = cl_abap_typedescr=&gt;describe_by_object_ref( me )-&gt;get_relative_name( ).
  ENDMETHOD.

  METHOD reserve_stock.
    IF mediator IS BOUND.
      mediator-&gt;log( |{ cl }: Inventory reserved for &quot;{ product }&quot;.|  ).
      mediator-&gt;notify( oref  = me
                        event = lif_mediator=&gt;item_reserved
                        text  = product ).
    ENDIF.
  ENDMETHOD.

  METHOD release_stock.
    IF mediator IS BOUND.
      mediator-&gt;log( |{ cl }: Inventory released for &quot;{ product }&quot;.|  ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Member class 4 (Notification Service)
*&amp;---------------------------------------------------------------------*

CLASS lcl_notification DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_member.
    METHODS send_confirmation.
  PRIVATE SECTION.
    DATA: mediator TYPE REF TO lif_mediator,
          cl       TYPE string.
ENDCLASS.

CLASS lcl_notification IMPLEMENTATION.
  METHOD lif_member~set_mediator.
    mediator = mediator_oref.
    cl = cl_abap_typedescr=&gt;describe_by_object_ref( me )-&gt;get_relative_name( ).
  ENDMETHOD.

  METHOD send_confirmation.
    IF mediator IS BOUND.
      mediator-&gt;log( |{ cl }: Order confirmation sent to customer.|  ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete Mediator
*&amp;---------------------------------------------------------------------*

CLASS lcl_mediator DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_mediator.
    METHODS: constructor IMPORTING prod_m   TYPE REF TO lcl_shopping_cart
                                   pay_proc TYPE REF TO lcl_payment
                                   inv_m    TYPE REF TO lcl_stock
                                   notif    TYPE REF TO lcl_notification,
      checkout,
      get_log RETURNING VALUE(log) TYPE string_table.
  PRIVATE SECTION.
    DATA: product_manager   TYPE REF TO lcl_shopping_cart,
          payment_processor TYPE REF TO lcl_payment,
          inventory_manager TYPE REF TO lcl_stock,
          notification      TYPE REF TO lcl_notification,
          cl                TYPE string,
          prod              TYPE string_table,
          log_tab           TYPE string_table.
ENDCLASS.

CLASS lcl_mediator IMPLEMENTATION.
  METHOD constructor.
    product_manager   = prod_m.
    payment_processor = pay_proc.
    inventory_manager = inv_m.
    notification  = notif.

    product_manager-&gt;lif_member~set_mediator( me ).
    payment_processor-&gt;lif_member~set_mediator( me ).
    inventory_manager-&gt;lif_member~set_mediator( me ).
    notification-&gt;lif_member~set_mediator( me ).

    cl = cl_abap_typedescr=&gt;describe_by_object_ref( me )-&gt;get_relative_name( ).
  ENDMETHOD.

  METHOD lif_mediator~notify.
    CASE event.
      WHEN lif_mediator=&gt;item_added.
        lif_mediator~log( |{ cl }: Reserving stock ...|  ).

        IF inventory_manager IS BOUND.
          inventory_manager-&gt;reserve_stock( text ).
        ENDIF.
      WHEN lif_mediator=&gt;item_reserved.
        lif_mediator~log( |{ cl }: Stock confirmed for &quot;{ text }&quot;.| ).

        APPEND text TO prod.
      WHEN lif_mediator=&gt;item_removed.
        lif_mediator~log( |{ cl }: Releasing inventory ...| ).

        IF inventory_manager IS BOUND.
          inventory_manager-&gt;release_stock( text ).
        ENDIF.

        DELETE prod WHERE table_line = text.
      WHEN lif_mediator=&gt;payment_done.
        lif_mediator~log( |{ cl }: Payment completed, sending confirmation.| ).

        IF notification IS BOUND.
          notification-&gt;send_confirmation( ).
        ENDIF.
    ENDCASE.
  ENDMETHOD.

  METHOD checkout.
    IF prod IS INITIAL.
      lif_mediator~log( |{ cl }: No items to checkout. Exiting.| ).
      RETURN.
    ENDIF.

    lif_mediator~log( |{ cl }: Initiating checkout ...| ).

    IF payment_processor IS BOUND.
      payment_processor-&gt;process_payment( prod ).
    ENDIF.
  ENDMETHOD.

  METHOD get_log.
    log = log_tab.
  ENDMETHOD.

  METHOD lif_mediator~log.
    APPEND text TO log_tab.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Memento</h2>
<ul>
<li>The idea of the memento design pattern is to allow the storing and restoring of an object&#x27;s state.</li>
<li>The state is stored in a separate object, the memento, which captures the object&#x27;s state.</li>
<li>A potential class setup for this pattern may include a class for which mementos are created, a memento class, and a class to manage the mementos.</li>
<li>Use cases for this pattern include saving object states and providing undo (and possibly redo) functionality to revert changes.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example demonstrates the memento design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the <code>CCIMP</code> are relevant for the for conceptual considerations.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Several class setup and design strategies may apply. This simplified example includes three classes:</li>
<li><code>lcl</code>: Represents the class for which mementos are created.</li>
<li><code>lcl_memento</code>: Captures the state of an <code>lcl</code> object.</li>
<li><code>lcl_memento_controller</code>: Manages mementos.</li>
<li>More details:</li>
<li><code>lcl</code> class</li>
<li>Represents the class for which mementos are created.</li>
<li>It is defined as <code>FINAL</code> and <code>CREATE PRIVATE</code>, which prevents inheritance and direct instantiation by other classes. This setup implements the singleton design pattern, allowing instantiation only through the <code>get_obj</code> method.</li>
<li>Attributes:</li>
<li><code>state</code>: Represents the state of an <code>lcl</code> object. In this simplified example, the state is a string that can change.</li>
<li><code>oref</code>: A static attribute holding a reference to the single <code>lcl</code> object.</li>
<li>Methods:</li>
<li><code>get_obj</code>: Static method that returns a singleton instance of the <code>lcl</code> class.</li>
<li><code>get_state</code>: Returns the current state of the object.</li>
<li><code>change_state</code>: Updates the current state by appending text, with an optional leading space.</li>
<li><code>save</code>: Creates a memento of the current state with a specified tag.</li>
<li><code>restore</code>: Sets the current state to the state stored in the provided memento.</li>
</ul>
<ul>
<li><code>lcl_memento</code> class</li>
<li>Captures the state of an <code>lcl</code> object.</li>
<li>Marked as <code>FINAL</code> and <code>CREATE PRIVATE</code>, which prevents inheritance and direct instantiation by other classes, except for its friend (using the <code>FRIENDS</code> addition) class, <code>lcl</code>.</li>
<li>Attributes:</li>
<li><code>state</code>: Represents the state of an <code>lcl</code> object. In this simplified example, it is a string that can change.</li>
<li><code>tag</code>: A string that labels each memento for identification.</li>
<li><code>time_stamp</code>: Records the UTC timestamp when the memento is created. In this example, it is included for logging and display purposes.</li>
<li>Methods:</li>
<li><code>constructor</code>: Initializes the <code>state</code> and <code>tag</code> attributes and captures the current timestamp.</li>
<li><code>get_state</code>: Returns the memento&#x27;s stored state.</li>
<li><code>get_tag</code>: Returns the tag associated with the memento.</li>
<li><code>get_timestamp</code>: Returns the creation timestamp of the memento.</li>
</ul>
<ul>
<li><code>lcl_memento_controller</code> class</li>
<li>Manages mementos but does not modify their states.</li>
<li>Attributes:</li>
<li><code>mementos_tab</code>: Internal table storing all created mementos.</li>
<li><code>redo_tab</code>: Internal table storing mementos for potential redo operations.</li>
<li><code>lcl_object</code>: Holds a reference to the <code>lcl</code> object for which it manages mementos.</li>
<li>Methods:</li>
<li><code>constructor</code>: Initializes the reference variable for the <code>lcl_object</code>.</li>
<li><code>save_memento</code>: Adds a new memento to the <code>mementos_tab</code>.</li>
<li><code>undo</code>: Restores the <code>lcl</code> object to the previous state and adds the latest memento to the <code>redo_tab</code>.</li>
<li><code>redo</code>: Restores the <code>lcl</code> object to the next state in the <code>redo_tab</code>, if available.</li>
<li><code>restore_by_tag</code>: Searches for a memento by its tag in the <code>mementos_tab</code> and restores the <code>lcl</code> object to that state, also returning information on the success of the restoration.</li>
<li><code>get_memento_log</code>: Returns logs of all mementos in the <code>mementos_tab</code> and <code>redo_tab</code>.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;-------------------------------------------------------------------------------------*
*&amp; 1) Creating objects and mementos, changing and getting states
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |1) Creating objects and mementos, changing and getting states\n| ).

    DATA(oref_lcl) = lcl=&gt;get_obj( ).
    DATA(oref_memento_ctrl)  = NEW lcl_memento_controller( oref_lcl ).

    oref_lcl-&gt;change_state( `Lorem` ).
    oref_memento_ctrl-&gt;save_memento( `TAG_1` ).

    DATA(state_a) = oref_lcl-&gt;get_state( ).
    out-&gt;write( state_a ).

    oref_lcl-&gt;change_state( `ipsum` ).
    oref_memento_ctrl-&gt;save_memento( `TAG_2` ).

    DATA(state_b) = oref_lcl-&gt;get_state( ).
    out-&gt;write( state_b ).

    oref_lcl-&gt;change_state( `dolor` ).
    oref_memento_ctrl-&gt;save_memento( `TAG_3` ).

    DATA(state_c) = oref_lcl-&gt;get_state( ).
    out-&gt;write( state_c ).

    oref_lcl-&gt;change_state( `sit` ).
    oref_memento_ctrl-&gt;save_memento( `TAG_4` ).

    DATA(state_d) = oref_lcl-&gt;get_state(  ).
    out-&gt;write( state_d ).

    oref_lcl-&gt;change_state( `amet` ).
    oref_memento_ctrl-&gt;save_memento( `TAG_5` ).

    DATA(state_e) = oref_lcl-&gt;get_state( ).
    out-&gt;write( state_e ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 2) Memento log
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |2) Memento log\n\n| ).


    DATA(memento_log) = oref_memento_ctrl-&gt;get_memento_log( ).
    out-&gt;write( data = memento_log name = `memento_log` ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 3) Undo operations
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |3) Undo operations\n| ).

    DATA(state_f) = oref_lcl-&gt;get_state( ).
    out-&gt;write( `Current state:` ).
    out-&gt;write( state_f ).

    out-&gt;write( |\n| ).
    out-&gt;write( `State after first undo operation:` ).
    oref_memento_ctrl-&gt;undo( CHANGING lcl_obj = oref_lcl ).

    DATA(state_g) = oref_lcl-&gt;get_state( ).
    out-&gt;write( state_g ).

    oref_memento_ctrl-&gt;undo( CHANGING lcl_obj = oref_lcl ).

    DATA(state_h) = oref_lcl-&gt;get_state( ).

    out-&gt;write( |\n| ).
    out-&gt;write( `State after second undo operation:` ).
    out-&gt;write( state_h ).

    oref_memento_ctrl-&gt;undo( CHANGING lcl_obj = oref_lcl ).

    DATA(state_i) = oref_lcl-&gt;get_state( ).

    out-&gt;write( |\n| ).
    out-&gt;write( `State after third undo operation:` ).
    out-&gt;write( state_i &amp;&amp; |\n\n| ).

    memento_log = oref_memento_ctrl-&gt;get_memento_log( ).
    out-&gt;write( data = memento_log name = `memento_log` ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 4) Redo operations
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |4) Redo operations\n| ).

    DATA(state_j) = oref_lcl-&gt;get_state( ).
    out-&gt;write( `Current state:` ).
    out-&gt;write( state_j ).

    oref_memento_ctrl-&gt;redo( CHANGING lcl_obj = oref_lcl ).

    DATA(state_k) = oref_lcl-&gt;get_state( ).

    out-&gt;write( |\n| ).
    out-&gt;write( `State after first redo operation:` ).
    out-&gt;write( state_k &amp;&amp; |\n\n| ).

    memento_log = oref_memento_ctrl-&gt;get_memento_log( ).
    out-&gt;write( data = memento_log name = `memento_log` ).

    oref_memento_ctrl-&gt;redo( CHANGING lcl_obj = oref_lcl ).

    DATA(state_l) = oref_lcl-&gt;get_state( ).

    out-&gt;write( |\n| ).
    out-&gt;write( `State after second redo operation:` ).
    out-&gt;write( state_l &amp;&amp; |\n\n| ).

    memento_log = oref_memento_ctrl-&gt;get_memento_log( ).
    out-&gt;write( data = memento_log name = `memento_log` ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 5) Restoring by tag
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |5) Restoring by tag\n| ).

    DATA(state_m) = oref_lcl-&gt;get_state( ).
    out-&gt;write( `Current state:` ).
    out-&gt;write( state_m ).
    out-&gt;write( |\n| ).

    DATA flag TYPE abap_boolean.

    &quot;At this stage, the memento with the tag TAG_5 is not stored in the memento table but
    &quot;in the redo table. Therefore, the current state remains unchanged because the restoration
    &quot;only considers mementos available in the memento table in the example.
    out-&gt;write( `Tag used: TAG_5` ).
    oref_memento_ctrl-&gt;restore_by_tag( EXPORTING tag = `TAG_5`
                                       CHANGING  lcl_obj = oref_lcl
                                       RECEIVING restoration_ok = flag ).

    DATA(state_n) = oref_lcl-&gt;get_state( ).
    out-&gt;write( |Restoration operation successful? { COND #( WHEN flag = abap_true THEN `YES` ELSE `NO` ) }| ).
    out-&gt;write( state_n ).
    out-&gt;write( |\n| ).

    out-&gt;write( `Tag used: TAG_2` ).
    oref_memento_ctrl-&gt;restore_by_tag( EXPORTING tag = `TAG_2`
                                       CHANGING  lcl_obj = oref_lcl
                                       RECEIVING restoration_ok = flag ).

    DATA(state_o) = oref_lcl-&gt;get_state( ).
    out-&gt;write( |Restoration operation successful? { COND #( WHEN flag = abap_true THEN `YES` ELSE `NO` ) }| ).
    out-&gt;write( state_o ).
    out-&gt;write( |\n| ).

    &quot;Checking on multiple tags in a loop
    DO 7 TIMES.
      DATA(tag) = |TAG_{ sy-index }|.
      out-&gt;write( |Tag used: { tag }| ).

      oref_memento_ctrl-&gt;restore_by_tag( EXPORTING tag = tag
                                         CHANGING  lcl_obj = oref_lcl
                                         RECEIVING restoration_ok = flag ).

      DATA(state_p) = oref_lcl-&gt;get_state( ).
      out-&gt;write( |Restoration operation successful? { COND #( WHEN flag = abap_true THEN `YES` ELSE `NO` ) }| ).
      out-&gt;write( state_p ).
      out-&gt;write( |\n| ).
    ENDDO.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl DEFINITION DEFERRED.

*&amp;---------------------------------------------------------------------*
*&amp; Memento class
*&amp;---------------------------------------------------------------------*

CLASS lcl_memento DEFINITION FINAL CREATE PRIVATE FRIENDS lcl.
  PUBLIC SECTION.
    METHODS: get_tag RETURNING VALUE(ret_tag) TYPE string,
             get_timestamp RETURNING VALUE(ret_ts) TYPE string.
  PRIVATE SECTION.
    METHODS: constructor IMPORTING state TYPE string
                                   tag   TYPE string,
             get_state RETURNING VALUE(ret_state) TYPE string.
    DATA: state     TYPE string,
          tag       TYPE string,
          timestamp TYPE utclong.
ENDCLASS.

CLASS lcl_memento IMPLEMENTATION.
  METHOD constructor.
    me-&gt;state = state.
    me-&gt;tag = tag.
    me-&gt;timestamp = utclong_current( ).
  ENDMETHOD.

  METHOD get_state.
    ret_state = me-&gt;state.
  ENDMETHOD.

  METHOD get_tag.
    ret_tag = me-&gt;tag.
  ENDMETHOD.

  METHOD get_timestamp.
    ret_ts = me-&gt;timestamp.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Class for which mementos should be created
*&amp;---------------------------------------------------------------------*

CLASS lcl DEFINITION FINAL CREATE PRIVATE.
  PUBLIC SECTION.
    CLASS-METHODS get_obj RETURNING VALUE(obj) TYPE REF TO lcl.
    METHODS: get_state RETURNING VALUE(ret_state) TYPE string,
             change_state IMPORTING text      TYPE string
                                    add_space TYPE abap_boolean DEFAULT abap_true,
             save IMPORTING tag                 TYPE string
                  RETURNING VALUE(oref_memento) TYPE REF TO lcl_memento,
             restore IMPORTING memento TYPE REF TO lcl_memento.
  PRIVATE SECTION.
    CLASS-DATA oref TYPE REF TO lcl.
    DATA state TYPE string.
ENDCLASS.

CLASS lcl IMPLEMENTATION.
  METHOD get_state.
    ret_state = state.
  ENDMETHOD.

  METHOD save.
    oref_memento = NEW #( state = state
                          tag   = tag ).
  ENDMETHOD.

  METHOD restore.
    state = memento-&gt;get_state( ).
  ENDMETHOD.

  METHOD change_state.
    state = |{ state }{ COND #( WHEN state IS NOT INITIAL AND add_space = abap_true THEN ` ` ) }{ text }|.
  ENDMETHOD.

  METHOD get_obj.
    IF oref IS NOT BOUND.
      oref = NEW lcl( ).
    ENDIF.
    obj = oref.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Class that manages mementos
*&amp;---------------------------------------------------------------------*

CLASS lcl_memento_controller DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS: save_memento IMPORTING tag TYPE string,
             undo CHANGING lcl_obj TYPE REF TO lcl,
             redo CHANGING lcl_obj TYPE REF TO lcl,
             restore_by_tag IMPORTING tag                   TYPE string
                            CHANGING  lcl_obj               TYPE REF TO lcl
                            RETURNING VALUE(restoration_ok) TYPE abap_boolean,
             get_memento_log RETURNING VALUE(states) TYPE string_table,
             constructor IMPORTING oref TYPE REF TO lcl.
  PRIVATE SECTION.
    DATA mementos_tab TYPE TABLE OF REF TO lcl_memento WITH EMPTY KEY.
    DATA redo_tab     TYPE TABLE OF REF TO lcl_memento WITH EMPTY KEY.
    DATA lcl_object TYPE REF TO lcl.
ENDCLASS.

CLASS lcl_memento_controller IMPLEMENTATION.
  METHOD save_memento.
    &quot;Clearing the redo table when a new state is added
    CLEAR redo_tab.
    &quot;Adding the memento to the table holding all stored mementos
    APPEND lcl_object-&gt;save( tag ) TO mementos_tab.
  ENDMETHOD.

  METHOD undo.
    DATA(count) = lines( mementos_tab ).

    IF count &lt;= 1.
      RETURN.
    ENDIF.

    &quot;Adding the last memento from the memento table to the redo table
    READ TABLE mementos_tab INTO DATA(memento_oref) INDEX count.
    IF sy-subrc = 0.
      APPEND memento_oref TO redo_tab.
      DELETE mementos_tab INDEX count.
    ENDIF.

    &quot;Restoring the previous state
    READ TABLE mementos_tab INTO memento_oref INDEX lines( mementos_tab ).
    IF sy-subrc = 0.
      lcl_object-&gt;restore( memento_oref ).
      lcl_obj = lcl_object.
    ENDIF.
  ENDMETHOD.

  METHOD redo.
    DATA(count) = lines( redo_tab ).

    IF count = 0.
      RETURN.
    ENDIF.

    &quot;Restoring the state from the redo table
    READ TABLE redo_tab INTO DATA(memento_oref) INDEX count.
    IF sy-subrc = 0.
      DELETE redo_tab INDEX count.
      &quot;Adding the memento to the memento table
      APPEND memento_oref TO mementos_tab.
      lcl_object-&gt;restore( memento_oref ).
      lcl_obj = lcl_object.
    ENDIF.
  ENDMETHOD.

  METHOD restore_by_tag.
    LOOP AT mementos_tab INTO DATA(memento_oref).
      IF memento_oref-&gt;get_tag( ) = tag.
        lcl_object-&gt;restore( memento_oref ).
        lcl_obj = lcl_object.
        restoration_ok = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.
    restoration_ok = abap_false.
  ENDMETHOD.

  METHOD get_memento_log.
    DATA idx TYPE i.
    LOOP AT mementos_tab INTO DATA(memento_wa).
      idx = sy-tabix.
      APPEND |{ idx }) Memento created with tag &quot;{ memento_wa-&gt;get_tag( ) }&quot; at { memento_wa-&gt;get_timestamp( ) }| TO states.
    ENDLOOP.

    IF lines( redo_tab ) &gt; 0.
      APPEND INITIAL LINE TO states.
      APPEND `*********************** Redo table entries ************************` TO states.
      LOOP AT redo_tab INTO memento_wa.
        idx = sy-tabix.
        APPEND |{ idx }) Memento with tag &quot;{ memento_wa-&gt;get_tag( ) }&quot;, created at { memento_wa-&gt;get_timestamp( ) }| TO states.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.

  METHOD constructor.
    IF lcl_object IS NOT BOUND.
      lcl_object = oref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Multiton</h2>
<ul>
<li>The multiton design pattern is a variant of the singleton pattern designed to manage a fixed set of distinct instances, rather than just one.</li>
<li>While the singleton pattern ensures a class has only one instance across the entire application, returned through a factory method, the multiton pattern controls instantiation by managing multiple unique instances. These instances are differentiated by unique keys, allowing for controlled, instance-specific access.</li>
<li>The design pattern suggests that a key is mapped to a specific instance in an internal table. A factory method then returns that instance when the corresponding key is provided. If an instance does not exist for the provided key, the factory method can create a new instance, and add it to the internal table.</li>
<li>This approach is beneficial when you need to control the instantiation process without restricting it to just a single instance. It offers greater flexibility by allowing multiple controlled instances, each suited to handle different needs or contexts. Furthermore, it allows for instance reuse, which can be especially useful in data-intensive or complex scenarios.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The following example illustrates the multiton design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the CCIMP include are relevant for the conceptual considerations.</li>
<li>Represents the user who requires instances to work with.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Class <code>lcl_multiton</code></li>
<li>Specifies the <code>CREATE PRIVATE</code> addition to prevent instance creation outside the class.</li>
<li>Maintains one instance per unique key. The key values in this example are determined by ABAP enumerated types, which serve as identifiers for unique instances. The example assumes that users require specific configuration settings among a set of multiple settings, with each setting corresponding to a distinct class instance.</li>
<li>Instance maintenance occurs in the <code>instance_table</code> internal table within the private visibility section. This table contains entries for created class instances, mapped to specific keys (the ABAP enumerated types).</li>
<li>The <code>get_instance</code> method is a public, static factory method that returns an instance of <code>lcl_multiton</code> for a given key. It first checks if an entry in the <code>instance_table</code> table already exists. If not, it creates a new instance and adds it to the table. Finally, it returns the instance corresponding to the provided key, ensuring that users receive the specific instance they need.</li>
<li>The instance <code>constructor</code> is declared in the private visibility section to prevent direct instantiation. The assumption is that instantiation may involve complex or data-intensive tasks, which should be avoided if users frequently require instances. The pattern promotes reuse and prevents duplicate instantiations. The simplified demo implementation only adds entries to an internal table for display purposes.</li>
<li>Other implementations in the demo class, like the <code>do_something</code> dummy method, also serve display purposes. A string table collects information, including the current timestamp, to demonstrate multiple different entries added during class instantiation and method calls. The <code>log</code> table tracks the number of instance retrieval requests and the timestamps of the first instantiation per key within the internal session.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.



CLASS zcl_demo_abap IMPLEMENTATION.

  METHOD if_oo_adt_classrun~main.

    out-&gt;write( |1) First call with key { lcl_multiton=&gt;config_a } \n\n| ).

    DATA(oref_config_a_1) = lcl_multiton=&gt;get_instance( key = lcl_multiton=&gt;config_a ).
    oref_config_a_1-&gt;do_something( ).
    DATA(tab) = oref_config_a_1-&gt;get_config_change_tab( ).

    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n\n| ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |2) Second call with key { lcl_multiton=&gt;config_a } \n\n| ).

    DATA(oref_config_a_2) = lcl_multiton=&gt;get_instance( key = lcl_multiton=&gt;config_a ).
    oref_config_a_2-&gt;do_something( ).
    tab = oref_config_a_2-&gt;get_config_change_tab( ).

    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n\n| ).

**********************************************************************

    out-&gt;write( |3) Third call with key { lcl_multiton=&gt;config_a } \n\n| ).

    DATA(oref_config_a_3) = lcl_multiton=&gt;get_instance( key = lcl_multiton=&gt;config_a ).
    oref_config_a_3-&gt;do_something( ).
    tab = oref_config_a_3-&gt;get_config_change_tab( ).

    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n\n| ).

**********************************************************************

    out-&gt;write( |4) First call with key { lcl_multiton=&gt;config_b } \n\n| ).

    DATA(oref_config_b_1) = lcl_multiton=&gt;get_instance( key = lcl_multiton=&gt;config_b ).
    oref_config_b_1-&gt;do_something( ).
    tab = oref_config_b_1-&gt;get_config_change_tab( ).

    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n\n| ).

**********************************************************************

    out-&gt;write( |5) Second call with key { lcl_multiton=&gt;config_b } \n\n| ).

    DATA(oref_config_b_2) = lcl_multiton=&gt;get_instance( key = lcl_multiton=&gt;config_b ).
    oref_config_b_2-&gt;do_something( ).
    tab = oref_config_b_2-&gt;get_config_change_tab( ).

    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n\n| ).

**********************************************************************

    out-&gt;write( |6) Call with key { lcl_multiton=&gt;config_c } \n\n| ).

    DATA(oref_config_c) = lcl_multiton=&gt;get_instance( key = lcl_multiton=&gt;config_c ).
    oref_config_c-&gt;do_something( ).
    tab = oref_config_c-&gt;get_config_change_tab( ).

    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n\n| ).

**********************************************************************

    &quot;Using random keys
    &quot;The base type of the enumerated type is i, and the example type has 12 components.
    &quot;I.e. config_a corresponds to the value 0, ..., config_m corresponds to 11.
    &quot;Here, the cl_abap_random_int class is used to create random integer values within
    &quot;the range of 0 - 12. This random value is then passed when calling the get_instance
    &quot;method. The output will show which enumerated type component is used.
    DO 5 TIMES.
      DATA(random_number) = cl_abap_random_int=&gt;create( seed = cl_abap_random=&gt;seed( )
                                                        min  = 0
                                                        max  = 11 )-&gt;get_next( ).

      DATA(enum) = CONV lcl_multiton=&gt;t_enum( random_number ).

      out-&gt;write( |{ 6 + sy-index }) Call with key { enum } \n\n| ).
      DATA(oref_config_random) = lcl_multiton=&gt;get_instance( key = enum ).
      oref_config_random-&gt;do_something( ).
      tab = oref_config_random-&gt;get_config_change_tab( ).

      out-&gt;write( data = tab name = `tab` ).
      out-&gt;write( |\n\n| ).
    ENDDO.

**********************************************************************

    &quot;Log table that tracks the timestamp of the first instantiation per
    &quot;key and the number of calls.
    DATA(log) = lcl_multiton=&gt;log.
    out-&gt;write( data = log name = `log` ).

  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl_multiton DEFINITION
  FINAL
  CREATE PRIVATE.

  PUBLIC SECTION.
    &quot;ABAP enumerated type serving as identifiers for unique
    &quot;instances
    TYPES: BEGIN OF ENUM t_enum,
             config_a,
             config_b,
             config_c,
             config_e,
             config_f,
             config_g,
             config_h,
             config_i,
             config_j,
             config_k,
             config_l,
             config_m,
           END OF ENUM t_enum.

    &quot;Factory method that returns distinct instances based on given key
    CLASS-METHODS get_instance
      IMPORTING key             TYPE t_enum
      RETURNING VALUE(instance) TYPE REF TO lcl_multiton.

    &quot;Dummy methods
    METHODS do_something.
    METHODS get_config_change_tab RETURNING VALUE(tab) TYPE string_table.

    &quot;Table type and internal table used to store values for display purposes
    TYPES: BEGIN OF ty_log_struc,
             ikey      TYPE t_enum,
             first_instantiation TYPE utclong,
             instance_request_count type i,
           END OF ty_log_struc.

    CLASS-DATA log TYPE SORTED TABLE OF ty_log_struc WITH UNIQUE KEY ikey.

  PRIVATE SECTION.

    &quot;Internal table containing the unique instances that are mapped to keys
    TYPES: BEGIN OF ty_instance_struc,
             ikey     TYPE t_enum,
             instance TYPE REF TO lcl_multiton,
           END OF ty_instance_struc,
           ty_instance_tab TYPE HASHED TABLE OF ty_instance_struc WITH UNIQUE KEY ikey.

    CLASS-DATA instance_table TYPE ty_instance_tab.

    METHODS constructor IMPORTING key TYPE t_enum.

    DATA config_change TYPE string_table.
ENDCLASS.

CLASS lcl_multiton IMPLEMENTATION.

  METHOD get_instance.
    &quot;Factory method the returns an distinct instance out of a fixed set of
    &quot;instance based on a give key. The implementation returns that instance
    &quot;when the corresponding key is provided. If it is not yet stored in the
    &quot;internal table, a new instance is created, added to the table, and returned.

    READ TABLE instance_table INTO DATA(ref) WITH KEY ikey = key.
    IF ref-instance IS NOT BOUND.
      ref-instance = NEW #( key ).
      INSERT VALUE #( ikey = key instance = ref-instance ) INTO TABLE instance_table.
    ENDIF.
    instance = ref-instance.

    &quot;Modifying an entry in an internal table to log the number of instance retrieval requests
    &quot;for display purposes.
    log[ ikey = key ]-instance_request_count += 1.
  ENDMETHOD.

  METHOD constructor.
    DATA(timestamp) = utclong_current( ).

    &quot;Adding entries to an internal table for display purposes.
    &quot;The example simply adds text to a string table, including timestamp values,
    &quot;to illustrate different values when calling the method.
    APPEND key TO config_change.
    APPEND |constructor called at { timestamp }| TO config_change.

    IF NOT line_exists( log[ ikey = key ] ).
      INSERT VALUE #( ikey = key
                      first_instantiation = timestamp ) INTO TABLE log.

      APPEND |Instance for key { key } first created at { timestamp }| TO config_change.
    ENDIF.

    &quot;Assumption: Complex or data-intensive tasks are executed to create an initial state
    &quot;of instances.
    CASE key.
      WHEN config_a.
        ...
      WHEN config_b.
        ...
      WHEN config_c.
        ...

        ...
    ENDCASE.

  ENDMETHOD.

  METHOD do_something.
    APPEND |do_something called at { utclong_current( ) }| TO config_change.
  ENDMETHOD.

  METHOD get_config_change_tab.
    APPEND |get_config_change_tab called at { utclong_current( ) }| TO config_change.

    tab = config_change.
  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Observer</h2>
<ul>
<li>The observer design pattern allows an object to notify other objects - the <em>observers</em> - whenever its state changes.</li>
<li>A class setup may include the following (as implemented in the first code example):</li>
<li>Observers can register or unregister to receive notifications (or not receive them anymore) about state changes of an observed object. The notification of observers may include parameters to be passed. The observed class may contain an internal table to store references to observers, along with methods for adding and removing those references. When a change occurs, a notification method can inform the observers by iterating through the internal table and calling a method that all observers implement through a common interface. This enables the observed object to communicate with all registered observers.</li>
<li>All registered observers can react to the information received.</li>
<li>Users of the setup are responsible not only for the object creation but also for the flexible registration and unregistration of observers.</li>
<li>Such a setup can be useful when you want to avoid tightly coupling different objects while still providing a mechanism to transfer changes from a specific object to a random number of other objects.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example code includes two examples demonstrating the observer design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the <code>CCIMP</code> are relevant for the for conceptual considerations.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li><em>Example 1</em></li>
<li>Defines the <code>lif_observer</code> interface that enables the observed object to communicate with observers via the <code>notify</code> method, which expects two numbers as importing parameters, among others. The <code>calculate</code> method is common to all observers, performing a simple calculation based on the two integer values provided.</li>
<li><code>lcl</code> represents the class for observed objects and offers several methods:</li>
<li><code>set_numbers</code>: Changes the state of the observed object by setting two integer values. The implementation includes calling the <code>notify_observers</code> method.</li>
<li><code>register</code> and <code>unregister</code> are used to register and unregister observers. For that purpose, the internal table <code>observer_tab</code> is used to manage reference variables. When registering, references to observers are added. When unregistering, references are removed from the table.</li>
<li><code>notify_observers</code>: The method is responsible for notifying observers. The notification is performed by looping across the reference table and calling the common notification method <code>notify</code> defined in the interface.</li>
<li>A string table is included for demonstration and display purposes, being populated throughout method calls to visualize the method call flow.</li>
<li>Multiple local classes act as observers, performing simple calculations.</li>
<li>When the observed object calls the <code>notify</code> method, it informs the observer about the state change, passes values, and triggers a calculation by invoking the <code>calculate</code> method.</li>
<li>The global class represents the user, creating objects and registering and unregistering observers. The string table is output to visualize the method call flow.</li>
<li><em>Example 2</em></li>
<li>Provides a simpler example and setup, where the class being observed defines events.</li>
<li>An interface implemented by all observers defines an event handler.</li>
<li>Observers are notified through a <code>RAISE EVENT</code> statement, provided that event handlers are registered with <code>SET HANDLER</code> statements, which triggers the calling of event handlers. When they are not registered, the event handlers are not called.</li>
<li>Like in example 1, a string table logs the method call flow, which is output.</li>
<li>The user, represented by the global class implementation, manages object creation, and registration and unregistration using <code>SET HANDLER</code> statements. When the observed object&#x27;s <code>set_text</code> method is called, the event is raised and handled accordingly by event handlers in the registered observers.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.



CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    out-&gt;write( |Example 1\n\n| ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 1) Creating objects, observers not registered
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |1) Creating objects, observers not registered\n\n| ).

    DATA(oref_observed) = NEW lcl( ).
    &quot;Observers
    DATA(observer_add) = NEW lcl_addition( ).
    DATA(observer_subtract) = NEW lcl_subtraction( ).
    DATA(observer_multiply) = NEW lcl_multiplication( ).
    DATA(observer_divide) = NEW lcl_division( ).

    &quot;Setting numbers representing a change of the object state
    &quot;The method implementation includes a call to the notification method.
    oref_observed-&gt;set_numbers(
      value1 = 1
      value2 = 2 ).

    &quot;At this stage, there are no observers registered.
    DATA(log) = lcl=&gt;tab4display.

    out-&gt;write( data = log name = `log` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).
    CLEAR lcl=&gt;tab4display.

*&amp;-------------------------------------------------------------------------------------*
*&amp; 2) Registering observers
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |2) Registering observers\n\n| ).

    oref_observed-&gt;register( observer_add ).
    oref_observed-&gt;register( observer_subtract ).
    oref_observed-&gt;register( observer_multiply ).
    oref_observed-&gt;register( observer_divide ).

    oref_observed-&gt;set_numbers(
      value1 = 7
      value2 = 5 ).

    log = lcl=&gt;tab4display.

    out-&gt;write( data = log name = `log` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

    CLEAR lcl=&gt;tab4display.

*&amp;-------------------------------------------------------------------------------------*
*&amp; 3) Unregistering observers
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |3) Unregistering observers\n\n| ).

    oref_observed-&gt;unregister( observer_multiply ).
    oref_observed-&gt;unregister( observer_divide ).

    oref_observed-&gt;set_numbers(
      value1 = 15
      value2 = 3 ).

    log = lcl=&gt;tab4display.

    out-&gt;write( data = log name = `log` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

    CLEAR lcl=&gt;tab4display.

*&amp;-------------------------------------------------------------------------------------*
*&amp; 4) More example values
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |4) More example values\n\n| ).

    &quot;Registering the unregistered observers again
    oref_observed-&gt;register( observer_multiply ).
    oref_observed-&gt;register( observer_divide ).

    &quot;Creating an internal table holding two integer values per line
    TYPES: BEGIN OF struc_int,
             number1 TYPE i,
             number2 TYPE i,
           END OF struc_int.

    DATA numbers_tab TYPE TABLE OF struc_int WITH EMPTY KEY.

    numbers_tab = VALUE #( ( number1 = 1 number2 = 8 )
                           ( number1 = 50 number2 = 25 )
                           ( number1 = 100 number2 = 4 )
                           ( number1 = 24 number2 = 6 )
                           ( number1 = 35 number2 = 7 )
                           ( number1 = 2 number2 = 0 ) ).

    LOOP AT numbers_tab INTO DATA(wa).
      oref_observed-&gt;set_numbers(
        value1 = wa-number1
        value2 = wa-number2 ).

      APPEND INITIAL LINE TO lcl=&gt;tab4display.
    ENDLOOP.

    log = lcl=&gt;tab4display.

    out-&gt;write( data = log name = `log` ).
    out-&gt;write( |{ repeat( val = `*` occ = 75 ) }| ).
    out-&gt;write( |{ repeat( val = `*` occ = 75 ) }| ).
    out-&gt;write( |{ repeat( val = `*` occ = 75 ) }\n| ).

**********************************************************************
**********************************************************************
**********************************************************************

*&amp;-------------------------------------------------------------------------------------*
*&amp; Example 2
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |Example 2\n\n| ).

    out-&gt;write( |6) Registering event handlers\n\n| ).

    DATA(o1) = NEW lcl_evt( ).
    DATA iref1 TYPE REF TO lif_obs.
    iref1 = NEW lcl_obs_1( ).
    DATA iref2 TYPE REF TO lif_obs.
    iref2 = NEW lcl_obs_2( ).

    &quot;Registering event handlers
    SET HANDLER iref1-&gt;handle_event FOR o1.
    SET HANDLER iref2-&gt;handle_event FOR o1.

    o1-&gt;set_text( `AB` ).

    log = lcl_evt=&gt;tab4display.
    out-&gt;write( data = log name = `log` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

    CLEAR lcl_evt=&gt;tab4display.

**********************************************************************

    out-&gt;write( |7) Unregistering an event handler\n\n| ).

    SET HANDLER iref2-&gt;handle_event FOR o1 ACTIVATION &#x27; &#x27;.

    o1-&gt;set_text( `Hello AB` ).

    log = lcl_evt=&gt;tab4display.
    out-&gt;write( data = log name = `log` ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Example 1
*&amp;---------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp; Interface for observers
*&amp;---------------------------------------------------------------------*

INTERFACE lif_observer.
  METHODS: notify IMPORTING num1 TYPE i
                            num2 TYPE i
                            ts   TYPE utclong,
   calculate IMPORTING num1 TYPE i
                       num2 TYPE i
             RETURNING VALUE(result) TYPE string.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Class for observed object
*&amp;---------------------------------------------------------------------*

CLASS lcl DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS:
      set_numbers IMPORTING value1 TYPE i value2 TYPE i,
      register IMPORTING oref_observer TYPE REF TO lif_observer,
      unregister IMPORTING oref_observer TYPE REF TO lif_observer,
      notify_observers.

    &quot;String table for display purposes
    CLASS-DATA tab4display TYPE string_table.
  PROTECTED SECTION.
    DATA: observer_tab TYPE TABLE OF REF TO lif_observer,
          num1         TYPE i,
          num2         TYPE i.
ENDCLASS.

CLASS lcl IMPLEMENTATION.
  METHOD register.
    IF NOT line_exists( observer_tab[ table_line = oref_observer ] ).
      INSERT oref_observer INTO TABLE observer_tab.

      &quot;Populating a string table for display purposes.
      APPEND |Object reference for { cl_abap_typedescr=&gt;describe_by_object_ref( oref_observer )-&gt;get_relative_name( ) } inserted into observer table.| TO lcl=&gt;tab4display.
    ENDIF.
  ENDMETHOD.
  METHOD unregister.
    DELETE TABLE observer_tab FROM oref_observer.

    &quot;Populating a string table for display purposes.
    APPEND |Object reference for { cl_abap_typedescr=&gt;describe_by_object_ref( oref_observer )-&gt;get_relative_name( ) } removed from observer table.| TO lcl=&gt;tab4display.
  ENDMETHOD.

  METHOD notify_observers.
    LOOP AT observer_tab ASSIGNING FIELD-SYMBOL(&lt;fs&gt;).
      &lt;fs&gt;-&gt;notify( num1 = me-&gt;num1 num2 = me-&gt;num2 ts = utclong_current( ) ).
    ENDLOOP.
  ENDMETHOD.

  METHOD set_numbers.
    num1 = value1.
    num2 = value2.
    
    &quot;Populating a string table for display purposes.
    APPEND |The number values { num1 } and { num2 } were set in the observed object. Observers are about to be notified.| TO lcl=&gt;tab4display.
    APPEND INITIAL LINE TO lcl=&gt;tab4display.
    notify_observers( ).
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Classes for observers
*&amp;---------------------------------------------------------------------*

CLASS lcl_addition DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_observer.
ENDCLASS.

CLASS lcl_addition IMPLEMENTATION.
  METHOD lif_observer~notify.
    &quot;Populating a string table for display purposes.
    APPEND |lcl_addition: Observer notified at { ts }.| TO lcl=&gt;tab4display.

    lif_observer~calculate( num1 = num1 num2 = num2 ).
  ENDMETHOD.

  METHOD lif_observer~calculate.
    TRY.
        result = |{ num1 + num2 STYLE = SIMPLE }|.
      CATCH cx_sy_arithmetic_error INTO DATA(error).
        result = error-&gt;get_text( ).
    ENDTRY.

    &quot;Populating a string table for display purposes.
    APPEND `lcl_addition: lif_observer~calculate called.` TO lcl=&gt;tab4display.
    APPEND |{ num1 } + { num2 } = { result }| TO lcl=&gt;tab4display.
    APPEND INITIAL LINE TO lcl=&gt;tab4display.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

CLASS lcl_subtraction DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_observer.
ENDCLASS.

CLASS lcl_subtraction IMPLEMENTATION.
  METHOD lif_observer~notify.
    &quot;Populating a string table for display purposes.
    APPEND |lcl_subtraction: Observer notified at { ts }.| TO lcl=&gt;tab4display.

    lif_observer~calculate( num1 = num1 num2 = num2 ).
  ENDMETHOD.

  METHOD lif_observer~calculate.
    TRY.
        result = |{ num1 - num2 STYLE = SIMPLE }|.
      CATCH cx_sy_arithmetic_error INTO DATA(error).
        result = error-&gt;get_text( ).
    ENDTRY.

    &quot;Populating a string table for display purposes.
    APPEND `lcl_subtraction: lif_observer~calculate called.` TO lcl=&gt;tab4display.
    APPEND |{ num1 } - { num2 } = { result }| TO lcl=&gt;tab4display.
    APPEND INITIAL LINE TO lcl=&gt;tab4display.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

CLASS lcl_multiplication DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_observer.
ENDCLASS.

CLASS lcl_multiplication IMPLEMENTATION.
  METHOD lif_observer~notify.
    &quot;Populating a string table for display purposes.
    APPEND |lcl_multiplication: Observer notified at { ts }.| TO lcl=&gt;tab4display.

    lif_observer~calculate( num1 = num1 num2 = num2 ).
  ENDMETHOD.

  METHOD lif_observer~calculate.
    TRY.
        result = |{ num1 * num2 STYLE = SIMPLE }|.
      CATCH cx_sy_arithmetic_error INTO DATA(error).
        result = error-&gt;get_text( ).
    ENDTRY.

    &quot;Populating a string table for display purposes.
    APPEND `lcl_multiplication: lif_observer~calculate called.` TO lcl=&gt;tab4display.
    APPEND |{ num1 } * { num2 } = { result }| TO lcl=&gt;tab4display.
    APPEND INITIAL LINE TO lcl=&gt;tab4display.
  ENDMETHOD.
ENDCLASS.

**********************************************************************

CLASS lcl_division DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_observer.
ENDCLASS.

CLASS lcl_division IMPLEMENTATION.
  METHOD lif_observer~notify.
    &quot;Populating a string table for display purposes.
    APPEND |lcl_division: Observer notified at { ts }.| TO lcl=&gt;tab4display.

    lif_observer~calculate( num1 = num1 num2 = num2 ).
  ENDMETHOD.

  METHOD lif_observer~calculate.
    TRY.
        result = |{ CONV decfloat34( num1 / num2 ) STYLE = SIMPLE }|.
      CATCH cx_sy_arithmetic_error INTO DATA(error).
        result = error-&gt;get_text( ).
    ENDTRY.

    &quot;Populating a string table for display purposes.
    APPEND `lcl_division: lif_observer~calculate called.` TO lcl=&gt;tab4display.
    APPEND |{ num1 } / { num2 } = { result }| TO lcl=&gt;tab4display.
    APPEND INITIAL LINE TO lcl=&gt;tab4display.
  ENDMETHOD.

ENDCLASS.

**********************************************************************
**********************************************************************
**********************************************************************

*&amp;---------------------------------------------------------------------*
*&amp; Example 2
*&amp;---------------------------------------------------------------------*

CLASS lcl_evt DEFINITION.
  PUBLIC SECTION.
    METHODS set_text IMPORTING txt TYPE string.
    EVENTS evt EXPORTING VALUE(info) TYPE string.

    CLASS-DATA tab4display TYPE string_table.
  PROTECTED SECTION.
    DATA text TYPE string.
ENDCLASS.

CLASS lcl_evt IMPLEMENTATION.
  METHOD set_text.
    text = txt.

    &quot;Populating a string table for display purposes.
    APPEND |Object changed. &quot;text&quot; was assigned the value &quot;{ text }&quot;. Event is about to be raised.| TO lcl_evt=&gt;tab4display.
    APPEND INITIAL LINE TO lcl_evt=&gt;tab4display.

    RAISE EVENT evt EXPORTING info = txt.
  ENDMETHOD.
ENDCLASS.

INTERFACE lif_obs.
  METHODS:
    add_text IMPORTING txt TYPE string,
    handle_event FOR EVENT evt OF lcl_evt IMPORTING info.
  DATA some_text TYPE string.
ENDINTERFACE.

CLASS lcl_obs_1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_obs.
ENDCLASS.

CLASS lcl_obs_1 IMPLEMENTATION.

  METHOD lif_obs~handle_event.
    &quot;Populating a string table for display purposes.
    APPEND `lcl_obs_1: Event handled in lif_obs~handle_event.` TO lcl_evt=&gt;tab4display.
    APPEND |Text &quot;{ info }&quot; is about to be processed.| TO lcl_evt=&gt;tab4display.

    lif_obs~add_text( info ).
  ENDMETHOD.

  METHOD lif_obs~add_text.
    lif_obs~some_text = |{ txt }AP|.

    &quot;Populating a string table for display purposes.
    APPEND |Text was processed in lif_obs~add_text. Result: &quot;{ lif_obs~some_text }&quot;| TO lcl_evt=&gt;tab4display.
    APPEND INITIAL LINE TO lcl_evt=&gt;tab4display.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_obs_2 DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_obs.
ENDCLASS.

CLASS lcl_obs_2 IMPLEMENTATION.

  METHOD lif_obs~handle_event.
    &quot;Populating a string table for display purposes.
    APPEND `lcl_obs_2: Event handled in lif_obs~handle_event.` TO lcl_evt=&gt;tab4display.
    APPEND |Text &quot;{ info }&quot; is about to be processed.| TO lcl_evt=&gt;tab4display.

    lif_obs~add_text( info ).
  ENDMETHOD.

  METHOD lif_obs~add_text.
    lif_obs~some_text = |{ txt }CDEFGHIJKLMNOPQRSTUVWXYZ|.

    &quot;Populating a string table for display purposes.
    APPEND |Text was processed in lif_obs~add_text. Result: &quot;{ lif_obs~some_text }&quot;| TO lcl_evt=&gt;tab4display.
    APPEND INITIAL LINE TO lcl_evt=&gt;tab4display.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Prototype</h2>
<ul>
<li>The prototype design pattern suggests that you can clone objects to create copies of existing objects of classes.</li>
<li>Cloning objects lets you preserve, reuse, and enhance an object&#x27;s current state without altering the original prototype.</li>
<li>This is especially useful when you want to delegate the task of object creation, particulary when the creation involves complex steps, instead of doing it manually. In cases where you need similar or the same objects, the prototype pattern simplifies and automates object creation, ensuring a consistent approach with the prototype providing a predefined state.</li>
<li>Reusing and enhancing prototypes allows you to create variants of original objects. This pattern offers an alternative to complex inheritance trees, with object variants created through subclasses.</li>
<li>In the pattern, prototype objects handle their own cloning. This can be done by providing a shared interface for all clonable objects. The interface may include a clone method. This clone method can be implemented to copy the entire state of the current object, including private attributes, or exclude attributes that should not be cloned. Instead of manually cloning objects to achieve a specific initial state, the prototype takes over the cloning, allowing users to easily retrieve the objects.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The simplified example illustrates the prototype design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the <code>CCIMP</code> are relevant for the for conceptual considerations.</li>
<li>The global class represents the user who creates objects of prototype classes and requires clones of these classes.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Interface <code>lif_prototype</code></li>
<li>Serves as the common interface for all prototype classes, enforcing the implementation of the <code>clone</code> method.</li>
<li>This method allows the creation of an clone of an object of a class that implements this interface.</li>
<li>It returns a new reference, representing the object clone.</li>
<li>Class <code>lcl_prototype_1</code></li>
<li>This demo class implements the <code>lif_prototype</code> interface that allows users to retrieve a clone of an object from the class.</li>
<li>Contains various class attributes and methods. Methods such as <code>do_something</code> modify the value of class attributes.</li>
<li>The constructor (or any other part of the class that modifies the object&#x27;s state) assumes there may be complex operations involved. However, this simplified example only assigns values to class attributes to demonstrate object cloning and enhancement.</li>
<li>The clone method <code>lif_prototype~clone</code> creates a clone of the current object by instantiating a new class instance with the <code>NEW</code> operator and copying the class attribute values. This example selectively clones certain attributes, showcasing a predefined state for the cloned object.</li>
<li>Class <code>lcl_prototype_2</code></li>
<li>This class is structured similarly to <code>lcl_prototype_1</code>, but it features different attributes and behaviors.</li>
<li>The class execution includes the following:</li>
<li>The global class contains several method calls and class attribute accesses, demonstrating the prototype pattern. Both local classes, <code>lcl_prototype_1</code> and <code>lcl_prototype_2</code>, are included.</li>
<li>Steps 1 and 4: Create objects of the prototype classes. Methods are called and class attributes are accessed to show changes in attribute values, resulting in specific object states.</li>
<li>Steps 2 and 5: Clone objects using the <code>clone</code> method, which creates copies of existing objects. The assumption is that the user needs a copy of the object to reuse a specific state instead of creating a new object from scratch.</li>
<li>Steps 3 and 6: Enhance the cloned objects. This involves casting to the prototype class to access its attributes and methods. The assumption is to create a variant of the object by modifying its attributes while using the original state as a foundation. Working with the variant involves a separate object, distinct from the original. A demo attribute shows that the clone method can be implemented to allow selective cloning, excluding certain attribute values.</li>
<li>The example outputs various class attributes to illustrate both the original object states and the enhanced clone object states.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.



CLASS zcl_demo_abap IMPLEMENTATION.

  METHOD if_oo_adt_classrun~main.

    out-&gt;write( |1) Processing original object (prototype 1) \n\n| ).

    &quot;Notes:
    &quot;- Creating objects of the prototype classes.
    &quot;- Methods are called and class attributes are accessed to show changes in attribute values,
    &quot;  resulting in specific object states.

    DATA(oref_1) = NEW lcl_prototype_1( str = `ABC` ).
    oref_1-&gt;do_something( `DEF` ).
    DATA(content) = oref_1-&gt;return_data( ).
    DATA(num) = oref_1-&gt;number.
    DATA(txt) = oref_1-&gt;txt.

    &quot;Displaying content
    out-&gt;write( data = content name = `content` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = num name = `num` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = txt name = `txt` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |2) Cloning prototype (1) \n\n| ).

    &quot;Notes:
    &quot;- Cloning objects using the clone method, which creates copies of existing
    &quot;  objects.
    &quot;- The assumption is that the user needs a copy of the object to reuse a
    &quot;  specific state instead of creating a new object from scratch.
    &quot;- At this stage, the cloned object has the same state as the original object.

    DATA(oref_2) = oref_1-&gt;lif_prototype~clone( ).

    &quot;Displaying the public class atrributes
    out-&gt;write( data = oref_2 name = `oref_2` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |3) Enhancing cloned prototype (1) \n\n| ).

    &quot;Notes:
    &quot;- Enhancing the cloned objects.
    &quot;- This involves casting to the prototype class to access its attributes
    &quot;  and methods.
    &quot;- The assumption is to create a variant of the object by modifying its
    &quot;  attributes while using the original state as a foundation.
    &quot;- Working with the variant involves a separate object, distinct from the original.
    &quot;  A demo attribute shows that the clone method can be implemented to allow selective
    &quot;  cloning, excluding certain attribute values.

    DATA(oref_3) = CAST lcl_prototype_1( oref_2 ).
    content = oref_3-&gt;return_data( ).
    num = oref_3-&gt;number.
    txt = oref_3-&gt;txt.

    &quot;Displaying content (original state)
    out-&gt;write( data = content name = `content` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = num name = `num` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = txt name = `txt` ).
    out-&gt;write( |\n\n| ).

    &quot;Enhancing the cloned object
    oref_3-&gt;do_something( `GHI` ).
    content = oref_3-&gt;return_data( ).
    num = oref_3-&gt;number.
    txt = oref_3-&gt;txt.

    &quot;Displaying content (enhanced state)
    out-&gt;write( data = content name = `content` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = num name = `num` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = txt name = `txt` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |4) Processing original object (prototype 2) \n\n| ).

    &quot;Notes:
    &quot;- Creating objects of the prototype classes.
    &quot;- Methods are called and class attributes are accessed to show changes in attribute values,
    &quot;  resulting in specific object states.

    DATA(oref_4) = NEW lcl_prototype_2( `JKL` ).
    oref_4-&gt;do_another_thing( `MNO` ).
    DATA(tab) = oref_4-&gt;tab.
    DATA(string) = oref_4-&gt;string.
    DATA(state) = oref_4-&gt;get_state( ).

    &quot;Displaying content
    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = string name = `string` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = state name = `state` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |5) Cloning prototype (2) \n\n| ).

    &quot;Notes:
    &quot;- Cloning objects using the clone method, which creates copies of existing
    &quot;  objects.
    &quot;- The assumption is that the user needs a copy of the object to reuse a
    &quot;  specific state instead of creating a new object from scratch.
    &quot;- At this stage, the cloned object has the same state as the original object.

    DATA(oref_5) = oref_4-&gt;lif_prototype~clone( ).

    &quot;Displaying the public class atrributes
    out-&gt;write( data = oref_5 name = `oref_5` ).
    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |6) Enhancing cloned prototype (2) \n\n| ).

    &quot;Notes:
    &quot;- Enhancing the cloned objects.
    &quot;- This involves casting to the prototype class to access its attributes
    &quot;  and methods.
    &quot;- The assumption is to create a variant of the object by modifying its
    &quot;  attributes while using the original state as a foundation.
    &quot;- Working with the variant involves a separate object, distinct from the original.
    &quot;  A demo attribute shows that the clone method can be implemented to allow selective
    &quot;  cloning, excluding certain attribute values.

    DATA(oref_6) = CAST lcl_prototype_2( oref_5 ).
    tab = oref_6-&gt;tab.
    string = oref_6-&gt;string.
    state = oref_6-&gt;get_state( ).

    &quot;Displaying content (original state)
    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = string name = `string` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = state name = `state` ).
    out-&gt;write( |\n\n| ).

    &quot;Enhancing the cloned object
    oref_6-&gt;do_another_thing( `PQR` ).
    tab = oref_6-&gt;tab.
    string = oref_6-&gt;string.
    state = oref_6-&gt;get_state( ).

    &quot;Displaying content (enhanced state)
    out-&gt;write( data = tab name = `tab` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = string name = `string` ).
    out-&gt;write( |\n| ).
    out-&gt;write( data = state name = `state` ).
  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Interface serving as the common interface for prototypes
*&amp;---------------------------------------------------------------------*
&quot;- The interface serves as the common interface for all prototype classes,
&quot;  enforcing the implementation of the clone method.
&quot;- This method allows the creation of an clone of an object of a class that
&quot;  implements this interface.
&quot;- It returns a new reference, representing the object clone.

INTERFACE lif_prototype.
  METHODS clone RETURNING VALUE(ref) TYPE REF TO lif_prototype.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Prototype class 1
*&amp;---------------------------------------------------------------------*
&quot;- This demo class implements the lif_prototype interface that allows users
&quot;  to retrieve a clone of an object from the class.
&quot;- Contains various class attributes and methods. Methods such as &#x27;do_something&#x27;
&quot;  modify the value of class attributes.

CLASS lcl_prototype_1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_prototype.
    METHODS constructor IMPORTING str TYPE string.
    METHODS do_something IMPORTING text TYPE string.
    METHODS return_data RETURNING VALUE(str) TYPE string.

    DATA number TYPE i.
    DATA txt TYPE string.
    DATA itab TYPE string_table.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA private_text TYPE string.
ENDCLASS.

CLASS lcl_prototype_1 IMPLEMENTATION.

  METHOD constructor.
    &quot;The constructor (or any other part of the class that modifies the object&#x27;s state) assumes
    &quot;there may be complex operations involved. However, this simplified example only assigns
    &quot;values to class attributes to demonstrate object cloning and enhancement.

    txt = str.
    private_text = `#`.
    itab = VALUE #( ( |{ txt } (added at { utclong_current( ) })| ) ).
  ENDMETHOD.

  METHOD lif_prototype~clone.
    &quot;Creating a clone of the current object by instantiating a new class instance with the NEW
    &quot;operator and copying the class attribute values. This example selectively clones certain
    &quot;attributes, showcasing a predefined state for the cloned object.

    DATA(obj_ref) = NEW lcl_prototype_1( txt ).
    obj_ref-&gt;itab = me-&gt;itab.
    obj_ref-&gt;txt = me-&gt;txt.
    obj_ref-&gt;private_text = me-&gt;private_text.
    ref = obj_ref.
  ENDMETHOD.

  METHOD do_something.
    &quot;The demo implementation includes some simple class attribute modifications.

    APPEND |{ text } (added at { utclong_current( ) })| TO itab.
    number += 1.
    txt &amp;&amp;= `!`.
    private_text &amp;&amp;= `#`.
  ENDMETHOD.

  METHOD return_data.
    &quot;The demo implementation returns the content of the string table as string.
    &quot;Additionally and for display purposes, the content of a private attribute
    &quot;is added to the result string.

    str = concat_lines_of( table = itab sep = |\n| ).
    str &amp;&amp;= |\nprivate_text = &quot;{ private_text }&quot;|.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Prototype class 2
*&amp;---------------------------------------------------------------------*
&quot;- This demo class implements the lif_prototype interface that allows users
&quot;  to retrieve a clone of an object from the class.
&quot;- It is structured similarly to lcl_prototype_1, but it features different
&quot;  attributes and behaviors.

CLASS lcl_prototype_2 DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_prototype.
    METHODS constructor IMPORTING t TYPE string.
    METHODS do_another_thing IMPORTING text TYPE string.
    METHODS get_state RETURNING VALUE(state) TYPE string.

    DATA string TYPE string.
    DATA tab TYPE string_table.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA private_integer TYPE i.
ENDCLASS.

CLASS lcl_prototype_2 IMPLEMENTATION.

  METHOD constructor.
    string = t.
    tab = VALUE #( ( |{ string } (added at { utclong_current( ) }| ) ).
  ENDMETHOD.

  METHOD lif_prototype~clone.
    DATA(obj_ref) = NEW lcl_prototype_2( string ).
    obj_ref-&gt;tab = me-&gt;tab.
    obj_ref-&gt;string = me-&gt;string.
    ref = obj_ref.
  ENDMETHOD.

  METHOD do_another_thing.
    APPEND |{ text } (added at { utclong_current( ) })| TO tab.
    private_integer += 1.
    string &amp;&amp;= `#`.
  ENDMETHOD.

  METHOD get_state.
    &quot;This demo implementation is intended to visualize enhancement of cloned objects.
    &quot;In this case, the value of the private attribute is evaluated.
    IF private_integer &gt; 0.
      state = |State changed. Value of &quot;private_integer&quot;: { private_integer }|.
    ELSE.
      state = |State not changed. Value of &quot;private_integer&quot;: { private_integer }|.
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Proxy</h2>
<ul>
<li>The proxy design pattern proposes that an object of a class serves as a surrogate for another object.</li>
<li>This means users interact with objects of a proxy class instead of interacting directly with an object of the original class.</li>
<li>In this way, the proxy class can delegate and forward access to the original class as if users were working directly with it.</li>
<li>Among the use cases for this design pattern is access control. A proxy class manages and restricts access to objects of another class, particularly for sensitive operations that only authorized users should perform. This setup prevents unauthorized access to the original class, ensuring that its methods cannot be called through the proxy. Additionally, you can enhance the proxy class with features like a logging mechanism that the original class does not provide, without modifying the original class itself. Other potential use cases include proxy classes that serve as surrogates for objects located in remote destinations, allowing interaction with remote objects through these proxies.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The simplified example illustrates an access control context where only authorized users can retrieve data via a proxy class.</li>
<li>This example demonstrates the proxy design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface, so the class can be run using F9 in ADT.</li>
<li>Serves as a vehicle for showcasing the design pattern. The declarations and implementations in the CCIMP include are relevant for conceptual considerations.</li>
<li>The implementation includes multiple access attempts, i.e. method calls, through the proxy class. If authorized, the calls are delegated to the original class. It includes both successful and discarded calls, and finally, it retrieves and displays the content of a log table.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Interface <code>lif_user_info</code>: Defines the common interface for both the original and proxy classes.</li>
<li>Class <code>lcl_user_info</code>: Represents the original class that implements the interface and contains the logic for retrieving user information.</li>
<li>Class <code>lcl_proxy</code>:</li>
<li>Represents the proxy class.</li>
<li>Implements the interface to serve as a surrogate of the original class. So, users interact with this class instead of the the original class.</li>
<li>The class maintains a reference to the original class and delegates requests to it. The logic can only be executed, and data can only be retrieved if authentication validation succeeds. The example uses hardcoded demo values for usernames and passwords. If validation fails, an object of the original class cannot be created, an exception is raised (local exception class <code>lcx_error</code>).</li>
<li>The original class, <code>lcl_user_info</code>, is declared with <code>CREATE PRIVATE</code> to prevent external object creation. Only the class itself and its friends can instantiate objects, which is why the proxy class is declared as a friend of the class.</li>
<li>The proxy class includes additional functionality by implementing a simple logging mechanism. In this example, logging is achieved through entries in an internal table, which is a static component to track all access attempts from the internal session. Logging to a database table for permanent storage may be an option.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.

  METHOD if_oo_adt_classrun~main.

    out-&gt;write( `User that is allowed to get user info` ).
    TRY.
        DATA(oref_power_user) = NEW lcl_proxy( username = `power_user` password = `abc123` ).
        DATA(info_a) = oref_power_user-&gt;lif_user_info~get_user_info( user_id = `A0001` ).
        DATA(info_b) = oref_power_user-&gt;lif_user_info~get_user_info( user_id = `A0002` ).

        out-&gt;write( info_a ).
        out-&gt;write( info_b ).
      CATCH lcx_error INTO DATA(error).
        out-&gt;write( error-&gt;get_text( ) ).
    ENDTRY.

    out-&gt;write( |\n| ).
    out-&gt;write( `User that is not allowed to get user info` ).
    TRY.
        DATA(oref_other_user) = NEW lcl_proxy( username = `other_user` password = `some_pw` ).
        DATA(info_c) = oref_other_user-&gt;lif_user_info~get_user_info( user_id = `A0003` ).
        DATA(info_d) = oref_other_user-&gt;lif_user_info~get_user_info( user_id = `A0004` ).

        out-&gt;write( info_c ).
        out-&gt;write( info_d ).
      CATCH lcx_error INTO error.
        out-&gt;write( error-&gt;get_text( ) ).
    ENDTRY.

    out-&gt;write( |\n| ).
    out-&gt;write( `Wrong credentials` ).
    TRY.
        DATA(oref_typo) = NEW lcl_proxy( username = `power_user` password = `abc1234` ).
        DATA(info_e) = oref_typo-&gt;lif_user_info~get_user_info( user_id = `A0005` ).
        DATA(info_f) = oref_typo-&gt;lif_user_info~get_user_info( user_id = `A0006` ).

        out-&gt;write( info_e ).
        out-&gt;write( info_f ).
      CATCH lcx_error INTO error.
        out-&gt;write( error-&gt;get_text( ) ).
    ENDTRY.

    out-&gt;write( |\n| ).
    out-&gt;write( `Log` ).
    DATA(log) = lcl_proxy=&gt;get_log( ).
    out-&gt;write( log ).

  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Interface serving as the common interface for both the original
*&amp; and proxy classes
*&amp;---------------------------------------------------------------------*

INTERFACE lif_user_info.
  METHODS get_user_info IMPORTING user_id     TYPE string
                        RETURNING VALUE(info) TYPE string.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Local exception class for errors due to failed authorization
*&amp; validations
*&amp;---------------------------------------------------------------------*

CLASS lcx_error DEFINITION INHERITING FROM cx_static_check.
  PUBLIC SECTION.
    INTERFACES if_t100_dyn_msg.

    DATA text TYPE string READ-ONLY.

    METHODS constructor
      IMPORTING
        textid   LIKE if_t100_message=&gt;t100key OPTIONAL
        previous LIKE previous OPTIONAL
        text     TYPE string OPTIONAL.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcx_error IMPLEMENTATION.
  METHOD constructor ##ADT_SUPPRESS_GENERATION.
    super-&gt;constructor( previous = previous ).

    me-&gt;text = text.
    CLEAR me-&gt;textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=&gt;default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Original class
*&amp;---------------------------------------------------------------------*

&quot;- Contains the business logic for retrieving user information
&quot;- Declared with CREATE PRIVATE to prevent external object creation. Only the
&quot;  class itself and its friends can instantiate objects, which is why the proxy
&quot;  class is declared as a friend of the class. Since the proxy class is not
&quot;  known yet in the CCIMP include, the class declaration is deferred.

CLASS lcl_proxy DEFINITION DEFERRED.

CLASS lcl_user_info DEFINITION CREATE PRIVATE FRIENDS lcl_proxy.
  PUBLIC SECTION.
    INTERFACES lif_user_info.
  PRIVATE SECTION.
    &quot;For demo purposes, adding hardcoded values for a user authorized
    &quot;to retrieve the data.
    CONSTANTS: user_name TYPE string VALUE `power_user`,
               pw        TYPE string VALUE `abc123`.
ENDCLASS.

CLASS lcl_user_info IMPLEMENTATION.
  METHOD lif_user_info~get_user_info.

    &quot;Here goes an operation to get user information.
*    SELECT user_id, info_a, info_b
*     FROM some_data_source
*     WHERE user_id = @user_id
*     INTO ...

    info = |Information for user { user_id }: Some information ...|.

  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Proxy class
*&amp;---------------------------------------------------------------------*

&quot;- Implements the interface to serve as a surrogate of the original class.
&quot;  So, users interact with this class instead of the the original class.
&quot;- Maintains a reference to the original class and delegates requests to it.
&quot;  The business logic can only be executed, and data can only be retrieved
&quot;  if authentication validation succeeds. If validation fails, the an object
&quot;  of the original class cannot be created, and exception is raised.
&quot;- Extra functionality is added to the proxy class by implementing a
&quot;  simplified logging mechanism, realized by an internal table in the example.
CLASS lcl_proxy DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_user_info.
    METHODS constructor IMPORTING username TYPE string
                                  password TYPE string
                        RAISING   lcx_error.

    TYPES: BEGIN OF ty_log,
             user           TYPE string,
             time_stamp     TYPE utclong,
             access_granted TYPE abap_boolean,
           END OF ty_log,
           tt_log TYPE TABLE OF ty_log WITH EMPTY KEY.

    CLASS-METHODS: add_log_entry IMPORTING user_name      TYPE string
                                           time_stamp     TYPE utclong
                                           access_granted TYPE abap_boolean,
                   get_log RETURNING VALUE(log) TYPE tt_log.

  PRIVATE SECTION.

    DATA oref TYPE REF TO lcl_user_info..
    CLASS-DATA log_tab TYPE tt_log.
ENDCLASS.

CLASS lcl_proxy IMPLEMENTATION.
  METHOD constructor.

    &quot;Here goes a proper authorization check ...
    &quot;The simplified example includes a dummy authorization check.
    IF username = lcl_user_info=&gt;user_name AND password = lcl_user_info=&gt;pw.
      &quot;Adding a log entry
      add_log_entry( user_name = username time_stamp = utclong_current( ) access_granted = abap_true ).

      &quot;Instantiating the original class
      oref = NEW #( ).
    ELSE.
      &quot;Add log entry
      add_log_entry( user_name = username time_stamp = utclong_current( ) access_granted = abap_false ).

      &quot;Dummy authentication failed
      RAISE EXCEPTION TYPE lcx_error.
    ENDIF.

  ENDMETHOD.

  METHOD lif_user_info~get_user_info.
    &quot;Calling a method of the original class via the proxy class
    &quot;The calling is only possible if the authorization validation was successful
    &quot;and an instance was created.
    TRY.
        info = oref-&gt;lif_user_info~get_user_info( user_id ).
      CATCH cx_sy_ref_is_initial.
        info = `No authorization`.
    ENDTRY.
  ENDMETHOD.

  METHOD add_log_entry.
    APPEND VALUE #( user = user_name time_stamp = time_stamp access_granted = access_granted ) TO log_tab.
  ENDMETHOD.

  METHOD get_log.
    log = log_tab.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Singleton</h2>
<ul>
<li>Used to restrict external users from instantiating a class.</li>
<li>This is typically achieved by using the <code>CREATE PRIVATE</code> addition in a class definition, preventing object creation outside the class. A factory method, often a static method, then provides users with an instance of the class. The singleton pattern ensures only one instance per class within an internal session.</li>
<li>Example of a predefined ABAP class: <code>CL_IXML_CORE</code>.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>This example demonstrates the singleton design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from a local class.</li>
<li>Acts as a consumer of an API (a local class) defined in the CCIMP include.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Contains the local class <code>lcl_singleton</code>, which provides the static factory method <code>get_obj</code> that supplies consumers with an instance (a single instance in this case) of the <code>lcl_singleton</code> class.</li>
<li>Specifies the <code>CREATE PRIVATE</code> addition to prevent instance creation outside the class.</li>
<li>The <code>get_obj</code> method checks for an existing instance of the <code>lcl_singleton</code> class. If it exists, it returns that instance; otherwise, it creates and returns a new instance. A private static attribute stores the reference to this instance.</li>
<li>To demonstrate the singleton pattern, an internal table, which represents a log table, is filled when calling the <code>add_log</code> method and providing some text. The content of the table is returned when the consumer (the example global class) calls the <code>get_log</code> method. The <code>get_obj</code> is called several times, i.e. multiple object reference variables were assigned the reference to the single instance of the class. Yet, the table content returned at the end of the example shows the same content for all method calls via different object reference variables. It shows consistent data across object reference variables (i.e. the table has not been filled anew etc.). This way, a consistent logging is ensured within an internal session, throughout class execution.</li>
<li>Furthermore, the class implements both static and instance constructors. These constructors log time stamps and set static and instance attributes. The table that stores object reference variable names and time stamp values (created in the global class) and that is output to the console shows that the time stamps have not changed throughout the class execution, especially the time stamp set when calling the instance constructor, which is indeed called only once.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    &quot;Internal table to store and display object reference variable names and
    &quot;time stamp values
    TYPES: BEGIN OF s_ts,
             name               TYPE string,
             timestamp_static   TYPE utclong,
             timestamp_instance TYPE utclong,
           END OF s_ts.
    DATA ts_tab TYPE TABLE OF s_ts WITH EMPTY KEY.

    &quot;Object creation as follows is not possible
    &quot;DATA(oref) = NEW lcl_singleton( ).

    &quot;Creating object
    DATA(oref1) = lcl_singleton=&gt;get_obj( ).

    &quot;Retrieving time stamps, and adding the values to the internal table created above
    &quot;for display purposes
    oref1-&gt;get_timestamps( IMPORTING ts_static   = DATA(ts_static)
                                     ts_instance = DATA(ts_instance) ).
    APPEND VALUE #( name = `oref1` timestamp_static = ts_static timestamp_instance = ts_instance ) TO ts_tab.

    &quot;Adding entries to a log table (represented by a private static attribute in the local class)
    oref1-&gt;add_log( |Text 1 added at { utclong_current( ) } (using oref1)| ).
    oref1-&gt;add_log( |Text 2 added at { utclong_current( ) } (using oref1)| ).

    &quot;Creating more objects (however, the one created previously is returned) and adding entries
    &quot;to the log table
    &quot;Time stamp values are also added the to the internal table for display purposes
    DATA(oref2) = lcl_singleton=&gt;get_obj( ).

    oref2-&gt;get_timestamps( IMPORTING ts_static   = ts_static
                                     ts_instance = ts_instance ).
    APPEND VALUE #( name = `oref2` timestamp_static = ts_static timestamp_instance = ts_instance ) TO ts_tab.

    oref2-&gt;add_log( |Text 3 added at { utclong_current( ) } (using oref2)| ).
    oref2-&gt;add_log( |Text 4 added at { utclong_current( ) } (using oref2)| ).

    oref1-&gt;add_log( |Text 5 added at { utclong_current( ) } (using oref1)| ).

    DATA(oref3) = lcl_singleton=&gt;get_obj( ).

    oref3-&gt;get_timestamps( IMPORTING ts_static   = ts_static
                                     ts_instance = ts_instance ).
    APPEND VALUE #( name = `oref3` timestamp_static = ts_static timestamp_instance = ts_instance ) TO ts_tab.

    oref3-&gt;add_log( |Text 6 added at { utclong_current( ) } (using oref3)| ).
    oref3-&gt;add_log( |Text 7 added at { utclong_current( ) } (using oref3)| ).

    oref1-&gt;add_log( |Text 8 added at { utclong_current( ) } (using oref1)| ).
    oref2-&gt;add_log( |Text 9 added at { utclong_current( ) } (using oref2)| ).
    oref3-&gt;add_log( |Text 10 added at { utclong_current( ) } (using oref3)| ).

    DATA(oref4) = lcl_singleton=&gt;get_obj( ).

    oref4-&gt;get_timestamps( IMPORTING ts_static   = ts_static
                                     ts_instance = ts_instance ).
    APPEND VALUE #( name = `oref4` timestamp_static = ts_static timestamp_instance = ts_instance ) TO ts_tab.

    oref4-&gt;add_log( |Text 11 added at { utclong_current( ) } (using oref4)| ).
    oref4-&gt;add_log( |Text 12 added at { utclong_current( ) } (using oref4)| ).

    &quot;Retrieving the content of the log table per object
    &quot;However, as it is one and the same object that is dealt with, the content is the same.
    DATA(log1) = oref1-&gt;get_log( ).
    DATA(log2) = oref2-&gt;get_log( ).
    DATA(log3) = oref3-&gt;get_log( ).

    out-&gt;write( log1 ).
    out-&gt;write( |\n| ).

    ASSERT log1 = log2.
    ASSERT log1 = log3.

    &quot;Displaying the time stamps visualizing the singleton pattern
    SORT ts_tab BY name ASCENDING.
    out-&gt;write( ts_tab ).

  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl_singleton DEFINITION CREATE PRIVATE.

  PUBLIC SECTION.
    CLASS-METHODS get_obj RETURNING VALUE(obj) TYPE REF TO lcl_singleton.

    METHODS add_log IMPORTING text TYPE string.
    METHODS get_log RETURNING VALUE(log) TYPE string_table.
    METHODS get_timestamps EXPORTING ts_static   TYPE utclong
                                     ts_instance TYPE utclong.

    CLASS-METHODS class_constructor.
    METHODS constructor.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-DATA oref TYPE REF TO lcl_singleton.
    CLASS-DATA log_table TYPE string_table.
    CLASS-DATA timestamp_static TYPE utclong.
    DATA timestamp_instance TYPE utclong.
ENDCLASS.

CLASS lcl_singleton IMPLEMENTATION.
  METHOD get_obj.
    IF oref IS NOT BOUND.
      oref = NEW lcl_singleton( ).
    ENDIF.

    obj = oref.
  ENDMETHOD.

  METHOD add_log.
    INSERT text INTO TABLE log_table.
  ENDMETHOD.

  METHOD get_log.
    log = log_table.
  ENDMETHOD.

  METHOD get_timestamps.
    ts_static = timestamp_static.
    ts_instance = timestamp_instance.
  ENDMETHOD.

  METHOD class_constructor.
    timestamp_static = utclong_current( ).
  ENDMETHOD.

  METHOD constructor.
    timestamp_instance = utclong_current( ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>State</h2>
<ul>
<li>The state of an object can be considered a specific situation that affects its behavior. So, an object&#x27;s behavior depends on its current state.</li>
<li>The state design pattern allows an object of a class to have different states, enabling it to change its behavior dynamically during runtime based on its current state.</li>
<li>A potential setup, illustrated in the following example, may look like this:</li>
<li>A class is defined whose objects&#x27; behavior changes. This class may manage the current state by storing a reference to the current state object as an attribute. Based on the current state, it forwards state-specific behavior calls to this object.</li>
<li>An interface is defined that declares methods whose concrete implementations represent behaviors related to different states.</li>
<li>Concrete state classes implement the interface, including code for the distinct behaviors for each state in the interface methods.</li>
<li>The actual state transitions, which enable the execution of different functionalities, may be implemented in various ways. The following example includes two approaches:</li>
<li>Delegating the task to the client, which is the global class in the example</li>
<li>Implementing state transitions within the class whose objects&#x27; behavior changes based on external input</li>
<li>The design pattern can be useful when you want to organize state-specific functionality in dedicated classes, enhancing maintenance and extensibility while reducing class complexity, aimed at not overcrowding classes with extensive code. It can also help avoid complex and repeated conditional logic.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example demonstrates the state design pattern through the following declarations and implementations. Note that this example is oversimplified, and multiple class setup strategies may apply. It uses a mathematical context to allow objects of the <code>lcl_math</code> and <code>lcl_math_cond</code> classes to perform mathematical operations. The object&#x27;s behavior changes dynamically based on its current state or a condition.</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as the client for demonstrating the design pattern. The declarations and implementations in the <em>CCIMP include</em> are relevant for conceptual considerations.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Interface <code>lif_calc</code>: Defines the shared interface for concrete state classes, including the <code>calculate</code> method for performing arithmetic operations. Each state class implements this method differently.</li>
<li>Concrete state classes <code>lcl_state_addition</code>, <code>lcl_state_subtraction</code>, and <code>lcl_state_multiplication</code>: These classes implement the <code>lif_calc</code> interface and perform specific and simple calculations.</li>
<li><code>lcl_math</code>:</li>
<li>Represents the class whose objects&#x27; behavior changes.</li>
<li>Declares private attributes, including the <code>state_ref</code> reference variable that holds the current object state, referencing an object that implements <code>lif_calc</code>.</li>
<li>The <code>set_state</code> method updates the current state in <code>state_ref</code>. To work with the latest calculation result, the resulting values are assigned accordingly.</li>
<li>The <code>execute</code> method calls the <code>calculate</code> method of the current state (if the reference variable is bound) and returns the result.</li>
<li>The <code>lcl_math_cond</code> class is similar to <code>lcl_math</code>, but it handles state transitions through conditional logic, and includes the object creation in the class itself.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.


CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;---------------------------------------------------------------------*
*&amp; Example 1
*&amp;---------------------------------------------------------------------*

    &quot;In Example 1, the client transitions the states of the objects by
    &quot;passing instances of the state classes to the set_state method.
    &quot;The example begins with the creation of an object of the lcl_math
    &quot;class. Its constructor expects an integer value, which serves as the
    &quot;first operand for the calculation. The example method calls illustrate
    &quot;several state transitions. When executing the execute method, the
    &quot;second operand is provided as an argument, and the calculation is
    &quot;performed based on the current state.

    DATA(oref) = NEW lcl_math( 15 ).

    &quot;Performing additions by transitioning the state
    DATA(oref_add) = NEW lcl_state_addition( ).

    oref-&gt;set_state( oref_add ).
    DATA(result) = oref-&gt;execute( 5 ).
    out-&gt;write( result ).

    result = oref-&gt;execute( 10 ).
    out-&gt;write( result ).

    result = oref-&gt;execute( 40 ).
    out-&gt;write( result ).

    &quot;Performing subtractions by transitioning the state
    DATA(oref_sub) = NEW lcl_state_subtraction( ).

    oref-&gt;set_state( oref_sub ).
    result = oref-&gt;execute( 10 ).
    out-&gt;write( result ).

    result = oref-&gt;execute( 80 ).
    out-&gt;write( result ).

    &quot;Transitioning the state back to perform an addition
    oref-&gt;set_state( oref_add ).

    result = oref-&gt;execute( 25 ).
    out-&gt;write( result ).

    &quot;Performing multiplications by transitioning the state
    DATA(oref_mul) = NEW lcl_state_multiplication( ).

    oref-&gt;set_state( oref_mul ).
    result = oref-&gt;execute( 5 ).
    out-&gt;write( result ).

    result = oref-&gt;execute( 4 ).
    out-&gt;write( result ).

    &quot;Transitioning the state back to perform a subtraction
    oref-&gt;set_state( oref_sub ).
    result = oref-&gt;execute( 99 ).
    out-&gt;write( result ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 70 ) }\n\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; Example 2
*&amp;---------------------------------------------------------------------*

    &quot;Example 2 is similar to Example 1, and yields the same results. Here,
    &quot;the state transitions are performed by the class whose objects&#x27; behavior
    &quot;changes, based on external input. In this case, the input is realized by
    &quot;passing an enumeration type, which is evaluated in the class.

    DATA(oref_cond) = NEW lcl_math_cond( 15 ).

    oref_cond-&gt;set_state( lcl_math_cond=&gt;plus ).

    result = oref_cond-&gt;execute( 5 ).
    out-&gt;write( result ).

    result = oref_cond-&gt;execute( 10 ).
    out-&gt;write( result ).

    result = oref_cond-&gt;execute( 40 ).
    out-&gt;write( result ).

    oref_cond-&gt;set_state( lcl_math_cond=&gt;minus ).

    result = oref_cond-&gt;execute( 10 ).
    out-&gt;write( result ).

    result = oref_cond-&gt;execute( 80 ).
    out-&gt;write( result ).

    oref_cond-&gt;set_state( lcl_math_cond=&gt;plus ).

    result = oref_cond-&gt;execute( 25 ).
    out-&gt;write( result ).

    oref_cond-&gt;set_state( lcl_math_cond=&gt;multiply ).

    result = oref_cond-&gt;execute( 5 ).
    out-&gt;write( result ).

    result = oref_cond-&gt;execute( 4 ).
    out-&gt;write( result ).

    oref_cond-&gt;set_state( lcl_math_cond=&gt;minus ).

    result = oref_cond-&gt;execute( 99 ).
    out-&gt;write( result ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; State interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_calc.
  DATA number TYPE i.
  METHODS calculate IMPORTING value         TYPE i
                    RETURNING VALUE(result) TYPE i.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete state classes
*&amp;---------------------------------------------------------------------*

CLASS lcl_state_addition DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_calc.
ENDCLASS.

CLASS lcl_state_addition IMPLEMENTATION.
  METHOD lif_calc~calculate.
    result = lif_calc~number + value.
    lif_calc~number = result.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_state_subtraction DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_calc.
ENDCLASS.

CLASS lcl_state_subtraction IMPLEMENTATION.
  METHOD lif_calc~calculate.
    result = lif_calc~number - value.
    lif_calc~number = result.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_state_multiplication DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_calc.
ENDCLASS.

CLASS lcl_state_multiplication IMPLEMENTATION.
  METHOD lif_calc~calculate.
    result = lif_calc~number * value.
    lif_calc~number = result.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Class whose objects&#x27; behavior changes (Example 1)
*&amp;---------------------------------------------------------------------*

CLASS lcl_math DEFINITION.
  PUBLIC SECTION.
    METHODS:
      constructor IMPORTING start_num TYPE i,
      set_state IMPORTING state TYPE REF TO lif_calc,
      execute IMPORTING value TYPE i RETURNING VALUE(result) TYPE i.
  PRIVATE SECTION.
    DATA: num       TYPE i,
          state_ref TYPE REF TO lif_calc.
ENDCLASS.

CLASS lcl_math IMPLEMENTATION.
  METHOD constructor.
    num = start_num.
  ENDMETHOD.

  METHOD set_state.
    num = COND #( WHEN state_ref IS BOUND THEN state_ref-&gt;number ELSE num ).
    state_ref = state.
    state_ref-&gt;number = num.
  ENDMETHOD.

  METHOD execute.
    IF state_ref IS BOUND.
      result = state_ref-&gt;calculate( value ).
    ELSE.
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Class whose objects&#x27; behavior changes (Example 2)
*&amp;---------------------------------------------------------------------*

CLASS lcl_math_cond DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF ENUM calc_operation,
             plus,
             minus,
             multiply,
           END OF ENUM calc_operation.
    METHODS:
      constructor IMPORTING start_num TYPE i,
      set_state IMPORTING calc_operation TYPE lcl_math_cond=&gt;calc_operation,
      execute IMPORTING value TYPE i RETURNING VALUE(result) TYPE i.
  PRIVATE SECTION.
    DATA num TYPE i.
    DATA state_ref TYPE REF TO lif_calc.
ENDCLASS.

CLASS lcl_math_cond IMPLEMENTATION.
  METHOD constructor.
    num = start_num.
  ENDMETHOD.

  METHOD set_state.
    num = COND #( WHEN state_ref IS BOUND THEN state_ref-&gt;number ELSE num ).

    state_ref = COND #( WHEN calc_operation = plus AND state_ref IS NOT INSTANCE OF lcl_state_addition THEN NEW lcl_state_addition( )
                        WHEN calc_operation = minus AND state_ref IS NOT INSTANCE OF lcl_state_subtraction THEN NEW lcl_state_subtraction( )
                        WHEN calc_operation = multiply AND state_ref IS NOT INSTANCE OF lcl_state_multiplication THEN NEW lcl_state_multiplication( ) ).

    state_ref-&gt;number = num.
  ENDMETHOD.

  METHOD execute.
    IF state_ref IS BOUND.
      result = state_ref-&gt;calculate( value ).
    ELSE.
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Strategy</h2>
<ul>
<li>Assume you have a class and want to incorporate a set of related functionalities. Instead of overcrowding this class with multiple methods, the strategy design pattern allows you to put these functionalities in separate classes. Users can flexibly select and execute the functionality at runtime without modifying the base class code.</li>
<li>To implement this, a strategy design pattern setup might look like this:</li>
<li>A strategy interface defines a method that all concrete strategy classes must implement.</li>
<li>Concrete strategy classes implement the strategy interface and provide specific functionalities.</li>
<li>A base class maintains a reference to the strategy. Based on the strategy chosen at runtime, it delegates the execution of functionality accordingly, allowing users to interchange strategies seamlessly.</li>
<li>This pattern enables flexibility in extending and maintaining functionality without requiring code modifications in the base class. It allows for the addition of more concrete strategy classes to enhance capabilities easily.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example code includes two examples demonstrating the observer design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the <code>CCIMP</code> are relevant for the for conceptual considerations.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>The example uses a simplified calculator context (simplified also in the sense, for example, that no proper error handling is implemented). The calculator performs various arithmetic operations, representing familiar functionalities. These operations are delegated to specific strategy classes.</li>
<li>Two example setups are demonstrated: using an interface and an abstract class.</li>
<li>Example setup with an interface:</li>
<li>Interface <code>lif_calculation</code>: Defines the shared interface for concrete strategy classes, including the <code>calculate</code> method.</li>
<li>Concrete strategy classes (<code>lcl_addition</code>, <code>lcl_subtraction</code>, <code>lcl_multiplication</code>, <code>lcl_division</code>) implement the <code>lif_calculation</code> interface and provide specific calculation strategies.</li>
<li>The base class <code>lcl_calculator</code> has two methods:</li>
<li><code>set_strategy_ref</code>: Sets a reference to a strategy. It expects an object that implements the <code>lif_calculation</code> interface.</li>
<li><code>calculate</code>: Delegates execution to the concrete strategy class. This setup allows for flexible delegation at runtime to any concrete strategy class that implements the shared interface.</li>
<li>Example setup with an abstract class:</li>
<li>Abstract class <code>lcl_strategy_abstract</code>: Similar to the <code>lif_calculation</code> interface, it defines the shared interface that concrete strategy classes use.</li>
<li>Concrete strategy classes inherit from the abstract superclass and implement the abstract method.</li>
<li>The user, represented by the global class implementation, manages object creation, sets the strategy by calling the <code>set_strategy_ref</code> method, and passes appropriate objects. When the <code>calculate</code> method is called, the corresponding functionality is executed based on the previously passed object.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;---------------------------------------------------------------------*
*&amp; 1) Example setup with an interface
*&amp;---------------------------------------------------------------------*

    out-&gt;write( |1) Example setup with an interface\n| ).

    DATA(calc) = NEW lcl_calculator( ).

    calc-&gt;set_strategy_ref( NEW lcl_addition( ) ).
    DATA(result) = calc-&gt;calculate( num1 = 7 num2 = 4 ).
    out-&gt;write( |7 + 4 = { result }| ).

    calc-&gt;set_strategy_ref( NEW lcl_subtraction( ) ).
    result = calc-&gt;calculate( num1 = 25 num2 = 15 ).
    out-&gt;write( |25 - 15 = { result }| ).

    calc-&gt;set_strategy_ref( NEW lcl_multiplication( ) ).
    result = calc-&gt;calculate( num1 = 8 num2 = 4 ).
    out-&gt;write( |8 * 4 = { result }| ).

    calc-&gt;set_strategy_ref( NEW lcl_division( ) ).
    result = calc-&gt;calculate( num1 = 36 num2 = 6 ).
    out-&gt;write( |36 / 6 = { result }| ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

*&amp;---------------------------------------------------------------------*
*&amp; 2) Example setup with an abstract class
*&amp;---------------------------------------------------------------------*

    out-&gt;write( |2) Example setup with an abstract class\n| ).

    DATA(calc_abs) = NEW lcl_calc( ).

    calc_abs-&gt;set_strategy_ref( NEW lcl_add( ) ).
    result = calc_abs-&gt;calculate( num1 = 12 num2 = 8 ).
    out-&gt;write( |12 + 8 = { result }| ).

    calc_abs-&gt;set_strategy_ref( NEW lcl_sub( ) ).
    result = calc_abs-&gt;calculate( num1 = 5 num2 = 10 ).
    out-&gt;write( |5 - 10 = { result }| ).

    calc_abs-&gt;set_strategy_ref( NEW lcl_mult( ) ).
    result = calc_abs-&gt;calculate( num1 = 10 num2 = 10 ).
    out-&gt;write( |10 * 10 = { result }| ).

    calc_abs-&gt;set_strategy_ref( NEW lcl_div( ) ).
    result = calc_abs-&gt;calculate( num1 = 81 num2 = 9 ).
    out-&gt;write( |81 / 9 = { result }| ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; 1) Example setup with an interface
*&amp;---------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp; Interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_calculation.
  METHODS calculate
    IMPORTING num1          TYPE i
              num2          TYPE i
    RETURNING VALUE(result) TYPE i.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete strategy classes
*&amp;---------------------------------------------------------------------*

CLASS lcl_addition DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_calculation.
ENDCLASS.

CLASS lcl_addition IMPLEMENTATION.
  METHOD lif_calculation~calculate.
    result = num1 + num2.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_subtraction DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_calculation.
ENDCLASS.

CLASS lcl_subtraction IMPLEMENTATION.
  METHOD lif_calculation~calculate.
    result = num1 - num2.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_multiplication DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_calculation.
ENDCLASS.

CLASS lcl_multiplication IMPLEMENTATION.
  METHOD lif_calculation~calculate.
    result = num1 * num2.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_division DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_calculation.
ENDCLASS.

CLASS lcl_division IMPLEMENTATION.
  METHOD lif_calculation~calculate.
    IF num1 &lt;&gt; 0 AND num2 = 0.
      result = 0.
    ELSE.
      result = num1 / num2.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Base class that delegates the execution of functionality
*&amp;---------------------------------------------------------------------*

CLASS lcl_calculator DEFINITION.
  PUBLIC SECTION.
    METHODS:
      set_strategy_ref IMPORTING strat_ref TYPE REF TO lif_calculation,
      calculate IMPORTING num1          TYPE i
                          num2          TYPE i
                RETURNING VALUE(result) TYPE i.
  PRIVATE SECTION.
    DATA strategy TYPE REF TO lif_calculation.
ENDCLASS.

CLASS lcl_calculator IMPLEMENTATION.
  METHOD set_strategy_ref.
    me-&gt;strategy = strat_ref.
  ENDMETHOD.

  METHOD calculate.
    IF strategy IS BOUND.
      result = strategy-&gt;calculate( num1 = num1 num2 = num2 ).
    ELSE.
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
**********************************************************************
**********************************************************************

*&amp;---------------------------------------------------------------------*
*&amp; 2) Example setup with an abstract class
*&amp;---------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp; Abstract class
*&amp;---------------------------------------------------------------------*

CLASS lcl_strategy_abstract DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS calculate ABSTRACT
      IMPORTING
        num1          TYPE i
        num2          TYPE i
      RETURNING
        VALUE(result) TYPE i.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete strategy classes
*&amp;---------------------------------------------------------------------*

CLASS lcl_add DEFINITION INHERITING FROM lcl_strategy_abstract FINAL.
  PUBLIC SECTION.
    METHODS calculate REDEFINITION.
ENDCLASS.

CLASS lcl_add IMPLEMENTATION.
  METHOD calculate.
    result = num1 + num2.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_sub DEFINITION INHERITING FROM lcl_strategy_abstract FINAL.
  PUBLIC SECTION.
    METHODS calculate REDEFINITION.
ENDCLASS.

CLASS lcl_sub IMPLEMENTATION.
  METHOD calculate.
    result = num1 - num2.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_mult DEFINITION INHERITING FROM lcl_strategy_abstract FINAL.
  PUBLIC SECTION.
    METHODS calculate REDEFINITION.
ENDCLASS.

CLASS lcl_mult IMPLEMENTATION.
  METHOD calculate.
    result = num1 * num2.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_div DEFINITION INHERITING FROM lcl_strategy_abstract FINAL.
  PUBLIC SECTION.
    METHODS calculate REDEFINITION.
ENDCLASS.

CLASS lcl_div IMPLEMENTATION.
  METHOD calculate.
    IF num1 &lt;&gt; 0 AND num2 = 0.
      result = 0.
    ELSE.
      result = num1 / num2.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Base class that delegates the execution of functionality
*&amp;---------------------------------------------------------------------*

CLASS lcl_calc DEFINITION.
  PUBLIC SECTION.
    METHODS:
      set_strategy_ref IMPORTING strat_ref TYPE REF TO lcl_strategy_abstract,
      calculate IMPORTING num1          TYPE i
                          num2          TYPE i
                RETURNING VALUE(result) TYPE i.
  PRIVATE SECTION.
    DATA strategy TYPE REF TO lcl_strategy_abstract.
ENDCLASS.

CLASS lcl_calc IMPLEMENTATION.
  METHOD set_strategy_ref.
    strategy = strat_ref.
  ENDMETHOD.

  METHOD calculate.
    IF strategy IS BOUND.
      result = strategy-&gt;calculate( num1 = num1 num2 = num2 ).
    ELSE.
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Template Method</h2>
<ul>
<li>The template method design pattern suggests that a template method, typically included in an abstract superclass, defines and outlines the sequence of steps, i.e. method calls, needed to perform certain tasks.</li>
<li>Abstract methods can be defined in the abstract superclass, and calls to these methods can be included in the template method. Subclasses that inherit from the abstract superclass provide the concrete implementations of these abstract methods.</li>
<li>The template method implementation may also include calls to non-abstract methods from the abstract superclass, which are implemented in the superclass. This ensures that all users share the same functionality.</li>
<li>Thus, the template method pattern allows to organize method calls into a common structure. It enables the standard functionality provided by the superclass while allowing subclasses to flexibly modify specific methods for custom implementations. This can be helpful for use cases that involve similar tasks and require the same sequence of method calls, while still allowing for customized functionality.</li>
<li>This approach can simplify code maintenance and promote encapsulation. For example, if you need to modify the standard functionality, you only have to adapt the code in the superclass. Similarly, if a specific subclass requires code changes, you can update the abstract method implementations without altering the underlying base structure.</li>
<li>A potential, high-level class design, which is also used in the example, might look as follows:</li>
<li>An abstract class defines a common interface for its subclasses.</li>
<li>The abstract class may include:</li>
<li>Abstract methods for subclasses to implement.</li>
<li>Non-abstract methods, providing standard functionality for all users in the template method. This approach avoids code duplication.</li>
<li>A template method to orchestrate a specific sequence of method calls. These method calls may include both abstract methods (implemented in subclasses) and non-abstract methods (implemented in the abstract superclass).</li>
<li>Subclasses, representing concrete classes, inherit from the abstract superclass and must implement the abstract methods.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The following example demonstrates a consistent flow of steps defined in a template method that is common to variants. It uses an XML and JSON parsing context. The steps in the template method are as follows:</li>
<li>The XML and JSON data is provided as a string and converted to an xstring.</li>
<li>The data is then parsed.</li>
<li>The parsed data is output.</li>
<li>The example illustrates the template method design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the CCIMP include are relevant for the conceptual considerations.</li>
<li>Represents the user who expects XML and JSON data to be parsed.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li>Abstract class <code>lcl_data_parser</code></li>
<li>Serves as the common interface for all subclasses that inherit from this class.</li>
<li>Includes protected non-abstract methods (<code>convert_to_xstring</code>, <code>output_data</code>) that are implemented in the superclass.</li>
<li>Contains the abstract method <code>parse</code>, requiring subclasses to provide their own implementation.</li>
<li>Includes the public, final template method <code>template_method</code>, which specifies the sequence of method calls mentioned earlier.</li>
<li>Multiple concrete subclasses inherit from the abstract superclass, each providing custom functionality in the <code>parse</code> method:</li>
<li><code>lcl_xml_parser_ixml</code>: Reads XML data using the iXML library.</li>
<li><code>lcl_xml_parser_sxml</code>: Reads XML data using the sXML library.</li>
<li><code>lcl_json_parser_sxml</code>: Reads JSON data using the sXML library. This implementation is similar to <code>lcl_xml_parser_sxml</code> and is only included to add more concrete classes.</li>
<li><code>lcl_json_parser_ui2cljson</code>: Reads JSON data using the <code>/ui2/cl_json</code> class and the <code>generate</code> method, which creates an ABAP data object from JSON. It is also only included to add more demo concrete classes. Instead of the typical usage of the class to include JSON data in known (in this case, unknown) data objects, the implementation here explores the created data and dynamic programming techniques. It is meant for exploration purposes and neither represents best practices nor claims to cover all JSON variants (beyond the demo JSON data covered in the global class).</li>
<li>The simplified parsing returns values in a string table for display.</li>
<li>Note that the example does not include proper error handling.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.



CLASS zcl_demo_abap IMPLEMENTATION.

  METHOD if_oo_adt_classrun~main.

    out-&gt;write( |1) Parsing XML using iXML \n\n| ).

    DATA(demo_xml) =
      `&lt;?xml version=&quot;1.0&quot;?&gt;` &amp;&amp;
      `&lt;node attr_a=&quot;123&quot;&gt;` &amp;&amp;
      ` &lt;subnode1&gt;` &amp;&amp;
      `  &lt;hallo&gt;hi&lt;/hallo&gt;` &amp;&amp;
      ` &lt;/subnode1&gt;` &amp;&amp;
      ` &lt;subnode2&gt;` &amp;&amp;
      `  &lt;letter&gt;a&lt;/letter&gt;` &amp;&amp;
      `  &lt;date format=&quot;mm-dd-yyyy&quot;&gt;01-01-2025&lt;/date&gt;` &amp;&amp;
      ` &lt;/subnode2&gt;` &amp;&amp;
      ` &lt;subnode3&gt;`  &amp;&amp;
      `  &lt;text attr_b=&quot;1&quot; attr_c=&quot;a&quot;&gt;abc&lt;/text&gt;` &amp;&amp;
      `  &lt;text attr_b=&quot;2&quot; attr_c=&quot;b&quot;&gt;def&lt;/text&gt;` &amp;&amp;
      `  &lt;text attr_b=&quot;3&quot; attr_c=&quot;c&quot;&gt;ghi&lt;/text&gt;` &amp;&amp;
      `  &lt;text attr_b=&quot;4&quot; attr_c=&quot;d&quot;&gt;jkl&lt;/text&gt;` &amp;&amp;
      ` &lt;/subnode3&gt;` &amp;&amp;
      `&lt;/node&gt;`.

    DATA(oref_ixml) = NEW lcl_xml_parser_ixml( ).
    oref_ixml-&gt;template_method( data = demo_xml out = out ).

    DATA(result_ixml) = oref_ixml-&gt;result.

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |2) Parsing XML using sXML \n\n| ).

    DATA(oref_sxml) = NEW lcl_xml_parser_sxml( ).
    oref_sxml-&gt;template_method( data = demo_xml out = out ).

    DATA(result_sxml) = oref_sxml-&gt;result.

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |3) Parsing JSON using sXML \n\n| ).

    DATA(demo_json) =
       `[` &amp;&amp;
       `    {` &amp;&amp;
       `        &quot;carrier_id&quot;: &quot;LH&quot;,` &amp;&amp;
       `        &quot;connection_id&quot;: &quot;400&quot;,` &amp;&amp;
       `        &quot;city_from&quot;: &quot;Frankfurt&quot;,` &amp;&amp;
       `        &quot;city_to&quot;: &quot;Berlin&quot;` &amp;&amp;
       `    },` &amp;&amp;
       `    {` &amp;&amp;
       `        &quot;carrier_id&quot;: &quot;DL&quot;,` &amp;&amp;
       `        &quot;connection_id&quot;: &quot;1984&quot;,` &amp;&amp;
       `        &quot;city_from&quot;: &quot;San Francisco&quot;,` &amp;&amp;
       `        &quot;city_to&quot;: &quot;New York&quot;` &amp;&amp;
       `    },` &amp;&amp;
       `    {` &amp;&amp;
       `        &quot;carrier_id&quot;: &quot;AZ&quot;,` &amp;&amp;
       `        &quot;connection_id&quot;: &quot;790&quot;,` &amp;&amp;
       `        &quot;city_from&quot;: &quot;Rome&quot;,` &amp;&amp;
       `        &quot;city_to&quot;: &quot;Osaka&quot;` &amp;&amp;
       `    }` &amp;&amp;
       `]`.

    DATA(oref_json_sxml) = NEW lcl_json_parser_sxml( ).
    oref_json_sxml-&gt;template_method( data = demo_json out = out ).

    DATA(result_json_sxml) = oref_json_sxml-&gt;result.

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

**********************************************************************

    out-&gt;write( |4) Parsing JSON using /ui2/cl_json \n\n| ).

    DATA(complex_json) =
     `[` &amp;&amp;
    `{` &amp;&amp;
    `  &quot;orderId&quot;: &quot;9876&quot;,` &amp;&amp;
    `  &quot;customer&quot;: {` &amp;&amp;
    `    &quot;name&quot;: &quot;John Doe&quot;,` &amp;&amp;
    `    &quot;email&quot;: &quot;john.doe@example.com&quot;,` &amp;&amp;
    `    &quot;phone&quot;: &quot;+49-01234-56789&quot;,` &amp;&amp;
    `    &quot;address&quot;: {` &amp;&amp;
    `      &quot;street&quot;: &quot;Some Street 1&quot;,` &amp;&amp;
    `      &quot;city&quot;: &quot;Walldorf&quot;,` &amp;&amp;
    `      &quot;zipcode&quot;: &quot;12345&quot;,` &amp;&amp;
    `      &quot;state&quot;: &quot;BW&quot;,` &amp;&amp;
    `      &quot;country&quot;: &quot;Germany&quot;` &amp;&amp;
    `    }` &amp;&amp;
    `  },` &amp;&amp;
    `  &quot;items&quot;: [` &amp;&amp;
    `    {` &amp;&amp;
    `      &quot;productId&quot;: &quot;123&quot;,` &amp;&amp;
    `      &quot;name&quot;: &quot;Laptop&quot;,` &amp;&amp;
    `      &quot;quantity&quot;: 1,` &amp;&amp;
    `      &quot;price&quot;: 1200.00,` &amp;&amp;
    `      &quot;attributes&quot;: {` &amp;&amp;
    `        &quot;color&quot;: &quot;Black&quot;,` &amp;&amp;
    `        &quot;warranty&quot;: &quot;2 years&quot;` &amp;&amp;
    `      }` &amp;&amp;
    `    },` &amp;&amp;
    `    {` &amp;&amp;
    `      &quot;productId&quot;: &quot;654&quot;,` &amp;&amp;
    `      &quot;name&quot;: &quot;Keyboard&quot;,` &amp;&amp;
    `      &quot;quantity&quot;: 2,` &amp;&amp;
    `      &quot;price&quot;: 45.50,` &amp;&amp;
    `      &quot;attributes&quot;: {` &amp;&amp;
    `        &quot;color&quot;: &quot;Grey&quot;,` &amp;&amp;
    `        &quot;warranty&quot;: &quot;1 year&quot;` &amp;&amp;
    `      }` &amp;&amp;
    `    }` &amp;&amp;
    `  ],` &amp;&amp;
    `  &quot;payment&quot;: {` &amp;&amp;
    `    &quot;method&quot;: &quot;Credit card&quot;,` &amp;&amp;
    `    &quot;transactionId&quot;: &quot;t1234567890&quot;,` &amp;&amp;
    `    &quot;amount&quot;: 1291.00,` &amp;&amp;
    `    &quot;currency&quot;: &quot;EUR&quot;` &amp;&amp;
    `  },` &amp;&amp;
    `  &quot;orderDate&quot;: &quot;2025-15-01T15:36:10Z&quot;,` &amp;&amp;
    `  &quot;status&quot;: &quot;In progress&quot;` &amp;&amp;
    `}` &amp;&amp;
       `]`.

    DATA(oref_json_ui2_cl_json) = NEW lcl_json_parser_ui2cljson( ).
    oref_json_ui2_cl_json-&gt;template_method( data = complex_json out = out ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).

    &quot;More demo json
    LOOP AT VALUE string_table(
    ( `[` &amp;&amp;
    `{` &amp;&amp;
    `    &quot;name&quot;: &quot;Jane Doe&quot;,` &amp;&amp;
    `    &quot;age&quot;: 25,` &amp;&amp;
    `    &quot;height&quot;: null,` &amp;&amp;
    `    &quot;isStudent&quot;: true,` &amp;&amp;
    `    &quot;courses&quot;: [&quot;Mathematics&quot;, &quot;Computer Science&quot;, &quot;Art History&quot;]` &amp;&amp;
    `}` &amp;&amp;
    `]` )

    ( `[` &amp;&amp;
    `    &quot;lion&quot;,` &amp;&amp;
    `    &quot;elephant&quot;,` &amp;&amp;
    `    &quot;bear&quot;,` &amp;&amp;
    `    &quot;penguin&quot;` &amp;&amp;
    `]` )

    ( `{` &amp;&amp;
    `    &quot;personalInfo&quot;: {` &amp;&amp;
    `        &quot;basic&quot;: {` &amp;&amp;
    `            &quot;firstName&quot;: &quot;Jane&quot;,` &amp;&amp;
    `            &quot;lastName&quot;: &quot;Doe&quot;,` &amp;&amp;
    `            &quot;age&quot;: 24,` &amp;&amp;
    `            &quot;gender&quot;: &quot;Female&quot;,` &amp;&amp;
    `            &quot;contactDetails&quot;: {` &amp;&amp;
    `                &quot;emails&quot;: [` &amp;&amp;
    `                    &quot;jane.doe@example.com&quot;,` &amp;&amp;
    `                    &quot;janedoe@example.com&quot;` &amp;&amp;
    `                ],` &amp;&amp;
    `                &quot;phone&quot;: [` &amp;&amp;
    `                    {` &amp;&amp;
    `                        &quot;type&quot;: &quot;mobile&quot;,` &amp;&amp;
    `                        &quot;phoneNumber&quot;: &quot;0123456789&quot;` &amp;&amp;
    `                    },` &amp;&amp;
    `                    {` &amp;&amp;
    `                        &quot;type&quot;: &quot;home&quot;,` &amp;&amp;
    `                        &quot;phoneNumber&quot;: &quot;9876543210&quot;` &amp;&amp;
    `                    }` &amp;&amp;
    `                ]` &amp;&amp;
    `            }` &amp;&amp;
    `        },` &amp;&amp;
    `        &quot;address&quot;: {` &amp;&amp;
    `            &quot;currentAddress&quot;: {` &amp;&amp;
    `                &quot;street&quot;: &quot;Some Street 1&quot;,` &amp;&amp;
    `                &quot;city&quot;: &quot;Walldorf&quot;,` &amp;&amp;
    `                &quot;zipCode&quot;: &quot;69190&quot;,` &amp;&amp;
    `                &quot;state&quot;: &quot;AA&quot;,` &amp;&amp;
    `                &quot;country&quot;: &quot;Germany&quot;` &amp;&amp;
    `            },` &amp;&amp;
    `            &quot;previousAddresses&quot;: [` &amp;&amp;
    `                {` &amp;&amp;
    `                    &quot;street&quot;: &quot;Some Street 2&quot;,` &amp;&amp;
    `                    &quot;city&quot;: &quot;Somewhere&quot;,` &amp;&amp;
    `                    &quot;zipCode&quot;: &quot;12345&quot;,` &amp;&amp;
    `                    &quot;state&quot;: &quot;BB&quot;,` &amp;&amp;
    `                    &quot;country&quot;: &quot;UK&quot;` &amp;&amp;
    `                },` &amp;&amp;
    `                {` &amp;&amp;
    `                    &quot;street&quot;: &quot;Some Street 3&quot;,` &amp;&amp;
    `                    &quot;city&quot;: &quot;Another Place&quot;,` &amp;&amp;
    `                    &quot;zipCode&quot;: &quot;98765&quot;,` &amp;&amp;
    `                    &quot;state&quot;: &quot;CC&quot;,` &amp;&amp;
    `                    &quot;country&quot;: &quot;USA&quot;` &amp;&amp;
    `                }` &amp;&amp;
    `            ]` &amp;&amp;
    `        },` &amp;&amp;
    `        &quot;career&quot;: [` &amp;&amp;
    `            {` &amp;&amp;
    `                &quot;company&quot;: &quot;Some company&quot;,` &amp;&amp;
    `                &quot;role&quot;: &quot;Software Engineer&quot;,` &amp;&amp;
    `                &quot;timespan&quot;: &quot;2018-2025&quot;,` &amp;&amp;
    `                &quot;jobInformation&quot;: {` &amp;&amp;
    `                    &quot;tasks&quot;: [` &amp;&amp;
    `                        &quot;Doing something&quot;,` &amp;&amp;
    `                        &quot;Doing another thing&quot;,` &amp;&amp;
    `                        &quot;Doing this&quot;` &amp;&amp;
    `                    ],` &amp;&amp;
    `                    &quot;projects&quot;: [` &amp;&amp;
    `                        {` &amp;&amp;
    `                            &quot;name&quot;: &quot;Project A&quot;,` &amp;&amp;
    `                            &quot;description&quot;: &quot;Development of A&quot;` &amp;&amp;
    `                        },` &amp;&amp;
    `                        {` &amp;&amp;
    `                            &quot;name&quot;: &quot;Project B&quot;,` &amp;&amp;
    `                            &quot;description&quot;: &quot;Development of B&quot;` &amp;&amp;
    `                        }` &amp;&amp;
    `                    ]` &amp;&amp;
    `                }` &amp;&amp;
    `            },` &amp;&amp;
    `            {` &amp;&amp;
    `                &quot;company&quot;: &quot;Another company&quot;,` &amp;&amp;
    `                &quot;role&quot;: &quot;Developer&quot;,` &amp;&amp;
    `                &quot;timespan&quot;: &quot;2016-2018&quot;,` &amp;&amp;
    `                &quot;jobInformation&quot;: {` &amp;&amp;
    `                    &quot;tasks&quot;: [` &amp;&amp;
    `                        &quot;Doing abc&quot;,` &amp;&amp;
    `                        &quot;Doing def&quot;,` &amp;&amp;
    `                        &quot;Doing ghi&quot;` &amp;&amp;
    `                    ],` &amp;&amp;
    `                    &quot;projects&quot;: [` &amp;&amp;
    `                        {` &amp;&amp;
    `                            &quot;name&quot;: &quot;Project C&quot;,` &amp;&amp;
    `                            &quot;description&quot;: &quot;Development of C&quot;` &amp;&amp;
    `                        }` &amp;&amp;
    `                    ]` &amp;&amp;
    `                }` &amp;&amp;
    `            }` &amp;&amp;
    `        ],` &amp;&amp;
    `        &quot;education&quot;: [` &amp;&amp;
    `            {` &amp;&amp;
    `                &quot;institution&quot;: &quot;Some University&quot;,` &amp;&amp;
    `                &quot;degree&quot;: &quot;Degree A&quot;,` &amp;&amp;
    `                &quot;field&quot;: &quot;Computer Science&quot;,` &amp;&amp;
    `                &quot;attendanceTime&quot;: &quot;2012-2016&quot;,` &amp;&amp;
    `                &quot;achievements&quot;: [` &amp;&amp;
    `                    &quot;Achievement A&quot;,` &amp;&amp;
    `                    &quot;Achievement B&quot;` &amp;&amp;
    `                ]` &amp;&amp;
    `            },` &amp;&amp;
    `            {` &amp;&amp;
    `                &quot;institution&quot;: &quot;Some School&quot;,` &amp;&amp;
    `                &quot;degree&quot;: &quot;Diploma B&quot;,` &amp;&amp;
    `                &quot;attendanceTime&quot;: &quot;2008-2012&quot;` &amp;&amp;
    `            }` &amp;&amp;
    `        ]` &amp;&amp;
    `    }` &amp;&amp;
    `}` ) ) INTO DATA(json).

      DATA(oref_json_ui2_cl_json_tests) = NEW lcl_json_parser_ui2cljson( ).
      oref_json_ui2_cl_json_tests-&gt;template_method( data = json out = out ).

      out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n\n| ).
    ENDLOOP.
  ENDMETHOD.

ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>*&amp;---------------------------------------------------------------------*
*&amp; Abstract class
*&amp;---------------------------------------------------------------------*
&quot;- Serves as the common interface for all subclasses that inherit from this class.
&quot;- Includes protected non-abstract methods (&#x27;convert_to_xstring&#x27;, &#x27;output_data&#x27;)
&quot;  that are implemented in the superclass.
&quot;- Contains the abstract method &#x27;parse&#x27;, requiring subclasses to provide their own
&quot;  implementation.
&quot;- Includes the public, final template method &#x27;template_method&#x27;, which specifies
&quot;  the sequence of method calls.

CLASS lcl_data_parser DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS template_method FINAL IMPORTING data TYPE string
                                            out  TYPE REF TO if_oo_adt_classrun_out OPTIONAL.
    DATA result TYPE string_table.
  PROTECTED SECTION.
    METHODS: parse ABSTRACT IMPORTING data          TYPE xstring
                            RETURNING VALUE(result) TYPE string_table,
      convert_to_xstring IMPORTING data        TYPE string
                         RETURNING VALUE(xstr) TYPE xstring,
      output_data IMPORTING data TYPE string_table
                            out  TYPE REF TO if_oo_adt_classrun_out OPTIONAL.
ENDCLASS.

CLASS lcl_data_parser IMPLEMENTATION.

  METHOD convert_to_xstring.
    TRY.
        xstr = cl_abap_conv_codepage=&gt;create_out( codepage = `UTF-8` )-&gt;convert( data ).
      CATCH cx_sy_conversion_codepage.
        &quot;If the conversion does not work, the program flow is interrupted.
        &quot;The example does not include a proper error handling and raise a runtime error in case of a failure at this stage.
        &quot;The example is designed for the demo input data.
        ASSERT 1 = 2.
    ENDTRY.
  ENDMETHOD.

  METHOD output_data.
    IF out IS SUPPLIED AND out IS BOUND.
      out-&gt;write( data ).
    ENDIF.
    &quot;As an alternative to the output, the result is assigned
    &quot;to a public instance attribute, for example, if the reference
    &quot;variable cannot be supplied and so as to still be able to check
    &quot;out the parsing result.
    result = data.
  ENDMETHOD.

  METHOD template_method.
    &quot;Predefined steps in the template method:
    &quot;- The XML and JSON data is provided as a string and converted to an xstring.
    &quot;- The data is then parsed.
    &quot;- The parsed data is output.

    DATA(xstr) = convert_to_xstring( data ).

    DATA(output) = parse( xstr ).

    IF out IS SUPPLIED AND out IS BOUND.
      output_data( data = output
                   out  = out ).
    ELSE.
      output_data( data = output ).
    ENDIF.
  ENDMETHOD.

ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete class 1 (XML parsing using iXML)
*&amp;---------------------------------------------------------------------*

CLASS lcl_xml_parser_ixml DEFINITION INHERITING FROM lcl_data_parser.
  PROTECTED SECTION.
    METHODS parse REDEFINITION.
ENDCLASS.

CLASS lcl_xml_parser_ixml IMPLEMENTATION.
  METHOD parse.
    &quot;For notes on the code example, see the XML and JSON cheat sheet.

    DATA(ixml_pa) = cl_ixml_core=&gt;create( ).
    DATA(stream_factory_pa) = ixml_pa-&gt;create_stream_factory( ).
    DATA(document_pa) = ixml_pa-&gt;create_document( ).
    DATA(parser_pa) = ixml_pa-&gt;create_parser(
                        istream = stream_factory_pa-&gt;create_istream_xstring( string = data )
                        document = document_pa
                        stream_factory = stream_factory_pa ).

    DATA(parsing_check) = parser_pa-&gt;parse( ).
    IF parsing_check = 0.
      DATA(iterator_pa) = document_pa-&gt;create_iterator( ).
      DATA(node_pa) = iterator_pa-&gt;get_next( ).
      WHILE NOT node_pa IS INITIAL.
        DATA(node_type) = node_pa-&gt;get_type( ).
        CASE node_type.
          WHEN if_ixml_node=&gt;co_node_element.
            APPEND |Element: &quot;{ node_pa-&gt;get_name( ) }&quot;| TO result.
            DATA(attributes_pa) = node_pa-&gt;get_attributes( ).
            IF NOT attributes_pa IS INITIAL.
              DO attributes_pa-&gt;get_length( ) TIMES.
                DATA(attr) = attributes_pa-&gt;get_item( sy-index - 1 ).
                APPEND |Attribute: &quot;{ attr-&gt;get_name( ) } = { attr-&gt;get_value( ) }&quot;| TO result.
              ENDDO.
            ENDIF.
          WHEN if_ixml_node=&gt;co_node_text OR if_ixml_node=&gt;co_node_cdata_section.
            APPEND |Text: &quot;{ node_pa-&gt;get_value( ) }&quot;| TO result.
            DATA(val) = to_upper( node_pa-&gt;get_value( ) ).
            node_pa-&gt;set_value( val ).
        ENDCASE.
        node_pa = iterator_pa-&gt;get_next( ).
      ENDWHILE.
    ELSE.
      &quot;Parsing was not successful.
      &quot;The example does not include a proper error handling.
      APPEND `--- Error ---` TO result.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete class 2 (XML parsing using sXML)
*&amp;---------------------------------------------------------------------*

CLASS lcl_xml_parser_sxml DEFINITION INHERITING FROM lcl_data_parser.
  PROTECTED SECTION.
    METHODS parse REDEFINITION.
ENDCLASS.

CLASS lcl_xml_parser_sxml IMPLEMENTATION.
  METHOD parse.
    &quot;For notes on the code, see the XML and JSON cheat sheet

    DATA(reader) = cl_sxml_string_reader=&gt;create( data ).

    TRY.
        DO.
          reader-&gt;next_node( ).

          IF reader-&gt;node_type = if_sxml_node=&gt;co_nt_final.
            EXIT.
          ENDIF.

          DATA(node_type) = SWITCH #( reader-&gt;node_type WHEN if_sxml_node=&gt;co_nt_initial THEN `CO_NT_INITIAL`
                                                        WHEN if_sxml_node=&gt;co_nt_element_open THEN `CO_NT_ELEMENT_OPEN`
                                                        WHEN if_sxml_node=&gt;co_nt_element_close THEN `CO_NT_ELEMENT_CLOSE`
                                                        WHEN if_sxml_node=&gt;co_nt_value THEN `CO_NT_VALUE`
                                                        WHEN if_sxml_node=&gt;co_nt_attribute THEN `CO_NT_ATTRIBUTE`
                                                        ELSE `Error` ).

          DATA(name) = reader-&gt;name.
          DATA(value) = COND #( WHEN reader-&gt;node_type = if_sxml_node=&gt;co_nt_value THEN reader-&gt;value ).
          APPEND |{ node_type }, { name }{ COND #( WHEN value IS NOT INITIAL THEN |, { value }| ) }| TO result.

          IF reader-&gt;node_type = if_sxml_node=&gt;co_nt_element_open.
            DO.
              reader-&gt;next_attribute( ).
              IF reader-&gt;node_type &lt;&gt; if_sxml_node=&gt;co_nt_attribute.
                EXIT.
              ENDIF.
              APPEND |CO_NT_ATTRIBUTE, { reader-&gt;name }{ COND #( WHEN reader-&gt;value IS NOT INITIAL THEN |, { reader-&gt;value }| ) }| TO result.
            ENDDO.
          ENDIF.
        ENDDO.
      CATCH cx_sxml_state_error INTO DATA(error).
        &quot;The example does not include a proper error handling.
        APPEND |--- Error: { error-&gt;get_text( ) } ---| TO result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete class 3 (JSON parsing using sXML)
*&amp;---------------------------------------------------------------------*

&quot;This class demonstrates the same code as lcl_xml_parser_sxml. It is
&quot;included to add more example classes.

CLASS lcl_json_parser_sxml DEFINITION INHERITING FROM lcl_data_parser.
  PROTECTED SECTION.
    METHODS parse REDEFINITION.
ENDCLASS.

CLASS lcl_json_parser_sxml IMPLEMENTATION.
  METHOD parse.
    DATA(reader) = cl_sxml_string_reader=&gt;create( data ).

    TRY.
        DO.
          reader-&gt;next_node( ).

          IF reader-&gt;node_type = if_sxml_node=&gt;co_nt_final.
            EXIT.
          ENDIF.

          DATA(node_type) = SWITCH #( reader-&gt;node_type WHEN if_sxml_node=&gt;co_nt_initial THEN `CO_NT_INITIAL`
                                                        WHEN if_sxml_node=&gt;co_nt_element_open THEN `CO_NT_ELEMENT_OPEN`
                                                        WHEN if_sxml_node=&gt;co_nt_element_close THEN `CO_NT_ELEMENT_CLOSE`
                                                        WHEN if_sxml_node=&gt;co_nt_value THEN `CO_NT_VALUE`
                                                        WHEN if_sxml_node=&gt;co_nt_attribute THEN `CO_NT_ATTRIBUTE`
                                                        ELSE `Error` ).

          DATA(name) = reader-&gt;name.
          DATA(value) = COND #( WHEN reader-&gt;node_type = if_sxml_node=&gt;co_nt_value THEN reader-&gt;value ).
          APPEND |{ node_type }, { name }{ COND #( WHEN value IS NOT INITIAL THEN |, { value }| ) }| TO result.

          IF reader-&gt;node_type = if_sxml_node=&gt;co_nt_element_open.
            DO.
              reader-&gt;next_attribute( ).
              IF reader-&gt;node_type &lt;&gt; if_sxml_node=&gt;co_nt_attribute.
                EXIT.
              ENDIF.
              APPEND |CO_NT_ATTRIBUTE, { reader-&gt;name }{ COND #( WHEN reader-&gt;value IS NOT INITIAL THEN |, { reader-&gt;value }| ) }| TO result.
            ENDDO.
          ENDIF.
        ENDDO.
      CATCH cx_sxml_state_error INTO DATA(error).
        &quot;The example does not include a proper error handling.
        APPEND |--- Error: { error-&gt;get_text( ) } ---| TO result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete class 4 (JSON parsing using /ui2/cl_json)
*&amp;---------------------------------------------------------------------*

&quot;This class reads JSON data using the &#x27;/ui2/cl_json&#x27; class and the &#x27;generate&#x27;
&quot;method, which creates an ABAP data object from JSON. It is only included to
&quot;add more demo concrete classes.
&quot;Instead of the typical usage of the class to include JSON data in known (in
&quot;this case, unknown) data objects, the implementation here explores the created
&quot;data and experiments with dynamic programming techniques. It is a nonsensical
&quot;example that just explores and experiments. It neither represents best practices
&quot;nor claims to cover all JSON variants (beyond the demo JSON data covered in the
&quot;global class). Uncaught exceptions may occur. It is particulary not meant to
&quot;reinvent the wheel, especially with the availability of the sXML library for the
&quot;purpose. Like the other classes, the example just adds items to a string table.

CLASS lcl_json_parser_ui2cljson DEFINITION INHERITING FROM lcl_data_parser.
  PROTECTED SECTION.
    METHODS parse REDEFINITION.
  PRIVATE SECTION.

    TYPES: BEGIN OF ty_node,
             node_name     TYPE string,
             ref           TYPE REF TO data,
             is_nested     TYPE abap_boolean,
             nesting_level TYPE i,
             value         TYPE string,
             done          TYPE abap_boolean,
             kind          TYPE REF TO cl_abap_typedescr,
           END OF ty_node,
           ty_nodes TYPE TABLE OF ty_node WITH EMPTY KEY.

    METHODS:
      process_elementary IMPORTING data TYPE REF TO data
                         CHANGING  node TYPE ty_node,
      process_structure IMPORTING data          TYPE REF TO data
                                  is_nested     TYPE abap_boolean DEFAULT abap_false
                                  nesting_level TYPE i DEFAULT 0,
      process_table IMPORTING data          TYPE REF TO data
                              name          TYPE string OPTIONAL
                              is_nested     TYPE abap_boolean DEFAULT abap_false
                              nesting_level TYPE i DEFAULT 0.

    DATA: json_data  TYPE TABLE OF REF TO data,
          node_table TYPE ty_nodes,
          error      TYPE REF TO cx_root,
          tabix      LIKE sy-tabix.
ENDCLASS.

CLASS lcl_json_parser_ui2cljson IMPLEMENTATION.
  METHOD parse.
    DATA(abap_obj_from_json) = /ui2/cl_json=&gt;generate( jsonx = data ).

    &quot;Checking JSON data and adding the data to an internal table for further processing
    IF ( abap_obj_from_json IS INITIAL OR abap_obj_from_json IS NOT BOUND )
    OR ( abap_obj_from_json-&gt;* IS INITIAL ).
      APPEND `--- JSON parsing not possible ---` TO result.
      RETURN.
    ENDIF.

    TRY.
        DATA(tdo_json) = cl_abap_typedescr=&gt;describe_by_data_ref( abap_obj_from_json ).

        CASE TYPE OF tdo_json.
          WHEN TYPE cl_abap_tabledescr.
            LOOP AT abap_obj_from_json-&gt;* ASSIGNING FIELD-SYMBOL(&lt;json&gt;).
              IF &lt;json&gt; IS BOUND.
                IF &lt;json&gt;-&gt;* IS INITIAL.
                  APPEND `--- INITIAL ---` TO result.
                ELSE.
                  APPEND &lt;json&gt; TO json_data.
                ENDIF.
              ELSE.
                APPEND `--- JSON parsing not possible ---` TO result.
              ENDIF.
            ENDLOOP.
          WHEN TYPE cl_abap_structdescr.
            LOOP AT CAST cl_abap_structdescr( cl_abap_typedescr=&gt;describe_by_data_ref( abap_obj_from_json ) )-&gt;components INTO DATA(comp_json).
              ASSIGN abap_obj_from_json-&gt;(comp_json-name)-&gt;* TO FIELD-SYMBOL(&lt;co&gt;).
              APPEND REF #( &lt;co&gt; ) TO json_data.
            ENDLOOP.
          WHEN OTHERS.
            APPEND |--- Not supported by the example implementation ---| TO result.
        ENDCASE.
      CATCH cx_root INTO error .
        APPEND |--- Error: { error-&gt;get_text( ) } ---| TO result.
    ENDTRY.

    &quot;Processing JSON data in the node table
    LOOP AT json_data ASSIGNING FIELD-SYMBOL(&lt;data&gt;).
      DATA(tdo) = cl_abap_typedescr=&gt;describe_by_data_ref( &lt;data&gt; ).
      CASE TYPE OF tdo.
        WHEN TYPE cl_abap_structdescr.
          process_structure( &lt;data&gt; ).
        WHEN TYPE  cl_abap_elemdescr.
          APPEND VALUE #( ref = &lt;data&gt; ) TO node_table REFERENCE INTO DATA(elem_ref).

          process_elementary( EXPORTING data = &lt;data&gt;
                              CHANGING  node = elem_ref-&gt;* ).
        WHEN OTHERS.
          APPEND |--- Not supported by the example implementation ---| TO result.
          RETURN.
      ENDCASE.
    ENDLOOP.

    &quot;Processing nested nodes
    WHILE line_exists( node_table[ done = abap_false ] ).
      LOOP AT node_table ASSIGNING FIELD-SYMBOL(&lt;node&gt;) WHERE done = abap_false.
        tabix = sy-tabix.
        &lt;node&gt;-done = abap_true.

        IF &lt;node&gt;-kind IS BOUND.
          CASE TYPE OF &lt;node&gt;-kind.
            WHEN TYPE cl_abap_elemdescr.
              process_elementary( EXPORTING data = &lt;node&gt;-ref CHANGING node = &lt;node&gt; ).
            WHEN TYPE cl_abap_structdescr.
              process_structure( data = &lt;node&gt;-ref is_nested = &lt;node&gt;-is_nested nesting_level = &lt;node&gt;-nesting_level ).
            WHEN TYPE cl_abap_tabledescr.
              process_table( data = &lt;node&gt;-ref is_nested = &lt;node&gt;-is_nested nesting_level = &lt;node&gt;-nesting_level name = &lt;node&gt;-node_name ).
          ENDCASE.
        ELSE.
          IF &lt;node&gt;-ref IS INITIAL.
            &lt;node&gt;-value = `%%%NULL%%%`.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDWHILE.

    &quot;Putting the collected values into a string table
    IF node_table IS NOT INITIAL.
      result = VALUE #( BASE result FOR wa IN node_table
        ( |{ repeat( val = ` ` occ = wa-nesting_level ) }{ COND #( WHEN wa-node_name IS NOT INITIAL THEN |{ wa-node_name } | ) }{ wa-value }| ) ).
    ENDIF.
  ENDMETHOD.

  METHOD process_elementary.
    node-value = |{ data-&gt;* }|.
  ENDMETHOD.

  METHOD process_structure.
    LOOP AT CAST cl_abap_structdescr( cl_abap_typedescr=&gt;describe_by_data_ref( data ) )-&gt;components INTO DATA(comp).
      ASSIGN data-&gt;(comp-name) TO FIELD-SYMBOL(&lt;comp&gt;).

      IF &lt;comp&gt; IS NOT INITIAL.
        DATA(refdescr) = cl_abap_refdescr=&gt;describe_by_data( &lt;comp&gt;-&gt;* ).
      ELSE.
        CLEAR refdescr.
      ENDIF.

      IF is_nested = abap_false.
        APPEND VALUE #( node_name = comp-name
                        ref = &lt;comp&gt;
                        is_nested = COND #( WHEN refdescr IS INSTANCE OF cl_abap_structdescr OR refdescr IS INSTANCE OF cl_abap_tabledescr THEN abap_true )
                        nesting_level = COND #( WHEN nesting_level IS SUPPLIED THEN nesting_level + 1 )
                        kind = refdescr
                       ) TO node_table.
      ELSE.
        tabix += 1.

        INSERT VALUE #( node_name = comp-name
                       ref           = &lt;comp&gt;
                       is_nested = COND #( WHEN refdescr IS INSTANCE OF cl_abap_structdescr OR refdescr IS INSTANCE OF cl_abap_tabledescr THEN abap_true )
                       nesting_level = COND #( WHEN nesting_level IS SUPPLIED THEN nesting_level + 1 )
                       kind = refdescr
                      ) INTO node_table INDEX tabix.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD process_table.
    LOOP AT data-&gt;* ASSIGNING FIELD-SYMBOL(&lt;t&gt;).
      DATA(outer_index) = sy-tabix.

      TRY.
          LOOP AT CAST cl_abap_structdescr( cl_abap_typedescr=&gt;describe_by_data_ref( &lt;t&gt; ) )-&gt;components INTO DATA(comp).
            DATA(idx) = sy-tabix.

            ASSIGN &lt;t&gt;-&gt;(comp-name) TO FIELD-SYMBOL(&lt;comp&gt;).
            DATA(refdescr) = cl_abap_refdescr=&gt;describe_by_data( &lt;comp&gt;-&gt;* ).

            IF is_nested = abap_false.
              IF idx = 1.
                &quot;Inserting a divider for table nodes
                APPEND VALUE #( node_name = |--- { name }-{ outer_index } ---|
                                nesting_level = COND #( WHEN nesting_level IS SUPPLIED THEN nesting_level + 1 )
                                done          = abap_true
                              ) TO node_table.
              ENDIF.

              APPEND VALUE #( node_name = comp-name
                              ref           = &lt;comp&gt;
                              is_nested = COND #( WHEN refdescr IS INSTANCE OF cl_abap_structdescr OR refdescr IS INSTANCE OF cl_abap_tabledescr THEN abap_true )
                                nesting_level = COND #( WHEN nesting_level IS SUPPLIED THEN nesting_level + 1 )
                                kind = refdescr
                             ) TO node_table.
            ELSE.
              tabix += 1.

              IF idx = 1.
                &quot;Inserting a divider for table nodes
                INSERT VALUE #( node_name = |--- { name }-{ outer_index } ---|
                                nesting_level = COND #( WHEN nesting_level IS SUPPLIED THEN nesting_level + 1 )
                                done          = abap_true
                              ) INTO node_table INDEX tabix.

                tabix += 1.
              ENDIF.

              INSERT VALUE #( node_name = comp-name
                             ref         = &lt;comp&gt;
                             is_nested = COND #( WHEN refdescr IS INSTANCE OF cl_abap_structdescr OR refdescr IS INSTANCE OF cl_abap_tabledescr THEN abap_true )
                             nesting_level = COND #( WHEN nesting_level IS SUPPLIED THEN nesting_level + 1 )
                             kind = refdescr
                            ) INTO node_table INDEX tabix.
            ENDIF.
          ENDLOOP.
        CATCH cx_sy_move_cast_error.
          IF is_nested = abap_false.
            APPEND VALUE #( ref           = &lt;t&gt;
                            is_nested = COND #( WHEN refdescr IS INSTANCE OF cl_abap_structdescr OR refdescr IS INSTANCE OF cl_abap_tabledescr THEN abap_true )
                            nesting_level = COND #( WHEN nesting_level IS SUPPLIED THEN nesting_level + 1 )
                            kind = cl_abap_typedescr=&gt;describe_by_data( &lt;t&gt;-&gt;* )
                           ) TO node_table.
          ELSE.
            tabix += 1.

            INSERT VALUE #( ref           = &lt;t&gt;
                           is_nested = COND #( WHEN refdescr IS INSTANCE OF cl_abap_structdescr OR refdescr IS INSTANCE OF cl_abap_tabledescr THEN abap_true )
                           nesting_level = COND #( WHEN nesting_level IS SUPPLIED THEN nesting_level + 1 )
                           kind = cl_abap_typedescr=&gt;describe_by_data( &lt;t&gt;-&gt;* )
                          ) INTO node_table INDEX tabix.
          ENDIF.

      ENDTRY.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
<h2>Visitor</h2>
<ul>
<li>The visitor design pattern allows you to add functionality to objects flexibly without altering the underlying class setup. This pattern enables you to perform various operations on the same object structure without bloating the class definitions.</li>
<li>The demo example below illustrates this pattern: an object holds data (in this case, database table entries are retrieved and stored in an internal table), while different visitors can process that data through various operations, such as XML or JSON conversion. The class setup eliminates the need to add methods for each new functionality in the underlying class. In the future, if more functionalities need to be added, this approach prevents class bloating that would occur from continually adding methods. The visitor pattern offers the flexibility to extend functionality as needed, allowing users to integrate new capabilities into the object without overcrowding the original class.</li>
</ul>
<p>&lt;br&gt;</p>
<p>&lt;details&gt; &lt;summary&gt;游릭 Click to expand for more information and example code&lt;/summary&gt; &lt;!-- --&gt;</p>
<p>&lt;br&gt;</p>
<p><strong>Example notes:</strong></p>
<ul>
<li>The example code includes two examples demonstrating the observer design pattern with the following declarations and implementations:</li>
<li>Global class:</li>
<li>Implements the <code>if_oo_adt_classrun</code> interface and calls methods from local classes.</li>
<li>Serves as a vehicle for demonstrating the design pattern. The declarations and implementations in the <code>CCIMP</code> are relevant for the for conceptual considerations.</li>
<li>CCIMP include (Local Types tab in ADT):</li>
<li><code>lif_visitor</code>:</li>
<li>Defines the shared interface for visitor classes.</li>
<li>A method and attributes are defined that provide a way for different visitor implementations to interact with instances of the <code>lcl_visited</code> class.</li>
<li>The <code>visit</code> method expects an instance of the the <code>lcl_visited</code> class and can be processed further by the visitor class for whatever purpose.</li>
<li>The instance attributes <code>result_xstring</code> and <code>result_string</code> are included to store results of the processing in the <code>visit</code> method.</li>
<li><code>lcl_visited</code></li>
<li>Represents the class to be visited</li>
<li>It encapsulates the logic for loading and storing entries of a data source, and and allows visitor classes to operate on it.</li>
<li>Methods:</li>
<li><code>set_itab_content_ref</code>: Takes a the name of a data source with an optional number of entries to perform a <code>SELECT</code> statement, storing results in the data reference variable <code>table_data_ref</code>, a private attribute.</li>
<li><code>get_itab_content_ref</code>: Returns a reference to the internal table data.</li>
<li><code>receive_visitor</code>: Accepts a visitor object and calls its <code>visit</code> method, passing an object of the class itself (<code>me</code>) as an argument.</li>
<li>Concrete visitor classes</li>
<li>Each visitor class implements the <code>lif_visitor</code> interface to process the table data of <code>lcl_visited</code> differently. In doing so, the setup allows for extending the capabilities of <code>lcl_visited</code> without changing the underlying code.</li>
<li><code>lcl_visitor_xml</code>: Implements the conversion of table data into XML format using a <code>CALL TRANSFORMATION</code> statement.</li>
<li><code>lcl_visitor_json</code>: Implements the serialization of table data into JSON format using <code>/ui2/cl_json</code>.</li>
<li><code>lcl_visitor_count</code>: Determines the number of lines in the table.</li>
<li><code>lcl_visitor_cont_str</code>: Converts the table content into string format.</li>
<li>The user, represented by the global class implementation, manages object creation, calls the <code>receive_visitor</code> method and passes appropriate objects. Accessing the <code>lif_visitor~result_xstring</code> and <code>lif_visitor~result_string</code> illustrates the results of the differently implemented operations.</li>
</ul>
<p>&lt;table&gt;</p>
<p>&lt;tr&gt; &lt;td&gt; Class include &lt;/td&gt; &lt;td&gt; Code &lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>Global class</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS zcl_demo_abap DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

*&amp;-------------------------------------------------------------------------------------*
*&amp; 1) Creating an object of the class to be visited, getting data from a data source
*&amp;-------------------------------------------------------------------------------------*

    DATA(oref_lcl) = NEW lcl_visited( ).

    &quot;Getting data from a data source
    &quot;The example uses the name of a view that contains timezone data.
    &quot;Based on the name of the data source, a dynamic SELECT statement is used to
    &quot;retrieve data and store it in an internal table.
    oref_lcl-&gt;set_itab_content_ref( data_source       = `I_TIMEZONE`
                                    number_of_entries = 10 ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 2) Visitor 1 (XML transformation)
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |Visitor 1: XML transformation of internal table content\n\n| ).

    &quot;This visitor example includes the creation of an interface reference variable.
    &quot;The other examples use an object reference variable with the visitor class
    &quot;as static type directly. In doing so, the cast can be avoided to access the
    &quot;attribute.
    DATA iref_visitor_xml TYPE REF TO lif_visitor.

    iref_visitor_xml = NEW lcl_visitor_xml( ).

    oref_lcl-&gt;receive_visitor( iref_visitor_xml ).

    &quot;Transforming the internal table data to XML
    DATA(result_xml_transformation) = CAST lcl_visitor_xml( iref_visitor_xml )-&gt;lif_visitor~result_xstring.

    &quot;Transformation XML -&gt; ABAP for display purposes
    DATA tab_from_xml TYPE TABLE OF i_timezone WITH EMPTY KEY.
    CALL TRANSFORMATION id SOURCE XML result_xml_transformation
                           RESULT itab = tab_from_xml.

    out-&gt;write( data = tab_from_xml name = `tab_from_xml` ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 3) Visitor 2 (JSON serialization)
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |Visitor 2: JSON serialization\n\n| ).

    DATA(oref_visitor_json) = NEW lcl_visitor_json( ).

    oref_lcl-&gt;receive_visitor( oref_visitor_json ).

    &quot;Serializing the internal table data
    DATA(result_json_serialization) = oref_visitor_json-&gt;lif_visitor~result_xstring.

    &quot;Deserializing for display purposes
    DATA tab_from_json LIKE tab_from_xml.
    /ui2/cl_json=&gt;deserialize( EXPORTING jsonx = result_json_serialization
                               CHANGING data  = tab_from_json ).

    out-&gt;write( data = tab_from_json name = `tab_from_json` ).
    out-&gt;write( |\n\n| ).

    &quot;The example implementation also includes the assignment of the
    &quot;interface attribute of type string.
    DATA(result_json_serialization_str) = oref_visitor_json-&gt;lif_visitor~result_string.

    out-&gt;write( result_json_serialization_str ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 4) Visitor 3 (Counting table entries)
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |Visitor 3: Counting the internal table entries\n| ).

    DATA(oref_visitor_count) = NEW lcl_visitor_count( ).

    oref_lcl-&gt;receive_visitor( oref_visitor_count ).

    &quot;Getting the table entry count
    DATA(result_count) = oref_visitor_count-&gt;lif_visitor~result_string.

    out-&gt;write( result_count ).

    out-&gt;write( |\n{ repeat( val = `*` occ = 75 ) }\n| ).

*&amp;-------------------------------------------------------------------------------------*
*&amp; 5) Visitor 4 (Converting table content into string)
*&amp;-------------------------------------------------------------------------------------*

    out-&gt;write( |Visitor 4: Converting the internal table content into a string\n| ).

    DATA(oref_visitor_cont_str) = NEW lcl_visitor_cont_str( ).

    oref_lcl-&gt;receive_visitor( oref_visitor_cont_str ).

    &quot;Getting the string holding the internal table content
    DATA(result_cont_str) = oref_visitor_cont_str-&gt;lif_visitor~result_string.

    out-&gt;write( result_cont_str ).
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;tr&gt; &lt;td&gt;</p>
<p>CCIMP include (Local Types tab in ADT)</p>
<p>&lt;/td&gt;</p>
<p>&lt;td&gt;</p>
<pre><code>CLASS lcl_visited DEFINITION DEFERRED.

*&amp;---------------------------------------------------------------------*
*&amp; Interface
*&amp;---------------------------------------------------------------------*

INTERFACE lif_visitor.
  DATA result_xstring TYPE xstring.
  DATA result_string TYPE string.
  METHODS visit IMPORTING oref TYPE REF TO lcl_visited.
ENDINTERFACE.

*&amp;---------------------------------------------------------------------*
*&amp; Class to be visited
*&amp;---------------------------------------------------------------------*

CLASS lcl_visited DEFINITION.
  PUBLIC SECTION.
    METHODS: set_itab_content_ref IMPORTING VALUE(data_source) TYPE string
                                            number_of_entries  TYPE i OPTIONAL,
      get_itab_content_ref RETURNING VALUE(content) TYPE REF TO data,
      receive_visitor IMPORTING obj TYPE REF TO lif_visitor.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA table_data_ref TYPE REF TO data.
ENDCLASS.

CLASS lcl_visited IMPLEMENTATION.

  METHOD set_itab_content_ref.
    data_source = to_upper( condense( val = data_source to = `` ) ).

    &quot;The example implementation includes a dynamic SELECT statement.
    &quot;The example goes without appropriate checks regarding dynamically
    &quot;inserting content from outside. Refer to the Dynamic Programming
    &quot;ABAP cheat sheet.
    IF number_of_entries IS SUPPLIED.
      SELECT * FROM (data_source) INTO TABLE NEW @table_data_ref UP TO @number_of_entries ROWS.
    ELSE.
      SELECT * FROM (data_source) INTO TABLE NEW @table_data_ref.
    ENDIF.
  ENDMETHOD.

  METHOD receive_visitor.
    &quot;Passing an object of this class to the concrete visitor.
    obj-&gt;visit( me ).
  ENDMETHOD.

  METHOD get_itab_content_ref.
    IF table_data_ref IS BOUND.
      TRY.
          &quot;Is a table
          DATA(tdo) = CAST cl_abap_tabledescr( cl_abap_typedescr=&gt;describe_by_data_ref( table_data_ref ) ).
        CATCH cx_root.
          &quot;Is not a table
          RETURN.
      ENDTRY.
      content = table_data_ref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete visitor 1: XML transformation
*&amp;---------------------------------------------------------------------*

CLASS lcl_visitor_xml DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_visitor.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_visitor_xml IMPLEMENTATION.
  METHOD lif_visitor~visit.


    DATA(tab_content) = oref-&gt;get_itab_content_ref( ).
    IF tab_content IS BOUND.
      CALL TRANSFORMATION id SOURCE itab = tab_content-&gt;*
                             RESULT XML lif_visitor~result_xstring.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete visitor 2: JSON serialization
*&amp;---------------------------------------------------------------------*

CLASS lcl_visitor_json DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_visitor.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_visitor_json IMPLEMENTATION.
  METHOD lif_visitor~visit.
    DATA(tab_content) = oref-&gt;get_itab_content_ref( ).
    IF tab_content IS BOUND.
      lif_visitor~result_string = /ui2/cl_json=&gt;serialize( data = tab_content-&gt;* format_output = abap_true ).
      lif_visitor~result_xstring = cl_abap_conv_codepage=&gt;create_out( codepage = `UTF-8` )-&gt;convert( lif_visitor~result_string ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete visitor 3: Counting table entries
*&amp;---------------------------------------------------------------------*

CLASS lcl_visitor_count DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_visitor.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_visitor_count IMPLEMENTATION.
  METHOD lif_visitor~visit.
    DATA(tab_content) = oref-&gt;get_itab_content_ref( ).
    IF tab_content IS BOUND.
      lif_visitor~result_string = lines( tab_content-&gt;* ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp; Concrete visitor 4: Converting table content into string
*&amp;---------------------------------------------------------------------*

CLASS lcl_visitor_cont_str DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_visitor.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_visitor_cont_str IMPLEMENTATION.
  METHOD lif_visitor~visit.
    DATA(tab_content) = oref-&gt;get_itab_content_ref( ).
    IF tab_content IS BOUND.
      LOOP AT tab_content-&gt;* ASSIGNING FIELD-SYMBOL(&lt;fs&gt;).
        DO.
          ASSIGN &lt;fs&gt;-(sy-index) TO FIELD-SYMBOL(&lt;comp&gt;).
          IF sy-subrc = 0.
            lif_visitor~result_string &amp;&amp;= &lt;comp&gt; &amp;&amp; `, ` .
          ELSE.
            EXIT.
          ENDIF.
        ENDDO.
        &quot;Replacing the final comma in the string and adding a line break
        lif_visitor~result_string = replace( val = lif_visitor~result_string pcre = `,([^,]*)$` with = `` ).
        lif_visitor~result_string &amp;&amp;= |\n|.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
ENDCLASS.</code></pre>
<p>&lt;/td&gt; &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
<p>&lt;/details&gt;</p>
<p>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;#top&quot;&gt;拘勇 back to top&lt;/a&gt;&lt;/p&gt;</p>
</body>
</html>